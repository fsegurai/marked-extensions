/**
 * marked v17.0.2 - a markdown parser
 * Copyright (c) 2018-2026, MarkedJS. (MIT License)
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT License)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function M$2(){return {async:false,breaks:false,extensions:null,gfm:true,hooks:null,pedantic:false,renderer:null,silent:false,tokenizer:null,walkTokens:null}}var T$2=M$2();function H$2(u){T$2=u;}var _$2={exec:()=>null};function k$2(u,e=""){let t=typeof u=="string"?u:u.source,n={replace:(r,i)=>{let s=typeof i=="string"?i:i.source;return s=s.replace(m$2.caret,"$1"),t=t.replace(r,s),n},getRegex:()=>new RegExp(t,e)};return n}var Re$2=(()=>{try{return !!new RegExp("(?<=1)(?<!1)")}catch{return  false}})(),m$2={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] +\S/,listReplaceTask:/^\[[ xX]\] +/,listTaskCheckbox:/\[[ xX]\]/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:u=>new RegExp(`^( {0,3}${u})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}#`),htmlBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}<(?:[a-z].*>|!--)`,"i"),blockquoteBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}>`)},Te$2=/^(?:[ \t]*(?:\n|$))+/,Oe$2=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,we$2=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,I$2=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,ye$2=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,N$2=/ {0,3}(?:[*+-]|\d{1,9}[.)])/,re$2=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,se$2=k$2(re$2).replace(/bull/g,N$2).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),Pe$2=k$2(re$2).replace(/bull/g,N$2).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),Q$2=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,Se$2=/^[^\n]+/,F$2=/(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,$e$2=k$2(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",F$2).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),_e$2=k$2(/^(bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,N$2).getRegex(),q$2="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",j$2=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,Le$2=k$2("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",j$2).replace("tag",q$2).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),ie$2=k$2(Q$2).replace("hr",I$2).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$2).getRegex(),Me$2=k$2(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",ie$2).getRegex(),U$2={blockquote:Me$2,code:Oe$2,def:$e$2,fences:we$2,heading:ye$2,hr:I$2,html:Le$2,lheading:se$2,list:_e$2,newline:Te$2,paragraph:ie$2,table:_$2,text:Se$2},te$2=k$2("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",I$2).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$2).getRegex(),ze$2={...U$2,lheading:Pe$2,table:te$2,paragraph:k$2(Q$2).replace("hr",I$2).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",te$2).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$2).getRegex()},Ce$2={...U$2,html:k$2(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",j$2).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:_$2,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:k$2(Q$2).replace("hr",I$2).replace("heading",` *#{1,6} *[^
]`).replace("lheading",se$2).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},Ae$2=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,Ie$2=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,oe$2=/^( {2,}|\\)\n(?!\s*$)/,Ee$2=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,v$2=/[\p{P}\p{S}]/u,K$2=/[\s\p{P}\p{S}]/u,ae$2=/[^\s\p{P}\p{S}]/u,Be$2=k$2(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,K$2).getRegex(),le$2=/(?!~)[\p{P}\p{S}]/u,De$2=/(?!~)[\s\p{P}\p{S}]/u,qe$2=/(?:[^\s\p{P}\p{S}]|~)/u,ue$2=/(?![*_])[\p{P}\p{S}]/u,ve$2=/(?![*_])[\s\p{P}\p{S}]/u,Ge$2=/(?:[^\s\p{P}\p{S}]|[*_])/u,He$2=k$2(/link|precode-code|html/,"g").replace("link",/\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-",Re$2?"(?<!`)()":"(^^|[^`])").replace("code",/(?<b>`+)[^`]+\k<b>(?!`)/).replace("html",/<(?! )[^<>]*?>/).getRegex(),pe$2=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,Ze$2=k$2(pe$2,"u").replace(/punct/g,v$2).getRegex(),Ne$2=k$2(pe$2,"u").replace(/punct/g,le$2).getRegex(),ce$2="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",Qe$2=k$2(ce$2,"gu").replace(/notPunctSpace/g,ae$2).replace(/punctSpace/g,K$2).replace(/punct/g,v$2).getRegex(),Fe$2=k$2(ce$2,"gu").replace(/notPunctSpace/g,qe$2).replace(/punctSpace/g,De$2).replace(/punct/g,le$2).getRegex(),je$2=k$2("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ae$2).replace(/punctSpace/g,K$2).replace(/punct/g,v$2).getRegex(),Ue$2=k$2(/^~~?(?:((?!~)punct)|[^\s~])/,"u").replace(/punct/g,ue$2).getRegex(),Ke$2="^[^~]+(?=[^~])|(?!~)punct(~~?)(?=[\\s]|$)|notPunctSpace(~~?)(?!~)(?=punctSpace|$)|(?!~)punctSpace(~~?)(?=notPunctSpace)|[\\s](~~?)(?!~)(?=punct)|(?!~)punct(~~?)(?!~)(?=punct)|notPunctSpace(~~?)(?=notPunctSpace)",We$2=k$2(Ke$2,"gu").replace(/notPunctSpace/g,Ge$2).replace(/punctSpace/g,ve$2).replace(/punct/g,ue$2).getRegex(),Xe$2=k$2(/\\(punct)/,"gu").replace(/punct/g,v$2).getRegex(),Je$2=k$2(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Ve$2=k$2(j$2).replace("(?:-->|$)","-->").getRegex(),Ye$2=k$2("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",Ve$2).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),D$2=/(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/,et$2=k$2(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",D$2).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),he$2=k$2(/^!?\[(label)\]\[(ref)\]/).replace("label",D$2).replace("ref",F$2).getRegex(),ke$2=k$2(/^!?\[(ref)\](?:\[\])?/).replace("ref",F$2).getRegex(),tt$2=k$2("reflink|nolink(?!\\()","g").replace("reflink",he$2).replace("nolink",ke$2).getRegex(),ne$2=/[hH][tT][tT][pP][sS]?|[fF][tT][pP]/,W$2={_backpedal:_$2,anyPunctuation:Xe$2,autolink:Je$2,blockSkip:He$2,br:oe$2,code:Ie$2,del:_$2,delLDelim:_$2,delRDelim:_$2,emStrongLDelim:Ze$2,emStrongRDelimAst:Qe$2,emStrongRDelimUnd:je$2,escape:Ae$2,link:et$2,nolink:ke$2,punctuation:Be$2,reflink:he$2,reflinkSearch:tt$2,tag:Ye$2,text:Ee$2,url:_$2},nt$2={...W$2,link:k$2(/^!?\[(label)\]\((.*?)\)/).replace("label",D$2).getRegex(),reflink:k$2(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",D$2).getRegex()},Z$2={...W$2,emStrongRDelimAst:Fe$2,emStrongLDelim:Ne$2,delLDelim:Ue$2,delRDelim:We$2,url:k$2(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol",ne$2).replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,text:k$2(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol",ne$2).getRegex()},rt$2={...Z$2,br:k$2(oe$2).replace("{2,}","*").getRegex(),text:k$2(Z$2.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},E$2={normal:U$2,gfm:ze$2,pedantic:Ce$2},z$2={normal:W$2,gfm:Z$2,breaks:rt$2,pedantic:nt$2};var st$2={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},de$2=u=>st$2[u];function O$2(u,e){if(e){if(m$2.escapeTest.test(u))return u.replace(m$2.escapeReplace,de$2)}else if(m$2.escapeTestNoEncode.test(u))return u.replace(m$2.escapeReplaceNoEncode,de$2);return u}function X$2(u){try{u=encodeURI(u).replace(m$2.percentDecode,"%");}catch{return null}return u}function J$2(u,e){let t=u.replace(m$2.findPipe,(i,s,a)=>{let o=false,l=s;for(;--l>=0&&a[l]==="\\";)o=!o;return o?"|":" |"}),n=t.split(m$2.splitPipe),r=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(m$2.slashPipe,"|");return n}function C$2(u,e,t){let n=u.length;if(n===0)return "";let r=0;for(;r<n;){let i=u.charAt(n-r-1);if(i===e&&true)r++;else break}return u.slice(0,n-r)}function ge$2(u,e){if(u.indexOf(e[1])===-1)return  -1;let t=0;for(let n=0;n<u.length;n++)if(u[n]==="\\")n++;else if(u[n]===e[0])t++;else if(u[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function fe$2(u,e=0){let t=e,n="";for(let r of u)if(r==="	"){let i=4-t%4;n+=" ".repeat(i),t+=i;}else n+=r,t++;return n}function me$2(u,e,t,n,r){let i=e.href,s=e.title||null,a=u[1].replace(r.other.outputLinkReplace,"$1");n.state.inLink=true;let o={type:u[0].charAt(0)==="!"?"image":"link",raw:t,href:i,title:s,text:a,tokens:n.inlineTokens(a)};return n.state.inLink=false,o}function it$2(u,e,t){let n=u.match(t.other.indentCodeCompensation);if(n===null)return e;let r=n[1];return e.split(`
`).map(i=>{let s=i.match(t.other.beginningSpace);if(s===null)return i;let[a]=s;return a.length>=r.length?i.slice(r.length):i}).join(`
`)}var w$2=class w{options;rules;lexer;constructor(e){this.options=e||T$2;}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return {type:"space",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,"");return {type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:C$2(n,`
`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],r=it$2(n,t[3]||"",this.rules);return {type:"code",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):t[2],text:r}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let r=C$2(n,"#");(this.options.pedantic||!r||this.rules.other.endingSpaceChar.test(r))&&(n=r.trim());}return {type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return {type:"hr",raw:C$2(t[0],`
`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=C$2(t[0],`
`).split(`
`),r="",i="",s=[];for(;n.length>0;){let a=false,o=[],l;for(l=0;l<n.length;l++)if(this.rules.other.blockquoteStart.test(n[l]))o.push(n[l]),a=true;else if(!a)o.push(n[l]);else break;n=n.slice(l);let p=o.join(`
`),c=p.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");r=r?`${r}
${p}`:p,i=i?`${i}
${c}`:c;let d=this.lexer.state.top;if(this.lexer.state.top=true,this.lexer.blockTokens(c,s,true),this.lexer.state.top=d,n.length===0)break;let h=s.at(-1);if(h?.type==="code")break;if(h?.type==="blockquote"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.blockquote(f);s[s.length-1]=S,r=r.substring(0,r.length-R.raw.length)+S.raw,i=i.substring(0,i.length-R.text.length)+S.text;break}else if(h?.type==="list"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.list(f);s[s.length-1]=S,r=r.substring(0,r.length-h.raw.length)+S.raw,i=i.substring(0,i.length-R.raw.length)+S.raw,n=f.substring(s.at(-1).raw.length).split(`
`);continue}}return {type:"blockquote",raw:r,tokens:s,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),r=n.length>1,i={type:"list",raw:"",ordered:r,start:r?+n.slice(0,-1):"",loose:false,items:[]};n=r?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=r?n:"[*+-]");let s=this.rules.other.listItemRegex(n),a=false;for(;e;){let l=false,p="",c="";if(!(t=s.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let d=fe$2(t[2].split(`
`,1)[0],t[1].length),h=e.split(`
`,1)[0],R=!d.trim(),f=0;if(this.options.pedantic?(f=2,c=d.trimStart()):R?f=t[1].length+1:(f=d.search(this.rules.other.nonSpaceChar),f=f>4?1:f,c=d.slice(f),f+=t[1].length),R&&this.rules.other.blankLine.test(h)&&(p+=h+`
`,e=e.substring(h.length+1),l=true),!l){let S=this.rules.other.nextBulletRegex(f),V=this.rules.other.hrRegex(f),Y=this.rules.other.fencesBeginRegex(f),ee=this.rules.other.headingBeginRegex(f),xe=this.rules.other.htmlBeginRegex(f),be=this.rules.other.blockquoteBeginRegex(f);for(;e;){let G=e.split(`
`,1)[0],A;if(h=G,this.options.pedantic?(h=h.replace(this.rules.other.listReplaceNesting,"  "),A=h):A=h.replace(this.rules.other.tabCharGlobal,"    "),Y.test(h)||ee.test(h)||xe.test(h)||be.test(h)||S.test(h)||V.test(h))break;if(A.search(this.rules.other.nonSpaceChar)>=f||!h.trim())c+=`
`+A.slice(f);else {if(R||d.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||Y.test(d)||ee.test(d)||V.test(d))break;c+=`
`+h;}R=!h.trim(),p+=G+`
`,e=e.substring(G.length+1),d=A.slice(f);}}i.loose||(a?i.loose=true:this.rules.other.doubleBlankLine.test(p)&&(a=true)),i.items.push({type:"list_item",raw:p,task:!!this.options.gfm&&this.rules.other.listIsTask.test(c),loose:false,text:c,tokens:[]}),i.raw+=p;}let o=i.items.at(-1);if(o)o.raw=o.raw.trimEnd(),o.text=o.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let l of i.items){if(this.lexer.state.top=false,l.tokens=this.lexer.blockTokens(l.text,[]),l.task){if(l.text=l.text.replace(this.rules.other.listReplaceTask,""),l.tokens[0]?.type==="text"||l.tokens[0]?.type==="paragraph"){l.tokens[0].raw=l.tokens[0].raw.replace(this.rules.other.listReplaceTask,""),l.tokens[0].text=l.tokens[0].text.replace(this.rules.other.listReplaceTask,"");for(let c=this.lexer.inlineQueue.length-1;c>=0;c--)if(this.rules.other.listIsTask.test(this.lexer.inlineQueue[c].src)){this.lexer.inlineQueue[c].src=this.lexer.inlineQueue[c].src.replace(this.rules.other.listReplaceTask,"");break}}let p=this.rules.other.listTaskCheckbox.exec(l.raw);if(p){let c={type:"checkbox",raw:p[0]+" ",checked:p[0]!=="[ ]"};l.checked=c.checked,i.loose?l.tokens[0]&&["paragraph","text"].includes(l.tokens[0].type)&&"tokens"in l.tokens[0]&&l.tokens[0].tokens?(l.tokens[0].raw=c.raw+l.tokens[0].raw,l.tokens[0].text=c.raw+l.tokens[0].text,l.tokens[0].tokens.unshift(c)):l.tokens.unshift({type:"paragraph",raw:c.raw,text:c.raw,tokens:[c]}):l.tokens.unshift(c);}}if(!i.loose){let p=l.tokens.filter(d=>d.type==="space"),c=p.length>0&&p.some(d=>this.rules.other.anyLine.test(d.raw));i.loose=c;}}if(i.loose)for(let l of i.items){l.loose=true;for(let p of l.tokens)p.type==="text"&&(p.type="paragraph");}return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return {type:"html",block:true,raw:t[0],pre:t[1]==="pre"||t[1]==="script"||t[1]==="style",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),r=t[2]?t[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):t[3];return {type:"def",tag:n,raw:t[0],href:r,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=J$2(t[1]),r=t[2].replace(this.rules.other.tableAlignChars,"").split("|"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:t[0],header:[],align:[],rows:[]};if(n.length===r.length){for(let a of r)this.rules.other.tableAlignRight.test(a)?s.align.push("right"):this.rules.other.tableAlignCenter.test(a)?s.align.push("center"):this.rules.other.tableAlignLeft.test(a)?s.align.push("left"):s.align.push(null);for(let a=0;a<n.length;a++)s.header.push({text:n[a],tokens:this.lexer.inline(n[a]),header:true,align:s.align[a]});for(let a of i)s.rows.push(J$2(a,s.header.length).map((o,l)=>({text:o,tokens:this.lexer.inline(o),header:false,align:s.align[l]})));return s}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return {type:"heading",raw:t[0],depth:t[2].charAt(0)==="="?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`
`?t[1].slice(0,-1):t[1];return {type:"paragraph",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return {type:"text",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return {type:"escape",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return !this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=true:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=false),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=true:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=false),{type:"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:false,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let s=C$2(n.slice(0,-1),"\\");if((n.length-s.length)%2===0)return}else {let s=ge$2(t[2],"()");if(s===-2)return;if(s>-1){let o=(t[0].indexOf("!")===0?5:4)+t[1].length+s;t[2]=t[2].substring(0,s),t[0]=t[0].substring(0,o).trim(),t[3]="";}}let r=t[2],i="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(r);s&&(r=s[1],i=s[3]);}else i=t[3]?t[3].slice(1,-1):"";return r=r.trim(),this.rules.other.startAngleBracket.test(r)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?r=r.slice(1):r=r.slice(1,-1)),me$2(t,{href:r&&r.replace(this.rules.inline.anyPunctuation,"$1"),title:i&&i.replace(this.rules.inline.anyPunctuation,"$1")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let r=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),i=t[r.toLowerCase()];if(!i){let s=n[0].charAt(0);return {type:"text",raw:s,text:s}}return me$2(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=""){let r=this.rules.inline.emStrongLDelim.exec(e);if(!r||r[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(r[1]||r[2]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=0,c=r[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+s);(r=c.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a)continue;if(o=[...a].length,r[3]||r[4]){l+=o;continue}else if((r[5]||r[6])&&s%3&&!((s+o)%3)){p+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l+p);let d=[...r[0]][0].length,h=e.slice(0,s+r.index+d+o);if(Math.min(s,o)%2){let f=h.slice(1,-1);return {type:"em",raw:h,text:f,tokens:this.lexer.inlineTokens(f)}}let R=h.slice(2,-2);return {type:"strong",raw:h,text:R,tokens:this.lexer.inlineTokens(R)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal," "),r=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return r&&i&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return {type:"br",raw:t[0]}}del(e,t,n=""){let r=this.rules.inline.delLDelim.exec(e);if(!r)return;if(!(r[1]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=this.rules.inline.delRDelim;for(p.lastIndex=0,t=t.slice(-1*e.length+s);(r=p.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a||(o=[...a].length,o!==s))continue;if(r[3]||r[4]){l+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l);let c=[...r[0]][0].length,d=e.slice(0,s+r.index+c+o),h=d.slice(s,-s);return {type:"del",raw:d,text:h,tokens:this.lexer.inlineTokens(h)}}}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,r;return t[2]==="@"?(n=t[1],r="mailto:"+n):(n=t[1],r=n),{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,r;if(t[2]==="@")n=t[0],r="mailto:"+n;else {let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??"";while(i!==t[0]);n=t[0],t[1]==="www."?r="http://"+t[0]:r=t[0];}return {type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return {type:"text",raw:t[0],text:t[0],escaped:n}}}};var x$2=class u{tokens;options;state;inlineQueue;tokenizer;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||T$2,this.options.tokenizer=this.options.tokenizer||new w$2,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:false,inRawBlock:false,top:true};let t={other:m$2,block:E$2.normal,inline:z$2.normal};this.options.pedantic?(t.block=E$2.pedantic,t.inline=z$2.pedantic):this.options.gfm&&(t.block=E$2.gfm,this.options.breaks?t.inline=z$2.breaks:t.inline=z$2.gfm),this.tokenizer.rules=t;}static get rules(){return {block:E$2,inline:z$2}}static lex(e,t){return new u(t).lex(e)}static lexInline(e,t){return new u(t).inlineTokens(e)}lex(e){e=e.replace(m$2.carriageReturn,`
`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens);}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=false){for(this.options.pedantic&&(e=e.replace(m$2.tabCharGlobal,"    ").replace(m$2.spaceLine,""));e;){let r;if(this.options.extensions?.block?.some(s=>(r=s.call({lexer:this},e,t))?(e=e.substring(r.raw.length),t.push(r),true):false))continue;if(r=this.tokenizer.space(e)){e=e.substring(r.raw.length);let s=t.at(-1);r.raw.length===1&&s!==void 0?s.raw+=`
`:t.push(r);continue}if(r=this.tokenizer.code(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(r=this.tokenizer.fences(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.heading(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.hr(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.blockquote(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.list(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.html(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.def(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.raw,this.inlineQueue.at(-1).src=s.text):this.tokens.links[r.tag]||(this.tokens.links[r.tag]={href:r.href,title:r.title},t.push(r));continue}if(r=this.tokenizer.table(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.lheading(e)){e=e.substring(r.raw.length),t.push(r);continue}let i=e;if(this.options.extensions?.startBlock){let s=1/0,a=e.slice(1),o;this.options.extensions.startBlock.forEach(l=>{o=l.call({lexer:this},a),typeof o=="number"&&o>=0&&(s=Math.min(s,o));}),s<1/0&&s>=0&&(i=e.substring(0,s+1));}if(this.state.top&&(r=this.tokenizer.paragraph(i))){let s=t.at(-1);n&&s?.type==="paragraph"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r),n=i.length!==e.length,e=e.substring(r.raw.length);continue}if(r=this.tokenizer.text(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(e){let s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=true,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,r=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,r.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let i;for(;(r=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)i=r[2]?r[2].length:0,n=n.slice(0,r.index+i)+"["+"a".repeat(r[0].length-i-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);n=this.options.hooks?.emStrongMask?.call({lexer:this},n)??n;let s=false,a="";for(;e;){s||(a=""),s=false;let o;if(this.options.extensions?.inline?.some(p=>(o=p.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),true):false))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let p=t.at(-1);o.type==="text"&&p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let l=e;if(this.options.extensions?.startInline){let p=1/0,c=e.slice(1),d;this.options.extensions.startInline.forEach(h=>{d=h.call({lexer:this},c),typeof d=="number"&&d>=0&&(p=Math.min(p,d));}),p<1/0&&p>=0&&(l=e.substring(0,p+1));}if(o=this.tokenizer.inlineText(l)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(a=o.raw.slice(-1)),s=true;let p=t.at(-1);p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(e){let p="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(p);break}else throw new Error(p)}}return t}};var y$2=class y{options;parser;constructor(e){this.options=e||T$2;}space(e){return ""}code({text:e,lang:t,escaped:n}){let r=(t||"").match(m$2.notSpaceStart)?.[0],i=e.replace(m$2.endingNewline,"")+`
`;return r?'<pre><code class="language-'+O$2(r)+'">'+(n?i:O$2(i,true))+`</code></pre>
`:"<pre><code>"+(n?i:O$2(i,true))+`</code></pre>
`}blockquote({tokens:e}){return `<blockquote>
${this.parser.parse(e)}</blockquote>
`}html({text:e}){return e}def(e){return ""}heading({tokens:e,depth:t}){return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`}hr(e){return `<hr>
`}list(e){let t=e.ordered,n=e.start,r="";for(let a=0;a<e.items.length;a++){let o=e.items[a];r+=this.listitem(o);}let i=t?"ol":"ul",s=t&&n!==1?' start="'+n+'"':"";return "<"+i+s+`>
`+r+"</"+i+`>
`}listitem(e){return `<li>${this.parser.parse(e.tokens)}</li>
`}checkbox({checked:e}){return "<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"> '}paragraph({tokens:e}){return `<p>${this.parser.parseInline(e)}</p>
`}table(e){let t="",n="";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let r="";for(let i=0;i<e.rows.length;i++){let s=e.rows[i];n="";for(let a=0;a<s.length;a++)n+=this.tablecell(s[a]);r+=this.tablerow({text:n});}return r&&(r=`<tbody>${r}</tbody>`),`<table>
<thead>
`+t+`</thead>
`+r+`</table>
`}tablerow({text:e}){return `<tr>
${e}</tr>
`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?"th":"td";return (e.align?`<${n} align="${e.align}">`:`<${n}>`)+t+`</${n}>
`}strong({tokens:e}){return `<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return `<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return `<code>${O$2(e,true)}</code>`}br(e){return "<br>"}del({tokens:e}){return `<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let r=this.parser.parseInline(n),i=X$2(e);if(i===null)return r;e=i;let s='<a href="'+e+'"';return t&&(s+=' title="'+O$2(t)+'"'),s+=">"+r+"</a>",s}image({href:e,title:t,text:n,tokens:r}){r&&(n=this.parser.parseInline(r,this.parser.textRenderer));let i=X$2(e);if(i===null)return O$2(n);e=i;let s=`<img src="${e}" alt="${n}"`;return t&&(s+=` title="${O$2(t)}"`),s+=">",s}text(e){return "tokens"in e&&e.tokens?this.parser.parseInline(e.tokens):"escaped"in e&&e.escaped?e.text:O$2(e.text)}};var $$2=class ${strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return ""+e}image({text:e}){return ""+e}br(){return ""}checkbox({raw:e}){return e}};var b$2=class u{options;renderer;textRenderer;constructor(e){this.options=e||T$2,this.options.renderer=this.options.renderer||new y$2,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new $$2;}static parse(e,t){return new u(t).parse(e)}static parseInline(e,t){return new u(t).parseInline(e)}parse(e){let t="";for(let n=0;n<e.length;n++){let r=e[n];if(this.options.extensions?.renderers?.[r.type]){let s=r,a=this.options.extensions.renderers[s.type].call({parser:this},s);if(a!==false||!["space","hr","heading","code","table","blockquote","list","html","def","paragraph","text"].includes(s.type)){t+=a||"";continue}}let i=r;switch(i.type){case "space":{t+=this.renderer.space(i);break}case "hr":{t+=this.renderer.hr(i);break}case "heading":{t+=this.renderer.heading(i);break}case "code":{t+=this.renderer.code(i);break}case "table":{t+=this.renderer.table(i);break}case "blockquote":{t+=this.renderer.blockquote(i);break}case "list":{t+=this.renderer.list(i);break}case "checkbox":{t+=this.renderer.checkbox(i);break}case "html":{t+=this.renderer.html(i);break}case "def":{t+=this.renderer.def(i);break}case "paragraph":{t+=this.renderer.paragraph(i);break}case "text":{t+=this.renderer.text(i);break}default:{let s='Token with "'+i.type+'" type was not found.';if(this.options.silent)return console.error(s),"";throw new Error(s)}}}return t}parseInline(e,t=this.renderer){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let a=this.options.extensions.renderers[i.type].call({parser:this},i);if(a!==false||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){n+=a||"";continue}}let s=i;switch(s.type){case "escape":{n+=t.text(s);break}case "html":{n+=t.html(s);break}case "link":{n+=t.link(s);break}case "image":{n+=t.image(s);break}case "checkbox":{n+=t.checkbox(s);break}case "strong":{n+=t.strong(s);break}case "em":{n+=t.em(s);break}case "codespan":{n+=t.codespan(s);break}case "br":{n+=t.br(s);break}case "del":{n+=t.del(s);break}case "text":{n+=t.text(s);break}default:{let a='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(a),"";throw new Error(a)}}}return n}};var P$2=class P{options;block;constructor(e){this.options=e||T$2;}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens","emStrongMask"]);static passThroughHooksRespectAsync=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}emStrongMask(e){return e}provideLexer(){return this.block?x$2.lex:x$2.lexInline}provideParser(){return this.block?b$2.parse:b$2.parseInline}};var B$2=class B{defaults=M$2();options=this.setOptions;parse=this.parseMarkdown(true);parseInline=this.parseMarkdown(false);Parser=b$2;Renderer=y$2;TextRenderer=$$2;Lexer=x$2;Tokenizer=w$2;Hooks=P$2;constructor(...e){this.use(...e);}walkTokens(e,t){let n=[];for(let r of e)switch(n=n.concat(t.call(this,r)),r.type){case "table":{let i=r;for(let s of i.header)n=n.concat(this.walkTokens(s.tokens,t));for(let s of i.rows)for(let a of s)n=n.concat(this.walkTokens(a.tokens,t));break}case "list":{let i=r;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=r;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(s=>{let a=i[s].flat(1/0);n=n.concat(this.walkTokens(a,t));}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)));}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let r={...n};if(r.async=this.defaults.async||r.async||false,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error("extension name required");if("renderer"in i){let s=t.renderers[i.name];s?t.renderers[i.name]=function(...a){let o=i.renderer.apply(this,a);return o===false&&(o=s.apply(this,a)),o}:t.renderers[i.name]=i.renderer;}if("tokenizer"in i){if(!i.level||i.level!=="block"&&i.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=t[i.level];s?s.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level==="block"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level==="inline"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]));}"childTokens"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens);}),r.extensions=t),n.renderer){let i=this.defaults.renderer||new y$2(this.defaults);for(let s in n.renderer){if(!(s in i))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let a=s,o=n.renderer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c||""};}r.renderer=i;}if(n.tokenizer){let i=this.defaults.tokenizer||new w$2(this.defaults);for(let s in n.tokenizer){if(!(s in i))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let a=s,o=n.tokenizer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.tokenizer=i;}if(n.hooks){let i=this.defaults.hooks||new P$2;for(let s in n.hooks){if(!(s in i))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let a=s,o=n.hooks[a],l=i[a];P$2.passThroughHooks.has(s)?i[a]=p=>{if(this.defaults.async&&P$2.passThroughHooksRespectAsync.has(s))return (async()=>{let d=await o.call(i,p);return l.call(i,d)})();let c=o.call(i,p);return l.call(i,c)}:i[a]=(...p)=>{if(this.defaults.async)return (async()=>{let d=await o.apply(i,p);return d===false&&(d=await l.apply(i,p)),d})();let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.hooks=i;}if(n.walkTokens){let i=this.defaults.walkTokens,s=n.walkTokens;r.walkTokens=function(a){let o=[];return o.push(s.call(this,a)),i&&(o=o.concat(i.call(this,a))),o};}this.defaults={...this.defaults,...r};}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return x$2.lex(e,t??this.defaults)}parser(e,t){return b$2.parse(e,t??this.defaults)}parseMarkdown(e){return (n,r)=>{let i={...r},s={...this.defaults,...i},a=this.onError(!!s.silent,!!s.async);if(this.defaults.async===true&&i.async===false)return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return a(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return a(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(s.hooks&&(s.hooks.options=s,s.hooks.block=e),s.async)return (async()=>{let o=s.hooks?await s.hooks.preprocess(n):n,p=await(s.hooks?await s.hooks.provideLexer():e?x$2.lex:x$2.lexInline)(o,s),c=s.hooks?await s.hooks.processAllTokens(p):p;s.walkTokens&&await Promise.all(this.walkTokens(c,s.walkTokens));let h=await(s.hooks?await s.hooks.provideParser():e?b$2.parse:b$2.parseInline)(c,s);return s.hooks?await s.hooks.postprocess(h):h})().catch(a);try{s.hooks&&(n=s.hooks.preprocess(n));let l=(s.hooks?s.hooks.provideLexer():e?x$2.lex:x$2.lexInline)(n,s);s.hooks&&(l=s.hooks.processAllTokens(l)),s.walkTokens&&this.walkTokens(l,s.walkTokens);let c=(s.hooks?s.hooks.provideParser():e?b$2.parse:b$2.parseInline)(l,s);return s.hooks&&(c=s.hooks.postprocess(c)),c}catch(o){return a(o)}}}onError(e,t){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,e){let r="<p>An error occurred:</p><pre>"+O$2(n.message+"",true)+"</pre>";return t?Promise.resolve(r):r}if(t)return Promise.reject(n);throw n}}};var L$2=new B$2;function g$2(u,e){return L$2.parse(u,e)}g$2.options=g$2.setOptions=function(u){return L$2.setOptions(u),g$2.defaults=L$2.defaults,H$2(g$2.defaults),g$2};g$2.getDefaults=M$2;g$2.defaults=T$2;g$2.use=function(...u){return L$2.use(...u),g$2.defaults=L$2.defaults,H$2(g$2.defaults),g$2};g$2.walkTokens=function(u,e){return L$2.walkTokens(u,e)};g$2.parseInline=L$2.parseInline;g$2.Parser=b$2;g$2.parser=b$2.parse;g$2.Renderer=y$2;g$2.TextRenderer=$$2;g$2.Lexer=x$2;g$2.lexer=x$2.lex;g$2.Tokenizer=w$2;g$2.Hooks=P$2;g$2.parse=g$2;g$2.options;g$2.setOptions;g$2.use;g$2.walkTokens;g$2.parseInline;b$2.parse;x$2.lex;

function markedHighlight(options) {
  if (typeof options === 'function') {
    options = {
      highlight: options,
    };
  }

  if (!options || typeof options.highlight !== 'function') {
    throw new Error('Must provide highlight function');
  }

  if (typeof options.langPrefix !== 'string') {
    options.langPrefix = 'language-';
  }

  if (typeof options.emptyLangClass !== 'string') {
    options.emptyLangClass = '';
  }

  return {
    async: !!options.async,
    walkTokens(token) {
      if (token.type !== 'code') {
        return;
      }

      const lang = getLang(token.lang);

      if (options.async) {
        return Promise.resolve(options.highlight(token.text, lang, token.lang || '')).then(updateToken(token));
      }

      const code = options.highlight(token.text, lang, token.lang || '');
      if (code instanceof Promise) {
        throw new Error('markedHighlight is not set to async but the highlight function is async. Set the async option to true on markedHighlight to await the async highlight function.');
      }
      updateToken(token)(code);
    },
    useNewRenderer: true,
    renderer: {
      code(code, infoString, escaped) {
        // istanbul ignore next
        if (typeof code === 'object') {
          escaped = code.escaped;
          infoString = code.lang;
          code = code.text;
        }
        const lang = getLang(infoString);
        const classValue = lang ? options.langPrefix + escape(lang) : options.emptyLangClass;
        const classAttr = classValue
          ? ` class="${classValue}"`
          : '';
        code = code.replace(/\n$/, '');
        return `<pre><code${classAttr}>${escaped ? code : escape(code, true)}\n</code></pre>`;
      },
    },
  };
}

function getLang(lang) {
  return (lang || '').match(/\S*/)[0];
}

function updateToken(token) {
  return (code) => {
    if (typeof code === 'string' && code !== token.text) {
      token.escaped = true;
      token.text = code;
    }
  };
}

// copied from marked helpers
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }

  return html;
}

const ensureStyles$8 = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables$5(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables$5 = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$8(key), 'g'), value);
    }, styles);
};
const escapeRegExp$8 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * The default configuration options for the accordion component.
 */
const DEFAULT_OPTIONS$c = {
    className: 'marked-extended-accordion',
    prefixId: 'accordion-',
    animationDuration: '0.3s',
    template: null,
    customizeToken: null,
    injectStyles: true,
};
/**
 * The default accordion template with improved accessibility.
 * Uses placeholders that will be replaced during rendering:
 * - {accordionId} - Unique ID for the accordion element
 * - {title} - Title of the accordion
 * - {content} - Content inside the accordion
 * - {expanded} - Whether the accordion is expanded (true/false)
 * - {expandedAttr} - 'open' attribute if expanded, empty if not
 * - {animationDuration} - Duration of the animation
 * - {headingTag} - Heading tag based on level (h1-h6)
 * - {className} - Additional CSS classes
 */
const DEFAULT_TEMPLATE$6 = `
<details id="{accordionId}" class="{className}" {expandedAttr}>
  <summary class="{className}-header">
    <{headingTag} class="{className}-title">{title}</{headingTag}>
  </summary>
  <div class="{className}-content">
    {content}
  </div>
</details>
`;
/**
 * The default structural styles for the accordion component.
 * These are minimal styles required for functionality.
 * Visual/theme styles should be provided by the user.
 * - {animationDuration} - Duration of the animation
 * - {transitionTiming} - Timing function for the transition
 */
const DEFAULT_STYLES$9 = `
  .marked-extended-accordion {
    overflow: hidden;
    
    & .marked-extended-accordion-content {
      transition: opacity {animationDuration} {transitionTiming};
      width: 100%;
      box-sizing: border-box;
      animation: accordion-fade {animationDuration} ease;
      overflow: auto;
    }
  }
  
  @keyframes accordion-fade {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;

/**
 * Regular expression for parsing properties from attribute strings
 * Matches patterns like: property="value"
 */
const propRegex$4 = /\s*(\w+)="([^"]+)"/g;
/**
 * Element patterns configuration for accordion blocks
 */
const elementPatterns$4 = {
    accordionBlock: {
        start: '::::accordion',
        end: '::::accordionend',
        aliases: [':acd', ':accordion'],
        endAliases: [':acdend', ':accordionend'],
    },
};
/**
 * Supported properties by element type
 */
const supportedPropsByElement$4 = {
    accordionBlock: [
        { name: 'title', defaultValue: '' },
        { name: 'expanded', defaultValue: 'false' },
        { name: 'duration', defaultValue: '1s' },
        { name: 'level', defaultValue: '3' },
    ],
};
/**
 * Parses balanced opening and closing tags with proper nesting support
 * @param src - Source string to parse
 * @param elementType - Type of element to parse
 * @returns RegExpExecArray or null if no match
 */
function parseBalancedTags$3(src, elementType) {
    const pattern = elementPatterns$4[elementType];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    // Find which start pattern matches
    let startPos = 0;
    if (src.startsWith(start)) {
        startPos = start.length;
    }
    else {
        for (const alias of aliases) {
            if (src.startsWith(alias)) {
                startPos = alias.length;
                break;
            }
        }
        if (startPos === 0)
            return null;
    }
    // Find property block
    let depth = 1;
    const propEnd = src.indexOf('}', startPos);
    if (propEnd === -1)
        return null;
    const propString = src.substring(startPos, propEnd);
    const contentStart = propEnd + 1;
    let pos = contentStart;
    // Parse nested content with depth tracking
    while (pos < src.length && depth > 0) {
        // Find next start tag
        const mainStartPos = src.indexOf(start, pos);
        let nextStartPos = mainStartPos;
        for (const alias of aliases) {
            const aliasPos = src.indexOf(alias, pos);
            if (aliasPos !== -1 && (nextStartPos === -1 || aliasPos < nextStartPos)) {
                nextStartPos = aliasPos;
            }
        }
        // Find next end tag
        let foundEndPattern = end;
        let nextEndPos = src.indexOf(end, pos);
        for (const endAlias of endAliases) {
            const endAliasPos = src.indexOf(endAlias, pos);
            if (endAliasPos !== -1 && (nextEndPos === -1 || endAliasPos < nextEndPos)) {
                nextEndPos = endAliasPos;
                foundEndPattern = endAlias;
            }
        }
        if (nextEndPos === -1)
            return null;
        // Handle nested tags
        if (nextStartPos !== -1 && nextStartPos < nextEndPos) {
            depth++;
            let matchedPattern = start;
            if (nextStartPos === mainStartPos) {
                matchedPattern = start;
            }
            else {
                for (const alias of aliases) {
                    if (src.indexOf(alias, pos) === nextStartPos) {
                        matchedPattern = alias;
                        break;
                    }
                }
            }
            pos = nextStartPos + matchedPattern.length;
            continue;
        }
        // Check if we've closed all nested tags
        if (--depth === 0) {
            const content = src.substring(contentStart, nextEndPos);
            const fullMatch = src.substring(0, nextEndPos + foundEndPattern.length);
            const result = [fullMatch, propString, content];
            result.index = 0;
            result.input = src;
            return result;
        }
        pos = nextEndPos + foundEndPattern.length;
    }
    return null;
}
/**
 * Validates and parses element patterns from source string
 * @param element - Element type or RegExp to validate
 * @param src - Source string to parse
 * @returns RegExpExecArray or null if no match
 */
const validateRegex$4 = (element, src) => {
    if (element instanceof RegExp) {
        return element.exec(src);
    }
    switch (element) {
        case 'accordionBlock':
            return parseBalancedTags$3(src, element);
        default:
            throw new Error(`Unknown element: ${element}`);
    }
};
/**
 * Constructs properties object from property string
 * @param element - Element type
 * @param propString - String containing properties
 * @returns Record of property names to values
 */
const constructProps$4 = (element, propString) => {
    const supportedProps = supportedPropsByElement$4[element];
    if (!supportedProps) {
        throw new Error(`Unknown element: ${element}`);
    }
    // Initialize with default values
    const props = {};
    supportedProps.forEach((prop) => {
        props[prop.name] = prop.defaultValue;
    });
    // Parse and override with actual values
    propRegex$4.lastIndex = 0;
    let propMatch;
    while ((propMatch = propRegex$4.exec(propString)) !== null) {
        const [, name, value] = propMatch;
        if (supportedProps.some((p) => p.name === name)) {
            props[name] = value;
        }
    }
    return props;
};

/**
 * Renders an accordion with the given properties
 * @param options - Properties for the accordion
 * @returns HTML representation of the accordion
 */
function renderAccordion(options) {
    const { prefixId, title, expanded, level, className, animationDuration, template, tokens, parser } = options;
    // Generate a unique ID
    const uniqueId = `${prefixId}${Math.random().toString(36).substring(2, 11)}`;
    // Render the content using the parser context which has all extensions loaded
    // This allows nested extensions to be properly rendered
    const markedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
    // Generate the heading element based on the level
    const headingTag = `h${level}`;
    // Get the accordion template
    const accordionTemplate = template || DEFAULT_TEMPLATE$6;
    // Return the template with all placeholders replaced
    return accordionTemplate
        .replace(/{accordionId}/g, uniqueId)
        .replace(/{headingTag}/g, headingTag)
        .replace(/{title}/g, title)
        .replace(/{content}/g, markedContent)
        .replace(/{expanded}/g, expanded ? 'true' : 'false')
        .replace(/{expandedAttr}/g, expanded ? 'open' : '')
        .replace(/{animationDuration}/g, animationDuration)
        .replace(/{className}/g, className);
}

/**
 * Create an accordion effect for the Markdown parser with enhanced features.
 * @param options - Configuration options
 * @returns Marked extension object
 */
function createTokenizer$6(options) {
    const { className, prefixId, animationDuration, template } = options;
    const element = 'accordionBlock';
    return {
        name: 'accordion',
        level: 'block',
        tokenizer(src) {
            // Check for the accordion block pattern
            const blockMatch = validateRegex$4(element, src);
            if (!blockMatch)
                return undefined;
            const [raw, propString, content] = blockMatch;
            // Parse properties from the propString
            const props = constructProps$4(element, propString);
            // Tokenize the content using this.lexer.blockTokens
            // This ensures nested extensions are properly tokenized
            const tokens = this.lexer.blockTokens(content.trim());
            // Return a token with all properties
            return {
                type: 'accordion',
                raw,
                tokens,
                meta: {
                    prefixId,
                    title: props['title'] || '',
                    expanded: props['expanded'] === 'true',
                    level: parseInt(props['level'] || '3', 10) || 3,
                    className,
                    animationDuration: props['duration'] || animationDuration,
                    template,
                },
            };
        },
    };
}
/**
 * Create the renderer extension for accordion
 * @returns Renderer extension object
 */
function createRenderer$6() {
    return {
        name: 'accordion',
        renderer(token) {
            const accordionToken = token;
            // 'this' context is provided by marked.js and contains the parser instance
            // The parser is already configured with all user-defined extensions and renderers
            return renderAccordion({
                ...accordionToken.meta,
                tokens: accordionToken.tokens || [],
                parser: this.parser,
            });
        },
    };
}

/**
 * Marked Extended Accordion extension
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedAccordion(options = {}) {
    // Set sensible defaults
    const config = { ...DEFAULT_OPTIONS$c, ...options };
    // Inject styles if needed
    if (config.injectStyles)
        ensureStyles$8('marked-extended-accordion-styles', DEFAULT_STYLES$9);
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type !== 'accordion')
                return;
            // Apply custom token modifications if configured
            if (config.customizeToken && typeof config.customizeToken === 'function') {
                config.customizeToken(token);
            }
        },
        extensions: [createTokenizer$6(config), createRenderer$6()],
    };
}

const ensureStyles$7 = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables$4(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables$4 = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$7(key), 'g'), value);
    }, styles);
};
const escapeRegExp$7 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * DEFAULT_OPTIONS object defines the default configuration settings.
 *
 * Properties:
 * - className: A string representing the default CSS class name to be applied. Defaults to 'marked-extended-alert'.
 * - variants: An array to hold variant options. Defaults to an empty array.
 * - injectStyles: A boolean indicating whether to inject styles automatically. Defaults to true.
 */
const DEFAULT_OPTIONS$b = {
    className: 'marked-extended-alert',
    variants: [],
    injectStyles: true,
};
/**
 * The default configuration for alert variants.
 */
const DEFAULT_VARIANTS = [
    {
        type: 'note',
        icon: '<svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>',
    },
    {
        type: 'tip',
        icon: '<svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>',
    },
    {
        type: 'important',
        icon: '<svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>',
    },
    {
        type: 'warning',
        icon: '<svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>',
    },
    {
        type: 'caution',
        icon: '<svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>',
    },
];
/**
 * The default template for rendering alerts
 * Uses placeholders that will be replaced during rendering:
 * - {className} - Base class name for the alert
 * - {variant} - Variant class name for the alert
 * - {titleClassName} - Class name for the title
 * - {icon} - Icon HTML for the alert
 * - {title} - Title of the alert
 * - {content} - Content inside the alert
 */
const DEFAULT_TEMPLATE$5 = `
<div class="{className} {className}-{variant}">
  <p class="{titleClassName}">{icon}{title}</p>
  <div class="{className}-content">{content}</div>
</div>
`;
/**
 * The default structural styles for the alert component.
 * These are minimal styles required for functionality.
 * Visual/theme styles should be provided by the user.
 *
 * Note: Alerts don't require structural styles as they follow normal content flow.
 * This is kept minimal to avoid injecting unnecessary styles.
 */
const DEFAULT_STYLES$8 = `
  .marked-extended-alert {
    /* No structural styles needed - alerts follow normal content flow */
  }
`;

/**
 * Returns a regex pattern to match alert syntax.
 * @param type - The alert type to match
 * @returns Regex pattern string
 */
function createSyntaxPattern(type) {
    return `^(?:\\[!${type.toUpperCase()}])\\s*?\n*`;
}
/**
 * Capitalizes the first letter of a string.
 * @param str - String to capitalize
 * @returns Capitalized string
 */
function ucfirst(str) {
    return str.slice(0, 1).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Process a blockquote token to check and convert it into an alert
 * @param options - Configuration options
 */
function processAlertToken(options) {
    const { token, className, variants } = options;
    const resolvedVariants = resolveVariants(variants);
    const matchedVariant = resolvedVariants.find(({ type }) => new RegExp(createSyntaxPattern(type)).test(token.text || ''));
    if (!matchedVariant)
        return;
    const { type: variantType, icon, title = ucfirst(variantType), titleClassName = `${className}-title`, } = matchedVariant;
    const typeRegexp = new RegExp(createSyntaxPattern(variantType));
    // Transform the token into an alert token
    Object.assign(token, {
        type: 'alert',
        meta: {
            className,
            variant: variantType,
            icon,
            title,
            titleClassName,
        },
    });
    // Clean up the first line to remove the alert marker
    const tokenWithTokens = token;
    const firstLine = tokenWithTokens.tokens?.[0];
    const firstLineText = firstLine?.raw?.replace(typeRegexp, '').trim();
    if (firstLineText && firstLine?.tokens) {
        const patternToken = firstLine.tokens[0];
        if (patternToken) {
            Object.assign(patternToken, {
                raw: patternToken.raw?.replace(typeRegexp, '') || '',
                text: patternToken.text?.replace(typeRegexp, '') || '',
            });
        }
        if (firstLine.tokens[1]?.type === 'br') {
            firstLine.tokens.splice(1, 1);
        }
    }
    else {
        tokenWithTokens.tokens?.shift();
    }
}
/**
 * Resolves the variant configuration, combining the provided variants with
 * the default variants.
 * @param variants - Custom variants to merge with defaults
 * @returns Merged variants
 */
function resolveVariants(variants) {
    if (!variants.length)
        return DEFAULT_VARIANTS;
    return Object.values([...DEFAULT_VARIANTS, ...variants].reduce((map, item) => {
        map[item.type] = item;
        return map;
    }, {}));
}

/**
 * Renders an alert with the given properties
 * @param meta - Metadata for the alert
 * @param tokens - Tokens to render within the alert
 * @param parser - Parser instance from marked.js renderer context (this.parser)
 * @returns HTML representation of the alert
 */
function renderAlert(meta, tokens, parser) {
    if (!meta)
        return '';
    const { className, variant, icon, title, titleClassName } = meta;
    // Tokenize and then parse the content
    const markedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
    return DEFAULT_TEMPLATE$5.replace(/{className}/g, className)
        .replace(/{variant}/g, variant)
        .replace(/{titleClassName}/g, titleClassName)
        .replace(/{icon}/g, icon)
        .replace(/{title}/g, title)
        .replace(/{content}/g, markedContent);
}

/**
 * A [marked](https://marked.js.org/) extension to support [GFM alerts](https://github.com/orgs/community/discussions/16925).
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedAlert(options = {}) {
    const config = { ...DEFAULT_OPTIONS$b, ...options };
    // Inject styles if needed
    if (config.injectStyles)
        ensureStyles$7('marked-extended-alert-styles', DEFAULT_STYLES$8);
    return {
        walkTokens(token) {
            if (token.type !== 'blockquote')
                return;
            // Process blockquote token for alerts
            processAlertToken({ token, ...config });
        },
        extensions: [
            {
                name: 'alert',
                renderer: function (token) {
                    // 'this' context is provided by marked.js and contains the parser instance
                    // The parser is already configured with all user-defined extensions and renderers
                    // Cast to AlertToken since we know this renderer only handles alert tokens
                    const alertToken = token;
                    return renderAlert(alertToken.meta, alertToken.tokens || [], this.parser);
                },
            },
        ],
    };
}

/**
 * Ensure styles are injected into the document
 */
function ensureStyles$6(id, styles) {
    if (typeof window === 'undefined')
        return;
    if (typeof document === 'undefined')
        return;
    if (document.getElementById(id))
        return;
    const styleEl = document.createElement('style');
    styleEl.id = id;
    styleEl.textContent = styles;
    document.head.appendChild(styleEl);
}

/**
 * Default options for the comment extension
 */
const DEFAULT_OPTIONS$a = {
    className: 'marked-extended-comment',
    prefixId: 'comment',
    showComments: true,
    enableInlineComments: true,
    enableBlockComments: true,
    showMetadata: true,
    showResolvedComments: false,
    defaultType: 'note',
    defaultVisibility: 'public',
    injectStyles: true,
};
/**
 * Comment type SVG icons
 */
const COMMENT_ICONS = {
    note: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M2 3.5A1.5 1.5 0 0 1 3.5 2h9A1.5 1.5 0 0 1 14 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 12.5v-9zm1.5-.5a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-9zM4.5 5h7v1h-7V5zm0 2h7v1h-7V7zm0 2h4v1h-4V9z"/></svg>',
    question: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/></svg>',
    suggestion: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>',
    issue: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"/><path d="M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z"/></svg>',
    internal: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M8 0a.5.5 0 0 1 .5.5v1.21l3 1.5c.161.08.29.213.358.368.069.154.09.332.06.499L11 12.31c-.062.37-.31.686-.649.87L8 14.75l-2.351-1.57c-.338-.184-.587-.5-.649-.87L4.082 4.078a.66.66 0 0 1 .06-.498.73.73 0 0 1 .358-.368l3-1.5V.5A.5.5 0 0 1 8 0zm0 2.396L5.354 3.71l.823 7.73L8 12.664l1.823-1.22.823-7.73L8 2.396zM9 6.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7.5 7.5v2h1v-2h-1z"/></svg>',
    review: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/></svg>',
    todo: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" class="comment-icon"><path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/></svg>',
};
/**
 * Comment type labels
 */
const COMMENT_LABELS = {
    note: 'Note',
    question: 'Question',
    suggestion: 'Suggestion',
    issue: 'Issue',
    internal: 'Internal',
    review: 'Review',
    todo: 'To Do',
};
/**
 * Default template for inline comments
 */
const DEFAULT_INLINE_TEMPLATE = `
<span class="{className} {className}-inline {className}-type-{type} {className}-status-{status} {visibilityClass}" 
      id="{commentId}"
      data-comment-type="{type}"
      data-comment-status="{status}"
      data-comment-visibility="{visibility}"
      data-comment-author="{author}"
      data-comment-date="{date}"
      role="note"
      aria-label="Comment: {text}"
      title="{tooltipText}">
  <span class="{className}-content">{content}</span>
  <span class="{className}-indicator" aria-hidden="true">{icon}</span>
</span>
`;
/**
 * Default template for block comments
 */
const DEFAULT_BLOCK_TEMPLATE = `
<aside class="{className} {className}-block {className}-type-{type} {className}-status-{status} {visibilityClass} {priorityClass}"
       id="{commentId}"
       data-comment-type="{type}"
       data-comment-status="{status}"
       data-comment-visibility="{visibility}"
       data-comment-author="{author}"
       data-comment-date="{date}"
       role="complementary"
       aria-label="Comment by {author}">
  <div class="{className}-header">
    <span class="{className}-icon" aria-hidden="true">{icon}</span>
    <span class="{className}-type-label">{typeLabel}</span>
    {metadata}
  </div>
  <div class="{className}-body">
    {content}
  </div>
</aside>
`;
/**
 * Metadata template
 */
const METADATA_TEMPLATE$1 = `
<div class="{className}-metadata">
  {authorInfo}
  {dateInfo}
  {tagsInfo}
  {priorityInfo}
</div>
`;
/**
 * Default structural styles for comments (minimal, layout-only)
 */
const DEFAULT_STYLES$7 = `
.marked-extended-comment { position: relative; display: inline-block; }
.marked-extended-comment-inline { display: inline; }
.marked-extended-comment-indicator { position: absolute; top: -8px; right: -8px; font-size: 12px; line-height: 1; }
.marked-extended-comment-block { display: block; margin: 1rem 0; }
.marked-extended-comment-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
.marked-extended-comment-icon { line-height: 1; }
.marked-extended-comment-body { margin: 0.5rem 0; }
.marked-extended-comment-metadata { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 0.5rem; }
.marked-extended-comment-metadata > span { display: flex; align-items: center; gap: 0.25rem; }
.marked-extended-comment.hidden { display: none; }
`;

/**
 * Generate a unique ID for comments
 */
let commentCounter = 0;
function generateUniqueId$2(prefix = 'comment') {
    commentCounter++;
    return `${prefix}-${Date.now()}-${commentCounter}`;
}
/**
 * Parse property string like 'author="John" type="note"'
 */
function parsePropString$2(propString) {
    const props = {};
    if (!propString || !propString.trim()) {
        return props;
    }
    // Match key="value" or key='value' or key=value patterns
    const matches = propString.matchAll(/(\w+)=(?:"([^"]*)"|'([^']*)'|([^\s]+))/g);
    for (const match of matches) {
        const key = match[1];
        const value = match[2] || match[3] || match[4];
        props[key] = value;
    }
    return props;
}
/**
 * Replace template placeholders with values
 */
function replaceTemplatePlaceholders$2(template, values) {
    let result = template;
    for (const [key, value] of Object.entries(values)) {
        const regex = new RegExp(`\\{${key}\\}`, 'g');
        result = result.replace(regex, value || '');
    }
    return result;
}
/**
 * Format date string
 */
function formatDate$1(dateString) {
    if (!dateString)
        return '';
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime()))
            return dateString;
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
        });
    }
    catch {
        return dateString;
    }
}
/**
 * Build metadata HTML for comments
 */
function buildMetadataHtml(author, date, tags, priority, className) {
    const authorInfo = author
        ? `<span class="${className}-author"><strong>Author:</strong> ${author}</span>`
        : '';
    const dateInfo = date
        ? `<span class="${className}-date"><strong>Date:</strong> ${formatDate$1(date)}</span>`
        : '';
    const tagsInfo = tags
        ? `<span class="${className}-tags"><strong>Tags:</strong> ${tags}</span>`
        : '';
    const priorityInfo = priority && priority !== 'low'
        ? `<span class="${className}-priority"><strong>Priority:</strong> ${priority}</span>`
        : '';
    return { authorInfo, dateInfo, tagsInfo, priorityInfo };
}

/**
 * Render an inline comment
 */
function renderInlineComment(options) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { commentId, meta, text, className, template} = options;
    const type = meta.type || 'note';
    const status = meta.status || 'open';
    const visibility = meta.visibility || 'public';
    const icon = COMMENT_ICONS[type] || '📝';
    // Build visibility class
    const visibilityClass = visibility !== 'public' ? `${className}-visibility-${visibility}` : '';
    // Build tooltip text
    const tooltipParts = [];
    if (meta.author)
        tooltipParts.push(`Author: ${meta.author}`);
    if (meta.type)
        tooltipParts.push(`Type: ${COMMENT_LABELS[meta.type] || meta.type}`);
    if (meta.date)
        tooltipParts.push(`Date: ${meta.date}`);
    const tooltipText = tooltipParts.join(' | ');
    const templateToUse = template || DEFAULT_INLINE_TEMPLATE;
    return replaceTemplatePlaceholders$2(templateToUse, {
        className,
        commentId,
        type,
        status,
        visibility,
        visibilityClass,
        author: meta.author || '',
        date: meta.date || '',
        text,
        content: text,
        icon,
        tooltipText,
    });
}
/**
 * Render a block comment
 */
function renderBlockComment(options) {
    const { commentId, meta, tokens, parser, className, template, showMetadata } = options;
    const type = meta.type || 'note';
    const status = meta.status || 'open';
    const visibility = meta.visibility || 'public';
    const priority = meta.priority || '';
    const icon = COMMENT_ICONS[type] || '📝';
    const typeLabel = COMMENT_LABELS[type] || type;
    // Build visibility class
    const visibilityClass = visibility !== 'public' ? `${className}-visibility-${visibility}` : '';
    // Build priority class
    const priorityClass = priority ? `${className}-priority-${priority}` : '';
    // Parse comment content (nested markdown)
    const content = parser.parse(tokens);
    // Build metadata HTML
    let metadata = '';
    if (showMetadata) {
        const { authorInfo, dateInfo, tagsInfo, priorityInfo } = buildMetadataHtml(meta.author, meta.date, meta.tags, meta.priority, className);
        metadata = replaceTemplatePlaceholders$2(METADATA_TEMPLATE$1, {
            className,
            authorInfo,
            dateInfo,
            tagsInfo,
            priorityInfo,
        });
    }
    const templateToUse = template || DEFAULT_BLOCK_TEMPLATE;
    return replaceTemplatePlaceholders$2(templateToUse, {
        className,
        commentId,
        type,
        status,
        visibility,
        visibilityClass,
        priorityClass,
        author: meta.author || '',
        date: meta.date || '',
        icon,
        typeLabel,
        content,
        metadata,
    });
}

/**
 * Create an inline comment tokenizer
 */
function createInlineCommentTokenizer(options) {
    return {
        name: 'inlineComment',
        level: 'inline',
        start(src) {
            return src.indexOf(':::comment');
        },
        tokenizer(src) {
            // Regex for inline comments: :::comment{props}text:::
            const match = src.match(/^:::comment(?:\{([^}]*)\})?([^:]+):::/);
            if (!match)
                return undefined;
            const [raw, propString = '', text] = match;
            // Parse properties
            const props = parsePropString$2(propString);
            const meta = {
                author: props['author'],
                date: props['date'],
                type: props['type'] || options.defaultType,
                visibility: props['visibility'] || options.defaultVisibility,
                status: props['status'] || 'open',
                priority: props['priority'],
                tags: props['tags'],
                id: props['id'],
                className: props['className'],
            };
            return {
                type: 'inlineComment',
                raw,
                text: text.trim(),
                meta,
            };
        },
    };
}
/**
 * Create block comment tokenizer
 */
function createBlockCommentTokenizer(options) {
    return {
        name: 'blockComment',
        level: 'block',
        tokenizer(src) {
            // Regex for block comments: ::::comment{props}\ncontent\n::::commentend
            const match = src.match(/^::::comment(?:\{([^}]*)\})?\s*\n([\s\S]*?)::::commentend/);
            if (!match)
                return undefined;
            const [raw, propString = '', content] = match;
            // Parse properties
            const props = parsePropString$2(propString);
            const meta = {
                author: props['author'],
                date: props['date'],
                type: props['type'] || options.defaultType,
                visibility: props['visibility'] || options.defaultVisibility,
                status: props['status'] || 'open',
                priority: props['priority'],
                tags: props['tags'],
                id: props['id'],
                replyTo: props['replyTo'],
                className: props['className'],
            };
            // Tokenize the content
            const tokens = this.lexer.blockTokens(content.trim());
            return {
                type: 'blockComment',
                raw,
                text: content.trim(),
                meta,
                tokens,
            };
        },
    };
}
/**
 * Create renderer for inline comments
 */
function createInlineCommentRenderer(options) {
    return {
        name: 'inlineComment',
        renderer(token) {
            const commentToken = token;
            const meta = commentToken.meta;
            // Check if comment should be shown
            if (!options.showComments)
                return commentToken.text;
            if (!options.enableInlineComments)
                return commentToken.text;
            if (meta.status === 'resolved' && !options.showResolvedComments)
                return commentToken.text;
            // Generate unique ID
            const commentId = meta.id || generateUniqueId$2(options.prefixId);
            return renderInlineComment({
                commentId,
                meta,
                text: commentToken.text,
                parser: this.parser,
                className: meta.className || options.className,
                template: options.inlineTemplate,
                showMetadata: options.showMetadata,
            });
        },
    };
}
/**
 * Create renderer for block comments
 */
function createBlockCommentRenderer(options) {
    return {
        name: 'blockComment',
        renderer(token) {
            const commentToken = token;
            const meta = commentToken.meta;
            // Check if comment should be shown
            if (!options.showComments)
                return '';
            if (!options.enableBlockComments)
                return '';
            if (meta.status === 'resolved' && !options.showResolvedComments)
                return '';
            // Generate unique ID
            const commentId = meta.id || generateUniqueId$2(options.prefixId);
            return renderBlockComment({
                commentId,
                meta,
                text: commentToken.text,
                tokens: commentToken.tokens || [],
                parser: this.parser,
                className: meta.className || options.className,
                template: options.blockTemplate,
                showMetadata: options.showMetadata,
            });
        },
    };
}

/**
 * Marked Extended Comments extension
 * Adds support for inline and block comments with rich metadata
 *
 * @example
 * ```markdown
 * // Inline comment
 * This text has :::comment{author="Alice" type="note"}a comment::: here.
 *
 * // Block comment
 * ::::comment{author="Bob" type="review" status="open"}
 * This section needs revision.
 * ::::commentend
 * ```
 *
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedComments(options = {}) {
    // Merge options with defaults
    const config = { ...DEFAULT_OPTIONS$a, ...options };
    // Inject styles if needed
    if (config.injectStyles) {
        ensureStyles$6('marked-extended-comments-styles', DEFAULT_STYLES$7);
    }
    // Return the extension
    return {
        walkTokens(token) {
            // Handle inline comments
            if (token.type === 'inlineComment') {
                const commentToken = token;
                // Apply custom token modifications if configured
                if (config.customizeToken && typeof config.customizeToken === 'function') {
                    config.customizeToken(commentToken);
                }
                // Trigger visibility change callback
                if (config.onVisibilityChange && typeof config.onVisibilityChange === 'function') {
                    const commentId = commentToken.meta.id || `${config.prefixId}-${Date.now()}`;
                    const visible = config.showComments
                        && (commentToken.meta.status !== 'resolved' || config.showResolvedComments);
                    config.onVisibilityChange(commentId, visible);
                }
            }
            // Handle block comments
            if (token.type === 'blockComment') {
                const commentToken = token;
                // Apply custom token modifications if configured
                if (config.customizeToken && typeof config.customizeToken === 'function') {
                    config.customizeToken(commentToken);
                }
                // Trigger visibility change callback
                if (config.onVisibilityChange && typeof config.onVisibilityChange === 'function') {
                    const commentId = commentToken.meta.id || `${config.prefixId}-${Date.now()}`;
                    const visible = config.showComments
                        && (commentToken.meta.status !== 'resolved' || config.showResolvedComments);
                    config.onVisibilityChange(commentId, visible);
                }
                // Trigger status change callback
                if (config.onStatusChange && typeof config.onStatusChange === 'function' && commentToken.meta.status) {
                    const commentId = commentToken.meta.id || `${config.prefixId}-${Date.now()}`;
                    config.onStatusChange(commentId, commentToken.meta.status);
                }
            }
        },
        extensions: [
            createInlineCommentTokenizer(config),
            createBlockCommentTokenizer(config),
            createInlineCommentRenderer(config),
            createBlockCommentRenderer(config),
        ],
    };
}

/**
 * Ensure styles are injected into the document
 */
function ensureStyles$5(id, styles) {
    if (typeof window === 'undefined')
        return;
    if (typeof document === 'undefined')
        return;
    if (document.getElementById(id))
        return;
    const styleEl = document.createElement('style');
    styleEl.id = id;
    styleEl.textContent = styles;
    document.head.appendChild(styleEl);
}

/**
 * Default options for the embed extension
 */
const DEFAULT_OPTIONS$9 = {
    className: 'marked-extended-embed',
    prefixId: 'embed',
    defaultAspectRatio: '16:9',
    allowFullscreen: true,
    lazyLoad: true,
    privacyMode: false,
    injectStyles: true,
    enableSandbox: true,
    sandboxPermissions: ['allow-scripts', 'allow-same-origin', 'allow-popups', 'allow-presentation'],
};
/**
 * Provider-specific URL patterns for detection
 */
const PROVIDER_PATTERNS = {
    youtube: [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]+)/,
        /youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/,
    ],
    vimeo: [
        /vimeo\.com\/(?:video\/)?(\d+)/,
    ],
    twitter: [
        /twitter\.com\/\w+\/status\/(\d+)/,
        /x\.com\/\w+\/status\/(\d+)/,
    ],
    codepen: [
        /codepen\.io\/([^\/]+)\/pen\/([a-zA-Z0-9]+)/,
    ],
    codesandbox: [
        /codesandbox\.io\/(?:s|embed)\/([a-zA-Z0-9-]+)/,
    ],
    'github-gist': [
        /gist\.github\.com\/([^\/]+)\/([a-zA-Z0-9]+)/,
    ],
    spotify: [
        /open\.spotify\.com\/(track|album|playlist|episode|show)\/([a-zA-Z0-9]+)/,
    ],
    soundcloud: [
        /soundcloud\.com\/([^\/]+\/[^\/]+)/,
    ],
    slideshare: [
        /slideshare\.net\/[^\/]+\/([^\/\?]+)/,
    ],
    figma: [
        /figma\.com\/(?:file|proto|design)\/([a-zA-Z0-9]+)(?:\/([^?]+))?/,
    ],
    loom: [
        /loom\.com\/(?:share|embed)\/([a-zA-Z0-9]+)/,
    ],
    miro: [
        /miro\.com\/app\/board\/([a-zA-Z0-9_=-]+)/,
    ],
    mermaid: [],
    excalidraw: [
        /excalidraw\.com\/#json=([a-zA-Z0-9_-]+)/,
        /excalidraw\.com\/#room=([a-zA-Z0-9_-]+)/,
    ],
    drawio: [
        /(?:app\.)?diagrams\.net\/.*[?&]src=([^&]+)/,
        /drive\.google\.com.*\/file\/d\/([^\/]+)/,
    ],
    'diagrams-net': [
        /(?:app\.)?diagrams\.net\/.*[?&]src=([^&]+)/,
    ],
    pdf: [],
    iframe: [],
};
/**
 * Provider display names
 */
const PROVIDER_NAMES = {
    youtube: 'YouTube',
    vimeo: 'Vimeo',
    twitter: 'Twitter',
    codepen: 'CodePen',
    codesandbox: 'CodeSandbox',
    'github-gist': 'GitHub Gist',
    spotify: 'Spotify',
    soundcloud: 'SoundCloud',
    slideshare: 'SlideShare',
    figma: 'Figma',
    loom: 'Loom',
    miro: 'Miro',
    mermaid: 'Mermaid Diagram',
    excalidraw: 'Excalidraw',
    drawio: 'Draw.io',
    'diagrams-net': 'Diagrams.net',
    pdf: 'PDF Document',
    iframe: 'External Content',
};
/**
 * Default template for embeds
 */
const DEFAULT_TEMPLATE$4 = `
<div class="{className}-container" id="{embedId}" data-provider="{provider}">
  <div class="{className}-wrapper" style="{aspectRatioStyle}">
    {loadingPlaceholder}
    <iframe
      class="{className}-iframe"
      src="{embedUrl}"
      title="{title}"
      frameborder="0"
      {allowFullscreen}
      {sandbox}
      {loading}
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      referrerpolicy="no-referrer-when-downgrade"
    ></iframe>
  </div>
  {caption}
</div>
`;
/**
 * Loading placeholder template
 */
const LOADING_PLACEHOLDER = `
<div class="{className}-loading" aria-label="Loading embed">
  <div class="{className}-spinner"></div>
  <span class="{className}-loading-text">Loading {providerName}...</span>
</div>
`;
/**
 * Default structural styles for embeds (minimal, layout-only)
 */
const DEFAULT_STYLES$6 = `
.marked-extended-embed-container { position: relative; margin: 1.5rem 0; overflow: hidden; }
.marked-extended-embed-wrapper { position: relative; width: 100%; height: 0; overflow: hidden; }
.marked-extended-embed-iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
.marked-extended-embed-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 1rem; }
.marked-extended-embed-spinner { width: 40px; height: 40px; }
.marked-extended-embed-caption { padding: 0.75rem 1rem; text-align: center; }
`;

/**
 * Generate a unique ID for embeds
 */
let embedCounter = 0;
function generateUniqueId$1(prefix = 'embed') {
    embedCounter++;
    return `${prefix}-${Date.now()}-${embedCounter}`;
}
/**
 * Parse property string like 'title="Video" autoplay="true"'
 */
function parsePropString$1(propString) {
    const props = {};
    if (!propString || !propString.trim()) {
        return props;
    }
    // Match key="value" or key='value' or key=value patterns
    const matches = propString.matchAll(/(\w+)=(?:"([^"]*)"|'([^']*)'|([^\s]+))/g);
    for (const match of matches) {
        const key = match[1];
        const value = match[2] || match[3] || match[4];
        props[key] = value;
    }
    return props;
}
/**
 * Detect embed provider from URL
 */
function detectProvider(url) {
    for (const [provider, patterns] of Object.entries(PROVIDER_PATTERNS)) {
        for (const pattern of patterns) {
            if (pattern.test(url)) {
                return provider;
            }
        }
    }
    return null;
}
/**
 * Parse embed URL and extract provider-specific information
 */
function parseEmbedUrl(url, provider) {
    const patterns = PROVIDER_PATTERNS[provider];
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) {
            return buildEmbedInfo(provider, match, url);
        }
    }
    return null;
}
/**
 * Build embed information based on provider
 */
function buildEmbedInfo(provider, match, originalUrl) {
    switch (provider) {
        case 'youtube': {
            const videoId = match[1];
            return {
                provider,
                id: videoId,
                embedUrl: `https://www.youtube.com/embed/${videoId}`,
                originalUrl,
            };
        }
        case 'vimeo': {
            const videoId = match[1];
            return {
                provider,
                id: videoId,
                embedUrl: `https://player.vimeo.com/video/${videoId}`,
                originalUrl,
            };
        }
        case 'twitter': {
            const tweetId = match[1];
            return {
                provider,
                id: tweetId,
                embedUrl: `https://platform.twitter.com/embed/Tweet.html?id=${tweetId}`,
                originalUrl,
            };
        }
        case 'codepen': {
            const username = match[1];
            const penId = match[2];
            return {
                provider,
                id: penId,
                embedUrl: `https://codepen.io/${username}/embed/${penId}`,
                originalUrl,
            };
        }
        case 'codesandbox': {
            const sandboxId = match[1];
            return {
                provider,
                id: sandboxId,
                embedUrl: `https://codesandbox.io/embed/${sandboxId}`,
                originalUrl,
            };
        }
        case 'github-gist': {
            const username = match[1];
            const gistId = match[2];
            return {
                provider,
                id: gistId,
                embedUrl: `https://gist.github.com/${username}/${gistId}`,
                originalUrl,
            };
        }
        case 'spotify': {
            const type = match[1];
            const id = match[2];
            return {
                provider,
                id,
                embedUrl: `https://open.spotify.com/embed/${type}/${id}`,
                originalUrl,
            };
        }
        case 'soundcloud': {
            const trackPath = match[1];
            return {
                provider,
                id: trackPath,
                embedUrl: `https://w.soundcloud.com/player/?url=https://soundcloud.com/${trackPath}`,
                originalUrl,
            };
        }
        case 'figma': {
            const fileId = match[1];
            return {
                provider,
                id: fileId,
                embedUrl: `https://www.figma.com/embed?embed_host=marked-extensions&url=${encodeURIComponent(originalUrl)}`,
                originalUrl,
            };
        }
        case 'loom': {
            const videoId = match[1];
            return {
                provider,
                id: videoId,
                embedUrl: `https://www.loom.com/embed/${videoId}`,
                originalUrl,
            };
        }
        case 'miro': {
            const boardId = match[1];
            return {
                provider,
                id: boardId,
                embedUrl: `https://miro.com/app/live-embed/${boardId}`,
                originalUrl,
            };
        }
        case 'excalidraw': {
            // Handle both #json= and #room= URLs
            const id = match[1];
            if (originalUrl.includes('#room=')) {
                return {
                    provider,
                    id,
                    embedUrl: `https://excalidraw.com/#room=${id}`,
                    originalUrl,
                };
            }
            return {
                provider,
                id,
                embedUrl: `https://excalidraw.com/#json=${id}`,
                originalUrl,
            };
        }
        case 'drawio':
        case 'diagrams-net': {
            // For draw.io, we need to use the original URL with viewer
            const fileUrl = match[1] || encodeURIComponent(originalUrl);
            return {
                provider,
                id: fileUrl,
                embedUrl: `https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=diagram#U${fileUrl}`,
                originalUrl,
            };
        }
        default:
            return {
                provider,
                id: '',
                embedUrl: originalUrl,
                originalUrl,
            };
    }
}
/**
 * Build embed URL with parameters
 */
function buildEmbedUrlWithParams(baseUrl, params = {}, providerConfig) {
    const url = new URL(baseUrl);
    // Apply custom domain if specified
    if (providerConfig?.domain) {
        url.hostname = providerConfig.domain;
    }
    // Add provider-specific params
    if (providerConfig?.params) {
        Object.entries(providerConfig.params).forEach(([key, value]) => {
            url.searchParams.set(key, value);
        });
    }
    // Add custom params
    Object.entries(params).forEach(([key, value]) => {
        url.searchParams.set(key, value);
    });
    return url.toString();
}
/**
 * Replace template placeholders with values
 */
function replaceTemplatePlaceholders$1(template, values) {
    let result = template;
    for (const [key, value] of Object.entries(values)) {
        const regex = new RegExp(`\\{${key}\\}`, 'g');
        result = result.replace(regex, value || '');
    }
    return result;
}
/**
 * Get aspect ratio style
 */
function getAspectRatioStyle(aspectRatio, customWidth, customHeight) {
    if (customWidth && customHeight) {
        return `width: ${customWidth}; height: ${customHeight};`;
    }
    const ratios = {
        '16:9': '56.25%',
        '4:3': '75%',
        '1:1': '100%',
        '21:9': '42.85%',
    };
    const padding = ratios[aspectRatio] || ratios['16:9'];
    return `padding-bottom: ${padding};`;
}
/**
 * Build sandbox attribute value
 */
function buildSandboxAttribute(permissions) {
    return permissions.join(' ');
}
/**
 * Escape HTML to prevent XSS
 */
function escapeHtml$1(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#039;',
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
}

/**
 * Render an embed
 */
function renderEmbed(options) {
    const { embedId, meta, className, template, lazyLoad, enableSandbox, sandboxPermissions, providers } = options;
    const provider = meta.provider;
    const providerConfig = providers[provider];
    const providerName = PROVIDER_NAMES[provider] || provider;
    // Build embed URL with parameters
    const params = {
        ...meta.params,
    };
    // Add provider-specific params
    if (meta.autoplay)
        params['autoplay'] = '1';
    if (meta.muted)
        params['mute'] = '1';
    if (meta.loop)
        params['loop'] = '1';
    if (meta.startTime)
        params['start'] = meta.startTime;
    if (meta.controls === false)
        params['controls'] = '0';
    // Privacy mode for YouTube
    if (provider === 'youtube' && (meta.privacyMode || providerConfig?.domain)) {
        const urlObj = new URL(meta.url);
        urlObj.hostname = 'www.youtube-nocookie.com';
        meta.url = urlObj.toString();
    }
    const embedUrl = buildEmbedUrlWithParams(meta.url, params, providerConfig);
    // Build aspect ratio style
    const aspectRatio = meta.aspectRatio || '16:9';
    const aspectRatioStyle = getAspectRatioStyle(aspectRatio, meta.width, meta.height);
    // Build attributes
    const allowFullscreen = meta.allowFullscreen !== false ? 'allowfullscreen' : '';
    const loading = lazyLoad ? 'loading="lazy"' : '';
    const sandbox = enableSandbox
        ? `sandbox="${buildSandboxAttribute(sandboxPermissions)}"`
        : '';
    // Build loading placeholder
    const loadingPlaceholder = lazyLoad
        ? replaceTemplatePlaceholders$1(LOADING_PLACEHOLDER, {
            className,
            providerName,
        })
        : '';
    // Build caption
    const caption = meta.title
        ? `<div class="${className}-caption">${escapeHtml$1(meta.title)}</div>`
        : '';
    // Get template
    const templateToUse = template || providerConfig?.template || DEFAULT_TEMPLATE$4;
    // Replace placeholders
    return replaceTemplatePlaceholders$1(templateToUse, {
        className,
        embedId,
        provider,
        providerName,
        embedUrl,
        title: escapeHtml$1(meta.title || `${providerName} embed`),
        aspectRatioStyle,
        allowFullscreen,
        sandbox,
        loading,
        loadingPlaceholder,
        caption,
    });
}
/**
 * Render special embeds (mermaid, excalidraw, pdf, drawio)
 */
function renderSpecialEmbed(options) {
    const { embedId, meta, className } = options;
    const provider = meta.provider;
    switch (provider) {
        case 'mermaid':
            return renderMermaidEmbed(embedId, meta, className);
        case 'excalidraw':
            return renderExcalidrawEmbed(embedId, meta, className);
        case 'drawio':
        case 'diagrams-net':
            return renderDrawioEmbed(embedId, meta, className);
        case 'pdf':
            return renderPdfEmbed(embedId, meta, className);
        default:
            return renderEmbed(options);
    }
}
/**
 * Render Mermaid diagram
 */
function renderMermaidEmbed(embedId, meta, className) {
    // Extract diagram code from URL (it should be the content after 'mermaid://')
    const diagramCode = meta.url.replace(/^mermaid:\/\//, '');
    return `
<div class="${className}-container ${className}-mermaid" id="${embedId}" data-provider="mermaid">
  <div class="mermaid">
${escapeHtml$1(diagramCode)}
  </div>
  ${meta.title ? `<div class="${className}-caption">${escapeHtml$1(meta.title)}</div>` : ''}
</div>
  `;
}
/**
 * Render Excalidraw diagram
 */
function renderExcalidrawEmbed(embedId, meta, className) {
    // Excalidraw embeds use iframe with the full URL
    const embedUrl = meta.url;
    const aspectRatioStyle = getAspectRatioStyle(meta.aspectRatio || '16:9', meta.width, meta.height);
    return `
<div class="${className}-container ${className}-excalidraw" id="${embedId}" data-provider="excalidraw">
  <div class="${className}-wrapper" style="${aspectRatioStyle}">
    <iframe
      class="${className}-iframe"
      src="${embedUrl}"
      title="${escapeHtml$1(meta.title || 'Excalidraw diagram')}"
      frameborder="0"
      allowfullscreen
    ></iframe>
  </div>
  ${meta.title ? `<div class="${className}-caption">${escapeHtml$1(meta.title)}</div>` : ''}
</div>
  `;
}
/**
 * Render Draw.io / Diagrams.net diagram
 */
function renderDrawioEmbed(embedId, meta, className) {
    const embedUrl = meta.url;
    const aspectRatioStyle = getAspectRatioStyle(meta.aspectRatio || '16:9', meta.width, meta.height);
    return `
<div class="${className}-container ${className}-drawio" id="${embedId}" data-provider="drawio">
  <div class="${className}-wrapper" style="${aspectRatioStyle}">
    <iframe
      class="${className}-iframe"
      src="${embedUrl}"
      title="${escapeHtml$1(meta.title || 'Draw.io diagram')}"
      frameborder="0"
      allowfullscreen
    ></iframe>
  </div>
  ${meta.title ? `<div class="${className}-caption">${escapeHtml$1(meta.title)}</div>` : ''}
</div>
  `;
}
/**
 * Render PDF embed
 */
function renderPdfEmbed(embedId, meta, className) {
    const aspectRatioStyle = getAspectRatioStyle('4:3', meta.width, meta.height);
    return `
<div class="${className}-container ${className}-pdf" id="${embedId}" data-provider="pdf">
  <div class="${className}-wrapper" style="${aspectRatioStyle}">
    <iframe
      class="${className}-iframe"
      src="${meta.url}"
      title="${escapeHtml$1(meta.title || 'PDF document')}"
      frameborder="0"
      type="application/pdf"
    ></iframe>
  </div>
  ${meta.title ? `<div class="${className}-caption">${escapeHtml$1(meta.title)}</div>` : ''}
</div>
  `;
}

/**
 * Create embed tokenizer
 */
function createEmbedTokenizer() {
    return {
        name: 'embed',
        level: 'block',
        tokenizer(src) {
            // Regex for embed blocks: ::::embed{props}\nurl\n::::embedend
            const match = src.match(/^::::embed(?:\{([^}]*)})?s*\n([\s\S]*?)::::embedend/);
            if (!match)
                return undefined;
            const [raw, propString = '', content] = match;
            const url = content.trim();
            if (!url)
                return undefined;
            // Parse properties
            const props = parsePropString$1(propString);
            // Detect provider from URL or use explicit provider
            let provider = props['provider'];
            if (!provider) {
                const detectedProvider = detectProvider(url);
                if (!detectedProvider)
                    return undefined;
                provider = detectedProvider;
            }
            // Parse embed URL
            let embedUrl = url;
            if (!['mermaid', 'excalidraw', 'pdf', 'iframe'].includes(provider)) {
                const parsed = parseEmbedUrl(url, provider);
                if (parsed) {
                    embedUrl = parsed.embedUrl;
                }
            }
            const meta = {
                provider,
                url: embedUrl,
                title: props['title'],
                aspectRatio: (props['aspectRatio'] || props['ratio']),
                width: props['width'],
                height: props['height'],
                allowFullscreen: props['allowFullscreen'] === 'false' ? false : undefined,
                autoplay: props['autoplay'] === 'true',
                lazyLoad: props['lazyLoad'] !== 'false',
                privacyMode: props['privacyMode'] === 'true' || props['privacy'] === 'true',
                startTime: props['startTime'] || props['start'],
                muted: props['muted'] === 'true',
                loop: props['loop'] === 'true',
                className: props['className'] || props['class'],
                id: props['id'],
                theme: props['theme'] || 'light',
                controls: props['controls'] !== 'false',
                params: {},
            };
            // Parse additional params (any prop starting with 'param-')
            Object.entries(props).forEach(([key, value]) => {
                if (key.startsWith('param-')) {
                    const paramName = key.replace('param-', '');
                    meta.params[paramName] = value;
                }
            });
            return {
                type: 'embed',
                raw,
                meta,
            };
        },
    };
}
/**
 * Create renderer for embeds
 */
function createEmbedRenderer(options) {
    return {
        name: 'embed',
        renderer(token) {
            const embedToken = token;
            const meta = embedToken.meta;
            // Generate unique ID
            const embedId = meta.id || generateUniqueId$1(options.prefixId);
            // Check if special embed (mermaid, excalidraw, pdf, drawio)
            const isSpecialEmbed = ['mermaid', 'excalidraw', 'pdf', 'drawio', 'diagrams-net'].includes(meta.provider);
            const renderOptions = {
                embedId,
                meta: {
                    ...meta,
                    // Override allowFullscreen from global config if meta doesn't specify
                    allowFullscreen: meta.allowFullscreen !== undefined ? meta.allowFullscreen : options.allowFullscreen,
                },
                className: meta.className || options.className,
                template: options.template,
                lazyLoad: meta.lazyLoad !== false && options.lazyLoad,
                enableSandbox: options.enableSandbox,
                sandboxPermissions: options.sandboxPermissions,
                providers: options.providers || {},
            };
            // Render embed
            const html = isSpecialEmbed
                ? renderSpecialEmbed(renderOptions)
                : renderEmbed(renderOptions);
            // Trigger onEmbedLoad callback if defined
            if (options.onEmbedLoad && typeof options.onEmbedLoad === 'function') {
                setTimeout(() => {
                    try {
                        options.onEmbedLoad(embedId, meta.provider);
                    }
                    catch (error) {
                        console.error('Error in onEmbedLoad callback:', error);
                    }
                }, 0);
            }
            return html;
        },
    };
}

/**
 * Marked Extended Embeds extension
 * Adds support for rich media embeds from various platforms
 *
 * @example
 * ```markdown
 * ::::embed{title="My Video" aspectRatio="16:9"}
 * https://www.youtube.com/watch?v=dQw4w9WgXcQ
 * ::::embedend
 *
 * ::::embed{provider="codepen" theme="dark"}
 * https://codepen.io/username/pen/abc123
 * ::::embedend
 * ```
 *
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedEmbeds(options = {}) {
    // Merge options with defaults
    const config = { ...DEFAULT_OPTIONS$9, ...options };
    // Inject styles if needed
    if (config.injectStyles) {
        ensureStyles$5('marked-extended-embeds-styles', DEFAULT_STYLES$6);
    }
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type !== 'embed')
                return;
            const embedToken = token;
            // Apply custom token modifications if configured
            if (config.customizeToken && typeof config.customizeToken === 'function') {
                config.customizeToken(embedToken);
            }
        },
        extensions: [createEmbedTokenizer(), createEmbedRenderer(config)],
    };
}

/**
 * Default configuration options for the footnote extension
 */
const DEFAULT_OPTIONS$8 = {
    prefixId: 'fnref-',
    description: 'Footnotes',
    refMarkers: false,
    backrefSymbol: '↩',
    backrefLinks: true,
    placeholderText: '[footnotes]',
    labelFormat: (id, number) => number,
    injectStyles: true,
    smoothScroll: true,
    scrollOffset: 80,
    hoverPreview: true,
    hoverPreviewMaxLength: 200,
};
/**
 * Default CSS styles for footnotes
 */
const DEFAULT_STYLES$5 = `
/* Footnote references */
[data-fnref-ref] {
  text-decoration: none;
  color: var(--footnote-ref-color, #0066cc);
  font-weight: 500;
  transition: color 0.2s ease;
  position: relative;
  cursor: pointer;
}

[data-fnref-ref]:hover {
  color: var(--footnote-ref-hover-color, #0052a3);
}

/* Hover preview tooltip */
[data-fnref-ref]:hover::after {
  content: attr(data-footnote-preview);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%) translateY(-8px);
  background: var(--footnote-preview-bg, #2a2a2a);
  color: var(--footnote-preview-color, #ffffff);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: normal;
  line-height: 1.4;
  white-space: normal;
  max-width: min(300px, 90vw);
  min-width: 150px;
  width: auto;
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  pointer-events: none;
  opacity: 0;
  animation: footnote-fade-in 0.2s ease forwards;
  text-align: left;
}

@keyframes footnote-fade-in {
  to {
    opacity: 1;
  }
}

[data-fnref-ref]:hover::before {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%) translateY(-2px);
  border: 6px solid transparent;
  border-top-color: var(--footnote-preview-bg, #2a2a2a);
  z-index: 1001;
  pointer-events: none;
  opacity: 0;
  animation: footnote-fade-in 0.2s ease forwards;
}

/* Footnote section */
.footnotes {
  margin-top: 3rem;
  padding-top: 1.5rem;
  border-top: 2px solid var(--footnote-border-color, #e5e7eb);
  scroll-margin-top: var(--footnote-scroll-offset, 80px);
}

.footnotes ol {
  padding-left: 1.5rem;
  counter-reset: footnote-counter;
}

.footnotes li {
  scroll-margin-top: var(--footnote-scroll-offset, 80px);
  margin-bottom: 0.75rem;
  line-height: 1.6;
  position: relative;
  transition: background-color 0.3s ease;
}

.footnotes li:target {
  background-color: var(--footnote-highlight-bg, #fef3c7);
  padding: 0.5rem;
  margin-left: -0.5rem;
  border-radius: 4px;
  animation: footnote-highlight 2s ease;
}

@keyframes footnote-highlight {
  0% {
    background-color: var(--footnote-highlight-bg, #fef3c7);
  }
  100% {
    background-color: transparent;
  }
}

/* Backlink styling */
[data-fnref-backref] {
  margin-left: 0.25rem;
  text-decoration: none;
  color: var(--footnote-backref-color, #6b7280);
  font-weight: 600;
  transition: color 0.2s ease;
}

[data-fnref-backref]:hover {
  color: var(--footnote-backref-hover-color, #374151);
}

/* Screen reader only class */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  [data-fnref-ref] {
    color: var(--footnote-ref-color, #60a5fa);
  }
  
  [data-fnref-ref]:hover {
    color: var(--footnote-ref-hover-color, #93c5fd);
  }
  
  .footnotes {
    border-top-color: var(--footnote-border-color, #374151);
  }
  
  [data-fnref-backref] {
    color: var(--footnote-backref-color, #9ca3af);
  }
  
  [data-fnref-backref]:hover {
    color: var(--footnote-backref-hover-color, #d1d5db);
  }
}
`;

/**
 * Create tokenizer functions for footnote extensions
 * @param options - Configuration options
 * @returns Tokenizer extension objects
 */
function createFootnoteTokenizers(options) {
    const { placeholderText, state, escapeRegExp } = options;
    const footnoteRef = {
        name: 'footnoteRef',
        level: 'inline',
        start(src) {
            return src.match(/\[\^([^\]]+)\]/)?.index;
        },
        tokenizer(src) {
            const match = src.match(/^\[\^([^\]]+)\]/);
            if (match) {
                const id = match[1];
                // Store reference if not already present
                if (!state.footnoteRefs.has(id)) {
                    state.footnoteRefs.set(id, {
                        id,
                        number: state.footnoteRefs.size + 1,
                        refCount: 0,
                        refIds: [],
                        renderIndex: 0,
                    });
                }
                const ref = state.footnoteRefs.get(id);
                if (ref) {
                    // Increment reference count and track this reference
                    ref.refCount++;
                    const refIdSuffix = ref.refCount > 1 ? `-${ref.refCount}` : '';
                    ref.refIds.push(`${id}${refIdSuffix}`);
                }
                const number = ref ? ref.number : state.footnoteRefs.size;
                return {
                    type: 'footnoteRef',
                    raw: match[0],
                    id,
                    number,
                };
            }
            return undefined;
        },
    };
    const footnoteDefinition = {
        name: 'footnoteDefinition',
        level: 'block',
        start(src) {
            return src.match(/^\[\^([^\]]+)\]:/)?.index;
        },
        tokenizer(src) {
            const match = src.match(/^\[\^([^\]]+)]:(?:\s+|\n)([\s\S]+?)(?=\n\n|\n\[\^|$)/);
            if (match) {
                const id = match[1];
                const content = match[2].trim();
                // Store definition
                state.footnoteDefinitions.set(id, {
                    id,
                    content,
                });
                return {
                    type: 'footnoteDefinition',
                    raw: match[0],
                    id,
                    text: content,
                };
            }
            return undefined;
        },
    };
    const footnoteSection = {
        name: 'footnoteSection',
        level: 'block',
        start(src) {
            const pattern = new RegExp(`^${escapeRegExp(placeholderText)}`);
            return src.match(pattern)?.index;
        },
        tokenizer(src) {
            const pattern = new RegExp(`^${escapeRegExp(placeholderText)}`);
            const match = src.match(pattern);
            if (match) {
                state.footnoteSectionAdded = true;
                return {
                    type: 'footnoteSection',
                    raw: match[0],
                };
            }
            return undefined;
        },
    };
    return {
        footnoteRef,
        footnoteDefinition,
        footnoteSection,
    };
}

/**
 * Sets up smooth scrolling for footnote links with offset
 * @param prefixId - Prefix for footnote IDs
 * @param scrollOffset - Offset in pixels from top
 */
function setupSmoothScroll(prefixId, scrollOffset) {
    if (typeof window === 'undefined')
        return;
    // Use event delegation for better performance
    document.addEventListener('click', (e) => {
        const target = e.target;
        const link = target.closest('a[data-fnref-ref], a[data-fnref-backref]');
        if (!link)
            return;
        const href = link.getAttribute('href');
        if (!href || !href.startsWith('#'))
            return;
        const targetId = href.slice(1);
        const targetElement = document.getElementById(targetId);
        if (!targetElement)
            return;
        e.preventDefault();
        // Calculate position with offset
        const elementPosition = targetElement.getBoundingClientRect().top;
        const offsetPosition = elementPosition + window.pageYOffset - scrollOffset;
        // Smooth scroll to position
        window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth',
        });
        // Update URL hash without triggering scroll
        history.pushState(null, '', `#${targetId}`);
        // Focus the target for accessibility
        targetElement.focus({ preventScroll: true });
    }, { passive: false });
}
/**
 * Truncates text to specified length with ellipsis
 * @param text - Text to truncate
 * @param maxLength - Maximum length
 * @returns Truncated text
 */
function truncateText(text, maxLength) {
    if (text.length <= maxLength)
        return text;
    return text.slice(0, maxLength).trim() + '...';
}
/**
 * Escapes special regex characters in a string
 * @param str - String to escape
 * @returns Escaped string safe to use in regex
 */
function escapeRegExp$6(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Create renderer functions for footnote extensions
 * @param options - Configuration options
 * @returns Renderer functions
 */
function createFootnoteRenderers(options) {
    const { prefixId, labelFormat, refMarkers, hoverPreview, hoverPreviewMaxLength, state } = options;
    return {
        /**
         * Renders a footnote reference (inline superscript link)
         * @param token - The footnote reference token
         * @returns HTML string for the footnote reference
         */
        footnoteRefRenderer(token) {
            const id = `${prefixId}${token.id}`;
            const ref = state.footnoteRefs.get(token.id);
            // Use the render index to get the correct refId for this instance
            let refId = `${prefixId}ref-${token.id}`;
            if (ref) {
                if (ref.refIds.length > 0 && ref.renderIndex < ref.refIds.length) {
                    // Get the refId for this specific render instance
                    const currentRefId = ref.refIds[ref.renderIndex];
                    refId = `${prefixId}ref-${currentRefId}`;
                }
                // Increment render index for next render call
                ref.renderIndex++;
            }
            const displayLabel = labelFormat(token.id, token.number);
            // Get footnote content for hover preview
            let previewAttr = '';
            if (hoverPreview) {
                const footnoteDef = state.footnoteDefinitions.get(token.id);
                if (footnoteDef) {
                    // Use raw content directly - it's Markdown at this point, strip Markdown syntax
                    let plainText = footnoteDef.content;
                    // Remove common Markdown syntax for preview
                    plainText = plainText
                        .replace(/\*\*(.+?)\*\*/g, '$1') // Bold
                        .replace(/\*(.+?)\*/g, '$1') // Italic
                        .replace(/__(.+?)__/g, '$1') // Bold
                        .replace(/_(.+?)_/g, '$1') // Italic
                        .replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
                        .replace(/`(.+?)`/g, '$1') // Code
                        .replace(/#{1,6}\s+/g, ''); // Headers
                    const preview = truncateText(plainText, hoverPreviewMaxLength);
                    previewAttr = ` data-footnote-preview="${preview.replace(/"/g, '&quot;')}"`;
                }
            }
            return `<sup><a id="${refId}" href="#${id}" data-fnref-ref aria-describedby="${prefixId}label"${previewAttr}>${refMarkers ? `[${displayLabel}]` : displayLabel}</a></sup>`;
        },
        /**
         * Renders a footnote definition (no output - handled by generator)
         * @returns Empty string
         */
        footnoteDefRenderer() {
            // Don't render anything for the definition itself
            // Definitions are collected and rendered in the footnote section
            return '';
        },
    };
}

/**
 * marked v17.0.2 - a markdown parser
 * Copyright (c) 2018-2026, MarkedJS. (MIT License)
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT License)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function M$1(){return {async:false,breaks:false,extensions:null,gfm:true,hooks:null,pedantic:false,renderer:null,silent:false,tokenizer:null,walkTokens:null}}var T$1=M$1();function H$1(u){T$1=u;}var _$1={exec:()=>null};function k$1(u,e=""){let t=typeof u=="string"?u:u.source,n={replace:(r,i)=>{let s=typeof i=="string"?i:i.source;return s=s.replace(m$1.caret,"$1"),t=t.replace(r,s),n},getRegex:()=>new RegExp(t,e)};return n}var Re$1=(()=>{try{return !!new RegExp("(?<=1)(?<!1)")}catch{return  false}})(),m$1={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] +\S/,listReplaceTask:/^\[[ xX]\] +/,listTaskCheckbox:/\[[ xX]\]/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:u=>new RegExp(`^( {0,3}${u})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}#`),htmlBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}<(?:[a-z].*>|!--)`,"i"),blockquoteBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}>`)},Te$1=/^(?:[ \t]*(?:\n|$))+/,Oe$1=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,we$1=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,I$1=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,ye$1=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,N$1=/ {0,3}(?:[*+-]|\d{1,9}[.)])/,re$1=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,se$1=k$1(re$1).replace(/bull/g,N$1).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),Pe$1=k$1(re$1).replace(/bull/g,N$1).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),Q$1=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,Se$1=/^[^\n]+/,F$1=/(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,$e$1=k$1(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",F$1).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),_e$1=k$1(/^(bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,N$1).getRegex(),q$1="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",j$1=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,Le$1=k$1("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",j$1).replace("tag",q$1).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),ie$1=k$1(Q$1).replace("hr",I$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$1).getRegex(),Me$1=k$1(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",ie$1).getRegex(),U$1={blockquote:Me$1,code:Oe$1,def:$e$1,fences:we$1,heading:ye$1,hr:I$1,html:Le$1,lheading:se$1,list:_e$1,newline:Te$1,paragraph:ie$1,table:_$1,text:Se$1},te$1=k$1("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",I$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$1).getRegex(),ze$1={...U$1,lheading:Pe$1,table:te$1,paragraph:k$1(Q$1).replace("hr",I$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",te$1).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q$1).getRegex()},Ce$1={...U$1,html:k$1(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",j$1).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:_$1,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:k$1(Q$1).replace("hr",I$1).replace("heading",` *#{1,6} *[^
]`).replace("lheading",se$1).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},Ae$1=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,Ie$1=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,oe$1=/^( {2,}|\\)\n(?!\s*$)/,Ee$1=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,v$1=/[\p{P}\p{S}]/u,K$1=/[\s\p{P}\p{S}]/u,ae$1=/[^\s\p{P}\p{S}]/u,Be$1=k$1(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,K$1).getRegex(),le$1=/(?!~)[\p{P}\p{S}]/u,De$1=/(?!~)[\s\p{P}\p{S}]/u,qe$1=/(?:[^\s\p{P}\p{S}]|~)/u,ue$1=/(?![*_])[\p{P}\p{S}]/u,ve$1=/(?![*_])[\s\p{P}\p{S}]/u,Ge$1=/(?:[^\s\p{P}\p{S}]|[*_])/u,He$1=k$1(/link|precode-code|html/,"g").replace("link",/\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-",Re$1?"(?<!`)()":"(^^|[^`])").replace("code",/(?<b>`+)[^`]+\k<b>(?!`)/).replace("html",/<(?! )[^<>]*?>/).getRegex(),pe$1=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,Ze$1=k$1(pe$1,"u").replace(/punct/g,v$1).getRegex(),Ne$1=k$1(pe$1,"u").replace(/punct/g,le$1).getRegex(),ce$1="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",Qe$1=k$1(ce$1,"gu").replace(/notPunctSpace/g,ae$1).replace(/punctSpace/g,K$1).replace(/punct/g,v$1).getRegex(),Fe$1=k$1(ce$1,"gu").replace(/notPunctSpace/g,qe$1).replace(/punctSpace/g,De$1).replace(/punct/g,le$1).getRegex(),je$1=k$1("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ae$1).replace(/punctSpace/g,K$1).replace(/punct/g,v$1).getRegex(),Ue$1=k$1(/^~~?(?:((?!~)punct)|[^\s~])/,"u").replace(/punct/g,ue$1).getRegex(),Ke$1="^[^~]+(?=[^~])|(?!~)punct(~~?)(?=[\\s]|$)|notPunctSpace(~~?)(?!~)(?=punctSpace|$)|(?!~)punctSpace(~~?)(?=notPunctSpace)|[\\s](~~?)(?!~)(?=punct)|(?!~)punct(~~?)(?!~)(?=punct)|notPunctSpace(~~?)(?=notPunctSpace)",We$1=k$1(Ke$1,"gu").replace(/notPunctSpace/g,Ge$1).replace(/punctSpace/g,ve$1).replace(/punct/g,ue$1).getRegex(),Xe$1=k$1(/\\(punct)/,"gu").replace(/punct/g,v$1).getRegex(),Je$1=k$1(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Ve$1=k$1(j$1).replace("(?:-->|$)","-->").getRegex(),Ye$1=k$1("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",Ve$1).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),D$1=/(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/,et$1=k$1(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",D$1).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),he$1=k$1(/^!?\[(label)\]\[(ref)\]/).replace("label",D$1).replace("ref",F$1).getRegex(),ke$1=k$1(/^!?\[(ref)\](?:\[\])?/).replace("ref",F$1).getRegex(),tt$1=k$1("reflink|nolink(?!\\()","g").replace("reflink",he$1).replace("nolink",ke$1).getRegex(),ne$1=/[hH][tT][tT][pP][sS]?|[fF][tT][pP]/,W$1={_backpedal:_$1,anyPunctuation:Xe$1,autolink:Je$1,blockSkip:He$1,br:oe$1,code:Ie$1,del:_$1,delLDelim:_$1,delRDelim:_$1,emStrongLDelim:Ze$1,emStrongRDelimAst:Qe$1,emStrongRDelimUnd:je$1,escape:Ae$1,link:et$1,nolink:ke$1,punctuation:Be$1,reflink:he$1,reflinkSearch:tt$1,tag:Ye$1,text:Ee$1,url:_$1},nt$1={...W$1,link:k$1(/^!?\[(label)\]\((.*?)\)/).replace("label",D$1).getRegex(),reflink:k$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",D$1).getRegex()},Z$1={...W$1,emStrongRDelimAst:Fe$1,emStrongLDelim:Ne$1,delLDelim:Ue$1,delRDelim:We$1,url:k$1(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol",ne$1).replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,text:k$1(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol",ne$1).getRegex()},rt$1={...Z$1,br:k$1(oe$1).replace("{2,}","*").getRegex(),text:k$1(Z$1.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},E$1={normal:U$1,gfm:ze$1,pedantic:Ce$1},z$1={normal:W$1,gfm:Z$1,breaks:rt$1,pedantic:nt$1};var st$1={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},de$1=u=>st$1[u];function O$1(u,e){if(e){if(m$1.escapeTest.test(u))return u.replace(m$1.escapeReplace,de$1)}else if(m$1.escapeTestNoEncode.test(u))return u.replace(m$1.escapeReplaceNoEncode,de$1);return u}function X$1(u){try{u=encodeURI(u).replace(m$1.percentDecode,"%");}catch{return null}return u}function J$1(u,e){let t=u.replace(m$1.findPipe,(i,s,a)=>{let o=false,l=s;for(;--l>=0&&a[l]==="\\";)o=!o;return o?"|":" |"}),n=t.split(m$1.splitPipe),r=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(m$1.slashPipe,"|");return n}function C$1(u,e,t){let n=u.length;if(n===0)return "";let r=0;for(;r<n;){let i=u.charAt(n-r-1);if(i===e&&true)r++;else break}return u.slice(0,n-r)}function ge$1(u,e){if(u.indexOf(e[1])===-1)return  -1;let t=0;for(let n=0;n<u.length;n++)if(u[n]==="\\")n++;else if(u[n]===e[0])t++;else if(u[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function fe$1(u,e=0){let t=e,n="";for(let r of u)if(r==="	"){let i=4-t%4;n+=" ".repeat(i),t+=i;}else n+=r,t++;return n}function me$1(u,e,t,n,r){let i=e.href,s=e.title||null,a=u[1].replace(r.other.outputLinkReplace,"$1");n.state.inLink=true;let o={type:u[0].charAt(0)==="!"?"image":"link",raw:t,href:i,title:s,text:a,tokens:n.inlineTokens(a)};return n.state.inLink=false,o}function it$1(u,e,t){let n=u.match(t.other.indentCodeCompensation);if(n===null)return e;let r=n[1];return e.split(`
`).map(i=>{let s=i.match(t.other.beginningSpace);if(s===null)return i;let[a]=s;return a.length>=r.length?i.slice(r.length):i}).join(`
`)}var w$1=class w{options;rules;lexer;constructor(e){this.options=e||T$1;}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return {type:"space",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,"");return {type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:C$1(n,`
`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],r=it$1(n,t[3]||"",this.rules);return {type:"code",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):t[2],text:r}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let r=C$1(n,"#");(this.options.pedantic||!r||this.rules.other.endingSpaceChar.test(r))&&(n=r.trim());}return {type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return {type:"hr",raw:C$1(t[0],`
`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=C$1(t[0],`
`).split(`
`),r="",i="",s=[];for(;n.length>0;){let a=false,o=[],l;for(l=0;l<n.length;l++)if(this.rules.other.blockquoteStart.test(n[l]))o.push(n[l]),a=true;else if(!a)o.push(n[l]);else break;n=n.slice(l);let p=o.join(`
`),c=p.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");r=r?`${r}
${p}`:p,i=i?`${i}
${c}`:c;let d=this.lexer.state.top;if(this.lexer.state.top=true,this.lexer.blockTokens(c,s,true),this.lexer.state.top=d,n.length===0)break;let h=s.at(-1);if(h?.type==="code")break;if(h?.type==="blockquote"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.blockquote(f);s[s.length-1]=S,r=r.substring(0,r.length-R.raw.length)+S.raw,i=i.substring(0,i.length-R.text.length)+S.text;break}else if(h?.type==="list"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.list(f);s[s.length-1]=S,r=r.substring(0,r.length-h.raw.length)+S.raw,i=i.substring(0,i.length-R.raw.length)+S.raw,n=f.substring(s.at(-1).raw.length).split(`
`);continue}}return {type:"blockquote",raw:r,tokens:s,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),r=n.length>1,i={type:"list",raw:"",ordered:r,start:r?+n.slice(0,-1):"",loose:false,items:[]};n=r?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=r?n:"[*+-]");let s=this.rules.other.listItemRegex(n),a=false;for(;e;){let l=false,p="",c="";if(!(t=s.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let d=fe$1(t[2].split(`
`,1)[0],t[1].length),h=e.split(`
`,1)[0],R=!d.trim(),f=0;if(this.options.pedantic?(f=2,c=d.trimStart()):R?f=t[1].length+1:(f=d.search(this.rules.other.nonSpaceChar),f=f>4?1:f,c=d.slice(f),f+=t[1].length),R&&this.rules.other.blankLine.test(h)&&(p+=h+`
`,e=e.substring(h.length+1),l=true),!l){let S=this.rules.other.nextBulletRegex(f),V=this.rules.other.hrRegex(f),Y=this.rules.other.fencesBeginRegex(f),ee=this.rules.other.headingBeginRegex(f),xe=this.rules.other.htmlBeginRegex(f),be=this.rules.other.blockquoteBeginRegex(f);for(;e;){let G=e.split(`
`,1)[0],A;if(h=G,this.options.pedantic?(h=h.replace(this.rules.other.listReplaceNesting,"  "),A=h):A=h.replace(this.rules.other.tabCharGlobal,"    "),Y.test(h)||ee.test(h)||xe.test(h)||be.test(h)||S.test(h)||V.test(h))break;if(A.search(this.rules.other.nonSpaceChar)>=f||!h.trim())c+=`
`+A.slice(f);else {if(R||d.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||Y.test(d)||ee.test(d)||V.test(d))break;c+=`
`+h;}R=!h.trim(),p+=G+`
`,e=e.substring(G.length+1),d=A.slice(f);}}i.loose||(a?i.loose=true:this.rules.other.doubleBlankLine.test(p)&&(a=true)),i.items.push({type:"list_item",raw:p,task:!!this.options.gfm&&this.rules.other.listIsTask.test(c),loose:false,text:c,tokens:[]}),i.raw+=p;}let o=i.items.at(-1);if(o)o.raw=o.raw.trimEnd(),o.text=o.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let l of i.items){if(this.lexer.state.top=false,l.tokens=this.lexer.blockTokens(l.text,[]),l.task){if(l.text=l.text.replace(this.rules.other.listReplaceTask,""),l.tokens[0]?.type==="text"||l.tokens[0]?.type==="paragraph"){l.tokens[0].raw=l.tokens[0].raw.replace(this.rules.other.listReplaceTask,""),l.tokens[0].text=l.tokens[0].text.replace(this.rules.other.listReplaceTask,"");for(let c=this.lexer.inlineQueue.length-1;c>=0;c--)if(this.rules.other.listIsTask.test(this.lexer.inlineQueue[c].src)){this.lexer.inlineQueue[c].src=this.lexer.inlineQueue[c].src.replace(this.rules.other.listReplaceTask,"");break}}let p=this.rules.other.listTaskCheckbox.exec(l.raw);if(p){let c={type:"checkbox",raw:p[0]+" ",checked:p[0]!=="[ ]"};l.checked=c.checked,i.loose?l.tokens[0]&&["paragraph","text"].includes(l.tokens[0].type)&&"tokens"in l.tokens[0]&&l.tokens[0].tokens?(l.tokens[0].raw=c.raw+l.tokens[0].raw,l.tokens[0].text=c.raw+l.tokens[0].text,l.tokens[0].tokens.unshift(c)):l.tokens.unshift({type:"paragraph",raw:c.raw,text:c.raw,tokens:[c]}):l.tokens.unshift(c);}}if(!i.loose){let p=l.tokens.filter(d=>d.type==="space"),c=p.length>0&&p.some(d=>this.rules.other.anyLine.test(d.raw));i.loose=c;}}if(i.loose)for(let l of i.items){l.loose=true;for(let p of l.tokens)p.type==="text"&&(p.type="paragraph");}return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return {type:"html",block:true,raw:t[0],pre:t[1]==="pre"||t[1]==="script"||t[1]==="style",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),r=t[2]?t[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):t[3];return {type:"def",tag:n,raw:t[0],href:r,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=J$1(t[1]),r=t[2].replace(this.rules.other.tableAlignChars,"").split("|"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:t[0],header:[],align:[],rows:[]};if(n.length===r.length){for(let a of r)this.rules.other.tableAlignRight.test(a)?s.align.push("right"):this.rules.other.tableAlignCenter.test(a)?s.align.push("center"):this.rules.other.tableAlignLeft.test(a)?s.align.push("left"):s.align.push(null);for(let a=0;a<n.length;a++)s.header.push({text:n[a],tokens:this.lexer.inline(n[a]),header:true,align:s.align[a]});for(let a of i)s.rows.push(J$1(a,s.header.length).map((o,l)=>({text:o,tokens:this.lexer.inline(o),header:false,align:s.align[l]})));return s}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return {type:"heading",raw:t[0],depth:t[2].charAt(0)==="="?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`
`?t[1].slice(0,-1):t[1];return {type:"paragraph",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return {type:"text",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return {type:"escape",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return !this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=true:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=false),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=true:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=false),{type:"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:false,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let s=C$1(n.slice(0,-1),"\\");if((n.length-s.length)%2===0)return}else {let s=ge$1(t[2],"()");if(s===-2)return;if(s>-1){let o=(t[0].indexOf("!")===0?5:4)+t[1].length+s;t[2]=t[2].substring(0,s),t[0]=t[0].substring(0,o).trim(),t[3]="";}}let r=t[2],i="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(r);s&&(r=s[1],i=s[3]);}else i=t[3]?t[3].slice(1,-1):"";return r=r.trim(),this.rules.other.startAngleBracket.test(r)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?r=r.slice(1):r=r.slice(1,-1)),me$1(t,{href:r&&r.replace(this.rules.inline.anyPunctuation,"$1"),title:i&&i.replace(this.rules.inline.anyPunctuation,"$1")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let r=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),i=t[r.toLowerCase()];if(!i){let s=n[0].charAt(0);return {type:"text",raw:s,text:s}}return me$1(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=""){let r=this.rules.inline.emStrongLDelim.exec(e);if(!r||r[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(r[1]||r[2]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=0,c=r[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+s);(r=c.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a)continue;if(o=[...a].length,r[3]||r[4]){l+=o;continue}else if((r[5]||r[6])&&s%3&&!((s+o)%3)){p+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l+p);let d=[...r[0]][0].length,h=e.slice(0,s+r.index+d+o);if(Math.min(s,o)%2){let f=h.slice(1,-1);return {type:"em",raw:h,text:f,tokens:this.lexer.inlineTokens(f)}}let R=h.slice(2,-2);return {type:"strong",raw:h,text:R,tokens:this.lexer.inlineTokens(R)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal," "),r=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return r&&i&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return {type:"br",raw:t[0]}}del(e,t,n=""){let r=this.rules.inline.delLDelim.exec(e);if(!r)return;if(!(r[1]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=this.rules.inline.delRDelim;for(p.lastIndex=0,t=t.slice(-1*e.length+s);(r=p.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a||(o=[...a].length,o!==s))continue;if(r[3]||r[4]){l+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l);let c=[...r[0]][0].length,d=e.slice(0,s+r.index+c+o),h=d.slice(s,-s);return {type:"del",raw:d,text:h,tokens:this.lexer.inlineTokens(h)}}}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,r;return t[2]==="@"?(n=t[1],r="mailto:"+n):(n=t[1],r=n),{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,r;if(t[2]==="@")n=t[0],r="mailto:"+n;else {let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??"";while(i!==t[0]);n=t[0],t[1]==="www."?r="http://"+t[0]:r=t[0];}return {type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return {type:"text",raw:t[0],text:t[0],escaped:n}}}};var x$1=class u{tokens;options;state;inlineQueue;tokenizer;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||T$1,this.options.tokenizer=this.options.tokenizer||new w$1,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:false,inRawBlock:false,top:true};let t={other:m$1,block:E$1.normal,inline:z$1.normal};this.options.pedantic?(t.block=E$1.pedantic,t.inline=z$1.pedantic):this.options.gfm&&(t.block=E$1.gfm,this.options.breaks?t.inline=z$1.breaks:t.inline=z$1.gfm),this.tokenizer.rules=t;}static get rules(){return {block:E$1,inline:z$1}}static lex(e,t){return new u(t).lex(e)}static lexInline(e,t){return new u(t).inlineTokens(e)}lex(e){e=e.replace(m$1.carriageReturn,`
`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens);}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=false){for(this.options.pedantic&&(e=e.replace(m$1.tabCharGlobal,"    ").replace(m$1.spaceLine,""));e;){let r;if(this.options.extensions?.block?.some(s=>(r=s.call({lexer:this},e,t))?(e=e.substring(r.raw.length),t.push(r),true):false))continue;if(r=this.tokenizer.space(e)){e=e.substring(r.raw.length);let s=t.at(-1);r.raw.length===1&&s!==void 0?s.raw+=`
`:t.push(r);continue}if(r=this.tokenizer.code(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(r=this.tokenizer.fences(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.heading(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.hr(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.blockquote(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.list(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.html(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.def(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.raw,this.inlineQueue.at(-1).src=s.text):this.tokens.links[r.tag]||(this.tokens.links[r.tag]={href:r.href,title:r.title},t.push(r));continue}if(r=this.tokenizer.table(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.lheading(e)){e=e.substring(r.raw.length),t.push(r);continue}let i=e;if(this.options.extensions?.startBlock){let s=1/0,a=e.slice(1),o;this.options.extensions.startBlock.forEach(l=>{o=l.call({lexer:this},a),typeof o=="number"&&o>=0&&(s=Math.min(s,o));}),s<1/0&&s>=0&&(i=e.substring(0,s+1));}if(this.state.top&&(r=this.tokenizer.paragraph(i))){let s=t.at(-1);n&&s?.type==="paragraph"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r),n=i.length!==e.length,e=e.substring(r.raw.length);continue}if(r=this.tokenizer.text(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(e){let s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=true,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,r=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,r.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let i;for(;(r=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)i=r[2]?r[2].length:0,n=n.slice(0,r.index+i)+"["+"a".repeat(r[0].length-i-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);n=this.options.hooks?.emStrongMask?.call({lexer:this},n)??n;let s=false,a="";for(;e;){s||(a=""),s=false;let o;if(this.options.extensions?.inline?.some(p=>(o=p.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),true):false))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let p=t.at(-1);o.type==="text"&&p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let l=e;if(this.options.extensions?.startInline){let p=1/0,c=e.slice(1),d;this.options.extensions.startInline.forEach(h=>{d=h.call({lexer:this},c),typeof d=="number"&&d>=0&&(p=Math.min(p,d));}),p<1/0&&p>=0&&(l=e.substring(0,p+1));}if(o=this.tokenizer.inlineText(l)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(a=o.raw.slice(-1)),s=true;let p=t.at(-1);p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(e){let p="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(p);break}else throw new Error(p)}}return t}};var y$1=class y{options;parser;constructor(e){this.options=e||T$1;}space(e){return ""}code({text:e,lang:t,escaped:n}){let r=(t||"").match(m$1.notSpaceStart)?.[0],i=e.replace(m$1.endingNewline,"")+`
`;return r?'<pre><code class="language-'+O$1(r)+'">'+(n?i:O$1(i,true))+`</code></pre>
`:"<pre><code>"+(n?i:O$1(i,true))+`</code></pre>
`}blockquote({tokens:e}){return `<blockquote>
${this.parser.parse(e)}</blockquote>
`}html({text:e}){return e}def(e){return ""}heading({tokens:e,depth:t}){return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`}hr(e){return `<hr>
`}list(e){let t=e.ordered,n=e.start,r="";for(let a=0;a<e.items.length;a++){let o=e.items[a];r+=this.listitem(o);}let i=t?"ol":"ul",s=t&&n!==1?' start="'+n+'"':"";return "<"+i+s+`>
`+r+"</"+i+`>
`}listitem(e){return `<li>${this.parser.parse(e.tokens)}</li>
`}checkbox({checked:e}){return "<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"> '}paragraph({tokens:e}){return `<p>${this.parser.parseInline(e)}</p>
`}table(e){let t="",n="";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let r="";for(let i=0;i<e.rows.length;i++){let s=e.rows[i];n="";for(let a=0;a<s.length;a++)n+=this.tablecell(s[a]);r+=this.tablerow({text:n});}return r&&(r=`<tbody>${r}</tbody>`),`<table>
<thead>
`+t+`</thead>
`+r+`</table>
`}tablerow({text:e}){return `<tr>
${e}</tr>
`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?"th":"td";return (e.align?`<${n} align="${e.align}">`:`<${n}>`)+t+`</${n}>
`}strong({tokens:e}){return `<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return `<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return `<code>${O$1(e,true)}</code>`}br(e){return "<br>"}del({tokens:e}){return `<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let r=this.parser.parseInline(n),i=X$1(e);if(i===null)return r;e=i;let s='<a href="'+e+'"';return t&&(s+=' title="'+O$1(t)+'"'),s+=">"+r+"</a>",s}image({href:e,title:t,text:n,tokens:r}){r&&(n=this.parser.parseInline(r,this.parser.textRenderer));let i=X$1(e);if(i===null)return O$1(n);e=i;let s=`<img src="${e}" alt="${n}"`;return t&&(s+=` title="${O$1(t)}"`),s+=">",s}text(e){return "tokens"in e&&e.tokens?this.parser.parseInline(e.tokens):"escaped"in e&&e.escaped?e.text:O$1(e.text)}};var $$1=class ${strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return ""+e}image({text:e}){return ""+e}br(){return ""}checkbox({raw:e}){return e}};var b$1=class u{options;renderer;textRenderer;constructor(e){this.options=e||T$1,this.options.renderer=this.options.renderer||new y$1,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new $$1;}static parse(e,t){return new u(t).parse(e)}static parseInline(e,t){return new u(t).parseInline(e)}parse(e){let t="";for(let n=0;n<e.length;n++){let r=e[n];if(this.options.extensions?.renderers?.[r.type]){let s=r,a=this.options.extensions.renderers[s.type].call({parser:this},s);if(a!==false||!["space","hr","heading","code","table","blockquote","list","html","def","paragraph","text"].includes(s.type)){t+=a||"";continue}}let i=r;switch(i.type){case "space":{t+=this.renderer.space(i);break}case "hr":{t+=this.renderer.hr(i);break}case "heading":{t+=this.renderer.heading(i);break}case "code":{t+=this.renderer.code(i);break}case "table":{t+=this.renderer.table(i);break}case "blockquote":{t+=this.renderer.blockquote(i);break}case "list":{t+=this.renderer.list(i);break}case "checkbox":{t+=this.renderer.checkbox(i);break}case "html":{t+=this.renderer.html(i);break}case "def":{t+=this.renderer.def(i);break}case "paragraph":{t+=this.renderer.paragraph(i);break}case "text":{t+=this.renderer.text(i);break}default:{let s='Token with "'+i.type+'" type was not found.';if(this.options.silent)return console.error(s),"";throw new Error(s)}}}return t}parseInline(e,t=this.renderer){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let a=this.options.extensions.renderers[i.type].call({parser:this},i);if(a!==false||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){n+=a||"";continue}}let s=i;switch(s.type){case "escape":{n+=t.text(s);break}case "html":{n+=t.html(s);break}case "link":{n+=t.link(s);break}case "image":{n+=t.image(s);break}case "checkbox":{n+=t.checkbox(s);break}case "strong":{n+=t.strong(s);break}case "em":{n+=t.em(s);break}case "codespan":{n+=t.codespan(s);break}case "br":{n+=t.br(s);break}case "del":{n+=t.del(s);break}case "text":{n+=t.text(s);break}default:{let a='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(a),"";throw new Error(a)}}}return n}};var P$1=class P{options;block;constructor(e){this.options=e||T$1;}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens","emStrongMask"]);static passThroughHooksRespectAsync=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}emStrongMask(e){return e}provideLexer(){return this.block?x$1.lex:x$1.lexInline}provideParser(){return this.block?b$1.parse:b$1.parseInline}};var B$1=class B{defaults=M$1();options=this.setOptions;parse=this.parseMarkdown(true);parseInline=this.parseMarkdown(false);Parser=b$1;Renderer=y$1;TextRenderer=$$1;Lexer=x$1;Tokenizer=w$1;Hooks=P$1;constructor(...e){this.use(...e);}walkTokens(e,t){let n=[];for(let r of e)switch(n=n.concat(t.call(this,r)),r.type){case "table":{let i=r;for(let s of i.header)n=n.concat(this.walkTokens(s.tokens,t));for(let s of i.rows)for(let a of s)n=n.concat(this.walkTokens(a.tokens,t));break}case "list":{let i=r;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=r;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(s=>{let a=i[s].flat(1/0);n=n.concat(this.walkTokens(a,t));}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)));}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let r={...n};if(r.async=this.defaults.async||r.async||false,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error("extension name required");if("renderer"in i){let s=t.renderers[i.name];s?t.renderers[i.name]=function(...a){let o=i.renderer.apply(this,a);return o===false&&(o=s.apply(this,a)),o}:t.renderers[i.name]=i.renderer;}if("tokenizer"in i){if(!i.level||i.level!=="block"&&i.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=t[i.level];s?s.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level==="block"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level==="inline"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]));}"childTokens"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens);}),r.extensions=t),n.renderer){let i=this.defaults.renderer||new y$1(this.defaults);for(let s in n.renderer){if(!(s in i))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let a=s,o=n.renderer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c||""};}r.renderer=i;}if(n.tokenizer){let i=this.defaults.tokenizer||new w$1(this.defaults);for(let s in n.tokenizer){if(!(s in i))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let a=s,o=n.tokenizer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.tokenizer=i;}if(n.hooks){let i=this.defaults.hooks||new P$1;for(let s in n.hooks){if(!(s in i))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let a=s,o=n.hooks[a],l=i[a];P$1.passThroughHooks.has(s)?i[a]=p=>{if(this.defaults.async&&P$1.passThroughHooksRespectAsync.has(s))return (async()=>{let d=await o.call(i,p);return l.call(i,d)})();let c=o.call(i,p);return l.call(i,c)}:i[a]=(...p)=>{if(this.defaults.async)return (async()=>{let d=await o.apply(i,p);return d===false&&(d=await l.apply(i,p)),d})();let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.hooks=i;}if(n.walkTokens){let i=this.defaults.walkTokens,s=n.walkTokens;r.walkTokens=function(a){let o=[];return o.push(s.call(this,a)),i&&(o=o.concat(i.call(this,a))),o};}this.defaults={...this.defaults,...r};}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return x$1.lex(e,t??this.defaults)}parser(e,t){return b$1.parse(e,t??this.defaults)}parseMarkdown(e){return (n,r)=>{let i={...r},s={...this.defaults,...i},a=this.onError(!!s.silent,!!s.async);if(this.defaults.async===true&&i.async===false)return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return a(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return a(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(s.hooks&&(s.hooks.options=s,s.hooks.block=e),s.async)return (async()=>{let o=s.hooks?await s.hooks.preprocess(n):n,p=await(s.hooks?await s.hooks.provideLexer():e?x$1.lex:x$1.lexInline)(o,s),c=s.hooks?await s.hooks.processAllTokens(p):p;s.walkTokens&&await Promise.all(this.walkTokens(c,s.walkTokens));let h=await(s.hooks?await s.hooks.provideParser():e?b$1.parse:b$1.parseInline)(c,s);return s.hooks?await s.hooks.postprocess(h):h})().catch(a);try{s.hooks&&(n=s.hooks.preprocess(n));let l=(s.hooks?s.hooks.provideLexer():e?x$1.lex:x$1.lexInline)(n,s);s.hooks&&(l=s.hooks.processAllTokens(l)),s.walkTokens&&this.walkTokens(l,s.walkTokens);let c=(s.hooks?s.hooks.provideParser():e?b$1.parse:b$1.parseInline)(l,s);return s.hooks&&(c=s.hooks.postprocess(c)),c}catch(o){return a(o)}}}onError(e,t){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,e){let r="<p>An error occurred:</p><pre>"+O$1(n.message+"",true)+"</pre>";return t?Promise.resolve(r):r}if(t)return Promise.reject(n);throw n}}};var L$1=new B$1;function g$1(u,e){return L$1.parse(u,e)}g$1.options=g$1.setOptions=function(u){return L$1.setOptions(u),g$1.defaults=L$1.defaults,H$1(g$1.defaults),g$1};g$1.getDefaults=M$1;g$1.defaults=T$1;g$1.use=function(...u){return L$1.use(...u),g$1.defaults=L$1.defaults,H$1(g$1.defaults),g$1};g$1.walkTokens=function(u,e){return L$1.walkTokens(u,e)};g$1.parseInline=L$1.parseInline;g$1.Parser=b$1;g$1.parser=b$1.parse;g$1.Renderer=y$1;g$1.TextRenderer=$$1;g$1.Lexer=x$1;g$1.lexer=x$1.lex;g$1.Tokenizer=w$1;g$1.Hooks=P$1;g$1.parse=g$1;g$1.options;g$1.setOptions;g$1.use;g$1.walkTokens;g$1.parseInline;b$1.parse;x$1.lex;

/**
 * Create a footnote section generator
 * @param options - Configuration options
 * @returns Generator functions
 */
function createFootnoteGenerator(options) {
    const { prefixId, description, backrefLinks, backrefSymbol, labelFormat, state } = options;
    return {
        /**
         * Generates the HTML for the footnotes section
         * @returns HTML string containing all footnotes
         */
        generateFootnoteSection() {
            // Only include footnotes that have both a reference and a definition
            const validFootnotes = [];
            // Collect all defined footnotes that have references
            for (const [id, def] of state.footnoteDefinitions) {
                if (state.footnoteRefs.has(id)) {
                    const ref = state.footnoteRefs.get(id);
                    validFootnotes.push({
                        id,
                        content: def.content,
                        number: ref ? ref.number : 0,
                    });
                }
            }
            // If no valid footnotes, return empty string
            if (validFootnotes.length === 0)
                return '';
            // Sort footnotes by their number
            validFootnotes.sort((a, b) => {
                const aNum = Number(a.number);
                const bNum = Number(b.number);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a.number).localeCompare(String(b.number));
            });
            let section = '<section class="footnotes" data-footnotes>\n';
            section += `  <h2 id="${prefixId}label" class="sr-only">${description}</h2>\n`;
            section += '  <ol>\n';
            for (const footnote of validFootnotes) {
                const id = `${prefixId}${footnote.id}`;
                const refId = `${prefixId}ref-${footnote.id}`;
                section += `    <li id="${id}" value="${footnote.number}">\n`;
                // Parse any markdown inside the footnote
                let content = footnote.content;
                // Save the current state to prevent recursion
                const savedState = {
                    refs: new Map(state.footnoteRefs),
                    defs: new Map(state.footnoteDefinitions),
                    added: state.footnoteSectionAdded,
                    isProcessing: state.isProcessingFootnoteSection,
                };
                // Set recursion guard
                state.isProcessingFootnoteSection = true;
                try {
                    // Parse any markdown inside the footnote
                    // marked.parse can return string or Promise<string> depending on configuration
                    const parsed = g$1.parse(content, { async: false });
                    content = parsed.trim();
                }
                catch (error) {
                    console.warn('Error parsing footnote content:', error);
                    // Fall back to plain text
                    content = footnote.content;
                }
                finally {
                    // Restore state
                    state.footnoteRefs = savedState.refs;
                    state.footnoteDefinitions = savedState.defs;
                    state.footnoteSectionAdded = savedState.added;
                    state.isProcessingFootnoteSection = savedState.isProcessing;
                }
                // Remove wrapping <p> tags if present
                if (content.startsWith('<p>') && content.endsWith('</p>')) {
                    content = content.slice(3, -4);
                }
                section += `      <p>${content}`;
                // Add backlink(s) if enabled
                if (backrefLinks) {
                    const ref = state.footnoteRefs.get(footnote.id);
                    const displayLabel = labelFormat(footnote.id, footnote.number);
                    if (ref && ref.refCount > 1) {
                        // Multiple references - show all backlinks
                        section += ' ';
                        for (let i = 0; i < ref.refCount; i++) {
                            const refIdSuffix = i > 0 ? `-${i + 1}` : '';
                            const backlinkRefId = `${prefixId}ref-${footnote.id}${refIdSuffix}`;
                            const backlinkLabel = String.fromCharCode(97 + i); // a, b, c, etc.
                            section += `<a href="#${backlinkRefId}" data-fnref-backref aria-label="Back to reference ${displayLabel}${backlinkLabel}">${backrefSymbol}<sup>${backlinkLabel}</sup></a> `;
                        }
                    }
                    else {
                        // Single reference - simple backlink
                        section += ` <a href="#${refId}" data-fnref-backref aria-label="Back to reference ${displayLabel}">${backrefSymbol}</a>`;
                    }
                }
                section += '</p>\n';
                section += '    </li>\n';
            }
            section += '  </ol>\n';
            section += '</section>\n';
            // Reset footnotes after generating the section
            state.resetFootnotes();
            return section;
        },
    };
}

/**
 * Injects CSS styles into the document head
 * @param id - Unique identifier for the style element
 * @param styles - CSS content to inject
 */
function injectStyles(id, styles) {
    if (typeof document === 'undefined')
        return;
    // Check if styles already injected
    if (document.getElementById(id))
        return;
    const styleEl = document.createElement('style');
    styleEl.id = id;
    styleEl.textContent = styles;
    document.head.appendChild(styleEl);
}

/**
 * Enhanced footnote extension for Marked.js
 *
 * This extension adds comprehensive footnote support to Marked, including
 * - Inline footnote references: [^1], [^note], etc.
 * - Footnote definitions: [^1]: This is a footnote
 * - Automatic footnote section generation at the end of content
 * - Optional placeholder to control footnote position: [footnotes]
 * - Customizable formatting and styling options
 *
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedFootnote(options = {}) {
    const config = { ...DEFAULT_OPTIONS$8, ...options };
    // Inject styles if enabled
    if (config.injectStyles) {
        injectStyles('marked-extended-footnote-styles', DEFAULT_STYLES$5);
    }
    // Set up smooth scrolling if enabled
    if (config.smoothScroll) {
        setupSmoothScroll(config.prefixId, config.scrollOffset);
    }
    // Shared state for tracking footnotes
    const state = {
        footnoteRefs: new Map(),
        footnoteDefinitions: new Map(),
        footnoteSectionAdded: false,
        isProcessingFootnoteSection: false,
        resetFootnotes() {
            this.footnoteRefs = new Map();
            this.footnoteDefinitions = new Map();
            this.footnoteSectionAdded = false;
            this.isProcessingFootnoteSection = false;
        },
    };
    // Create the footnote section generator
    const { generateFootnoteSection } = createFootnoteGenerator({ ...config, state });
    // Create tokenizers
    const { footnoteRef, footnoteDefinition, footnoteSection } = createFootnoteTokenizers({
        placeholderText: config.placeholderText,
        state,
        escapeRegExp: escapeRegExp$6,
    });
    // Create renderers with state for hover preview
    const renderers = createFootnoteRenderers({ ...config, state });
    return {
        extensions: [
            {
                name: 'footnoteRef',
                level: 'inline',
                start: footnoteRef.start,
                tokenizer: footnoteRef.tokenizer,
                renderer: function (token) {
                    return renderers.footnoteRefRenderer(token);
                },
            },
            {
                name: 'footnoteDefinition',
                level: 'block',
                start: footnoteDefinition.start,
                tokenizer: footnoteDefinition.tokenizer,
                renderer: function () {
                    return renderers.footnoteDefRenderer();
                },
            },
            {
                name: 'footnoteSection',
                level: 'block',
                start: footnoteSection.start,
                tokenizer: footnoteSection.tokenizer,
                renderer: function () {
                    return generateFootnoteSection();
                },
            },
        ],
        hooks: {
            postprocess(html) {
                // Only add footnotes if:
                // 1. There are references and definitions
                // 2. Section hasn't been explicitly added via placeholder
                // 3. Not currently processing (prevent recursion)
                if (state.footnoteRefs.size > 0
                    && state.footnoteDefinitions.size > 0
                    && !state.footnoteSectionAdded
                    && !state.isProcessingFootnoteSection) {
                    // Set recursion guard flag
                    state.isProcessingFootnoteSection = true;
                    // Generate the footnote section
                    const footnotesHtml = generateFootnoteSection();
                    // Reset the recursion guard
                    state.isProcessingFootnoteSection = false;
                    // Add the footnotes to HTML
                    html += footnotesHtml;
                    // Clear refs and definitions since we've processed them
                    state.footnoteRefs.clear();
                    state.footnoteDefinitions.clear();
                }
                return html;
            },
        },
    };
}

/**
 * Ensures that the extension styles are injected into the document head.
 * @param id - The unique identifier for the style element
 * @param styles - The CSS styles to inject
 */
function ensureStyles$4(id, styles) {
    // Check if we're in a browser environment
    if (typeof document === 'undefined')
        return;
    // Check if styles are already injected
    if (document.getElementById(id))
        return;
    // Create and inject the style element
    const styleElement = document.createElement('style');
    styleElement.id = id;
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
}

/**
 * The default configuration options for the Kanban component.
 */
const DEFAULT_OPTIONS$7 = {
    className: 'marked-extended-kanban',
    defaultView: 'board',
    showTaskCount: true,
    template: null,
    customizeToken: null,
    injectStyles: true,
};
/**
 * The default Kanban board template.
 * Uses placeholders that will be replaced during rendering:
 * - {kanbanId} - Unique ID for the Kanban board
 * - {className} - CSS class name
 * - {viewMode} - Current view mode
 * - {columnsHtml} - Rendered columns HTML
 * - {viewSwitcher} - View switcher HTML
 */
const DEFAULT_TEMPLATE$3 = `
<div id="{kanbanId}" class="{className}" data-view-mode="{viewMode}">
  <div class="{className}-header">
    <div class="{className}-view-switcher">
      {viewSwitcher}
    </div>
  </div>
  <div class="{className}-container">
    {columnsHtml}
  </div>
</div>
`;
/**
 * Default structural styles for the Kanban component (minimal, layout-only).
 */
const DEFAULT_STYLES$4 = `
  .marked-extended-kanban { margin: 1.5rem 0; padding: 0; overflow: visible; }
  .marked-extended-kanban-header { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 1.25rem; padding: 0.75rem 0; }
  .marked-extended-kanban-view-switcher { display: flex; gap: 0.5rem; padding: 0.25rem; }
  .marked-extended-kanban-view-button { padding: 0.5rem 1rem; border: none; cursor: pointer; }
  .marked-extended-kanban[data-view-mode="board"] .marked-extended-kanban-container { display: flex; flex-direction: row; gap: 1.25rem; align-items: stretch; overflow-x: auto; padding-bottom: 0.5rem; }
  .marked-extended-kanban[data-view-mode="board"] .marked-extended-kanban-column { flex: 1 1 280px; min-width: 280px; max-width: 400px; padding: 1rem; min-height: 120px; }
  .marked-extended-kanban-column-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; }
  .marked-extended-kanban-column-title { margin: 0; line-height: 1.4; }
  .marked-extended-kanban-column-count { padding: 0.25rem 0.6rem; min-width: 28px; text-align: center; }
  .marked-extended-kanban-column-tasks { display: flex; flex-direction: column; gap: 0.75rem; }
  .marked-extended-kanban-task { padding: 1rem; cursor: pointer; }
  .marked-extended-kanban-task-title { margin: 0 0 0.5rem 0; line-height: 1.5; }
  .marked-extended-kanban-task-description { margin: 0 0 0.5rem 0; line-height: 1.5; }
  .marked-extended-kanban-task-tags { display: flex; flex-wrap: wrap; gap: 0.375rem; margin-top: 0.75rem; }
  .marked-extended-kanban-task-tag { padding: 0.25rem 0.6rem; line-height: 1.2; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-container { display: block; overflow-x: auto; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-column { display: none; }
  .marked-extended-kanban[data-view-mode="board"] .marked-extended-kanban-table,
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-table { display: none; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-table { width: 100%; border-collapse: collapse; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-table th,
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-table td { padding: 1rem 1.25rem; text-align: left; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-table th { position: sticky; top: 0; z-index: 1; white-space: nowrap; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-table td { vertical-align: top; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-column-label { display: inline-block; padding: 0.4rem 0.875rem; white-space: nowrap; }
  .marked-extended-kanban[data-view-mode="table"] .marked-extended-kanban-task-tag { display: inline-block; margin-right: 0.375rem; margin-bottom: 0.375rem; padding: 0.3rem 0.7rem; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-container { display: flex; flex-direction: column; gap: 1.5rem; padding: 0; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column { margin-bottom: 0; padding: 1.25rem; min-width: 0; max-width: 100%; flex: none; min-height: auto; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column:last-child { margin-bottom: 0; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column-header { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.25rem; margin-bottom: 1rem; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column-title { margin: 0; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column-count { padding: 0.2rem 0.5rem; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-column-tasks { display: flex; flex-direction: column; gap: 0.5rem; padding-left: 1rem; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-task { display: flex; flex-direction: row; flex-wrap: wrap; align-items: flex-start; gap: 0.75rem; padding: 0.75rem 1rem; cursor: default; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-task-title { flex: 1 1 auto; min-width: 200px; line-height: 1.5; margin: 0; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-task-description { flex: 2 1 300px; margin: 0; line-height: 1.5; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-task-tags { flex: 0 0 auto; display: flex; flex-wrap: wrap; gap: 0.375rem; align-items: center; justify-content: flex-end; margin: 0; }
  .marked-extended-kanban[data-view-mode="list"] .marked-extended-kanban-task-tag { padding: 0.15rem 0.5rem; }
  @media (max-width: 768px) {
    .marked-extended-kanban { padding: 1rem; margin: 1rem 0; }
    .marked-extended-kanban[data-view-mode="board"] .marked-extended-kanban-container { gap: 1rem; }
    .marked-extended-kanban-view-switcher { flex-wrap: wrap; }
    .marked-extended-kanban-view-button { padding: 0.4rem 0.75rem; }
  }
`;

/**
 * Regular expression for parsing properties from attribute strings
 * Matches patterns like: property="value"
 */
const propRegex$3 = /\s*(\w+)="([^"]+)"/g;
/**
 * Element patterns configuration for kanban blocks
 */
const elementPatterns$3 = {
    kanbanBlock: {
        start: '::::kanban',
        end: '::::kanbanend',
        aliases: [':kbn', ':kanban', ':::kanban'],
        endAliases: [':kbnend', ':kanbanend', ':::kanbanend'],
    },
    kanbanColumnBlock: {
        start: ':::column',
        end: ':::columnend',
        aliases: [':col', ':column'],
        endAliases: [':colend', ':columnend'],
    },
};
/**
 * Supported properties by element type
 */
const supportedPropsByElement$3 = {
    kanbanBlock: [
        { name: 'view', defaultValue: 'board' },
    ],
    kanbanColumnBlock: [
        { name: 'label', defaultValue: '' },
        { name: 'color', defaultValue: '#6c757d' },
    ],
};
/**
 * Escapes special regex characters in a string
 * @param str - String to escape
 * @returns Escaped string safe for use in RegExp
 */
function escapeRegExp$5(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
/**
 * Generates regex for kanban column matching
 * Dynamically created from element patterns configuration
 */
const generateKanbanColumnRegex = () => {
    const pattern = elementPatterns$3['kanbanColumnBlock'];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    const startPatterns = [start, ...aliases].map(escapeRegExp$5).join('|');
    const endPatterns = [end, ...endAliases].map(escapeRegExp$5).join('|');
    return new RegExp(`(?:${startPatterns})\\{(.*?)\\}([\\s\\S]*?)(?:${endPatterns})(?:\\n|$)`, 'g');
};
/**
 * Regex for matching kanban column blocks
 * Exported for use in kanban tokenizer
 */
const kanbanColumnRegex = generateKanbanColumnRegex();
/**
 * Parses balanced opening and closing tags with proper nesting support
 * @param src - Source string to parse
 * @param elementType - Type of element to parse
 * @returns RegExpExecArray or null if no match
 */
function parseBalancedTags$2(src, elementType) {
    const pattern = elementPatterns$3[elementType];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    // Find which start pattern matches
    let startPos = 0;
    if (src.startsWith(start)) {
        startPos = start.length;
    }
    else {
        for (const alias of aliases) {
            if (src.startsWith(alias)) {
                startPos = alias.length;
                break;
            }
        }
        if (startPos === 0)
            return null;
    }
    // Find property block
    let depth = 1;
    const propEnd = src.indexOf('}', startPos);
    if (propEnd === -1)
        return null;
    const propString = src.substring(startPos, propEnd);
    const contentStart = propEnd + 1;
    let pos = contentStart;
    // Parse nested content with depth tracking
    while (pos < src.length && depth > 0) {
        // Find next start tag
        const mainStartPos = src.indexOf(start, pos);
        let nextStartPos = mainStartPos;
        for (const alias of aliases) {
            const aliasPos = src.indexOf(alias, pos);
            if (aliasPos !== -1 && (nextStartPos === -1 || aliasPos < nextStartPos)) {
                nextStartPos = aliasPos;
            }
        }
        // Find next end tag
        let foundEndPattern = end;
        let nextEndPos = src.indexOf(end, pos);
        for (const endAlias of endAliases) {
            const endAliasPos = src.indexOf(endAlias, pos);
            if (endAliasPos !== -1 && (nextEndPos === -1 || endAliasPos < nextEndPos)) {
                nextEndPos = endAliasPos;
                foundEndPattern = endAlias;
            }
        }
        if (nextEndPos === -1)
            return null;
        // Handle nested tags
        if (nextStartPos !== -1 && nextStartPos < nextEndPos) {
            depth++;
            let matchedPattern = start;
            if (nextStartPos === mainStartPos) {
                matchedPattern = start;
            }
            else {
                for (const alias of aliases) {
                    if (src.indexOf(alias, pos) === nextStartPos) {
                        matchedPattern = alias;
                        break;
                    }
                }
            }
            pos = nextStartPos + matchedPattern.length;
            continue;
        }
        // Check if we've closed all nested tags
        if (--depth === 0) {
            const content = src.substring(contentStart, nextEndPos);
            const fullMatch = src.substring(0, nextEndPos + foundEndPattern.length);
            const result = [fullMatch, propString, content];
            result.index = 0;
            result.input = src;
            return result;
        }
        pos = nextEndPos + foundEndPattern.length;
    }
    return null;
}
/**
 * Validates and parses element patterns from source string
 * @param element - Element type to validate
 * @param src - Source string to parse
 * @returns RegExpExecArray or null if no match
 */
const validateRegex$3 = (element, src) => {
    switch (element) {
        case 'kanbanBlock':
            return parseBalancedTags$2(src, element);
        case 'kanbanColumnBlock':
            return kanbanColumnRegex ? kanbanColumnRegex.exec(src) : null;
        default:
            throw new Error(`Unknown element: ${element}`);
    }
};
/**
 * Constructs properties object from property string
 * @param element - Element type
 * @param propString - String containing properties
 * @returns Record of property names to values
 */
const constructProps$3 = (element, propString) => {
    const supportedProps = supportedPropsByElement$3[element];
    if (!supportedProps) {
        throw new Error(`Unknown element: ${element}`);
    }
    // Initialize with default values
    const props = {};
    supportedProps.forEach((prop) => {
        props[prop.name] = prop.defaultValue;
    });
    // Parse and override with actual values
    propRegex$3.lastIndex = 0;
    let propMatch;
    while ((propMatch = propRegex$3.exec(propString)) !== null) {
        const [, name, value] = propMatch;
        if (supportedProps.some((p) => p.name === name)) {
            props[name] = value;
        }
    }
    return props;
};

/**
 * marked v17.0.2 - a markdown parser
 * Copyright (c) 2018-2026, MarkedJS. (MIT License)
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT License)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function M(){return {async:false,breaks:false,extensions:null,gfm:true,hooks:null,pedantic:false,renderer:null,silent:false,tokenizer:null,walkTokens:null}}var T=M();function H(u){T=u;}var _={exec:()=>null};function k(u,e=""){let t=typeof u=="string"?u:u.source,n={replace:(r,i)=>{let s=typeof i=="string"?i:i.source;return s=s.replace(m.caret,"$1"),t=t.replace(r,s),n},getRegex:()=>new RegExp(t,e)};return n}var Re=(()=>{try{return !!new RegExp("(?<=1)(?<!1)")}catch{return  false}})(),m={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] +\S/,listReplaceTask:/^\[[ xX]\] +/,listTaskCheckbox:/\[[ xX]\]/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:u=>new RegExp(`^( {0,3}${u})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}#`),htmlBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}<(?:[a-z].*>|!--)`,"i"),blockquoteBeginRegex:u=>new RegExp(`^ {0,${Math.min(3,u-1)}}>`)},Te=/^(?:[ \t]*(?:\n|$))+/,Oe=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,we=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,I=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,ye=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,N=/ {0,3}(?:[*+-]|\d{1,9}[.)])/,re=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,se=k(re).replace(/bull/g,N).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),Pe=k(re).replace(/bull/g,N).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),Q=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,Se=/^[^\n]+/,F=/(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,$e=k(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",F).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),_e=k(/^(bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,N).getRegex(),q="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",j=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,Le=k("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",j).replace("tag",q).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),ie=k(Q).replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex(),Me=k(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",ie).getRegex(),U={blockquote:Me,code:Oe,def:$e,fences:we,heading:ye,hr:I,html:Le,lheading:se,list:_e,newline:Te,paragraph:ie,table:_,text:Se},te=k("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex(),ze={...U,lheading:Pe,table:te,paragraph:k(Q).replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",te).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex()},Ce={...U,html:k(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",j).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:_,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:k(Q).replace("hr",I).replace("heading",` *#{1,6} *[^
]`).replace("lheading",se).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},Ae=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,Ie=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,oe=/^( {2,}|\\)\n(?!\s*$)/,Ee=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,v=/[\p{P}\p{S}]/u,K=/[\s\p{P}\p{S}]/u,ae=/[^\s\p{P}\p{S}]/u,Be=k(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,K).getRegex(),le=/(?!~)[\p{P}\p{S}]/u,De=/(?!~)[\s\p{P}\p{S}]/u,qe=/(?:[^\s\p{P}\p{S}]|~)/u,ue=/(?![*_])[\p{P}\p{S}]/u,ve=/(?![*_])[\s\p{P}\p{S}]/u,Ge=/(?:[^\s\p{P}\p{S}]|[*_])/u,He=k(/link|precode-code|html/,"g").replace("link",/\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-",Re?"(?<!`)()":"(^^|[^`])").replace("code",/(?<b>`+)[^`]+\k<b>(?!`)/).replace("html",/<(?! )[^<>]*?>/).getRegex(),pe=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,Ze=k(pe,"u").replace(/punct/g,v).getRegex(),Ne=k(pe,"u").replace(/punct/g,le).getRegex(),ce="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",Qe=k(ce,"gu").replace(/notPunctSpace/g,ae).replace(/punctSpace/g,K).replace(/punct/g,v).getRegex(),Fe=k(ce,"gu").replace(/notPunctSpace/g,qe).replace(/punctSpace/g,De).replace(/punct/g,le).getRegex(),je=k("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ae).replace(/punctSpace/g,K).replace(/punct/g,v).getRegex(),Ue=k(/^~~?(?:((?!~)punct)|[^\s~])/,"u").replace(/punct/g,ue).getRegex(),Ke="^[^~]+(?=[^~])|(?!~)punct(~~?)(?=[\\s]|$)|notPunctSpace(~~?)(?!~)(?=punctSpace|$)|(?!~)punctSpace(~~?)(?=notPunctSpace)|[\\s](~~?)(?!~)(?=punct)|(?!~)punct(~~?)(?!~)(?=punct)|notPunctSpace(~~?)(?=notPunctSpace)",We=k(Ke,"gu").replace(/notPunctSpace/g,Ge).replace(/punctSpace/g,ve).replace(/punct/g,ue).getRegex(),Xe=k(/\\(punct)/,"gu").replace(/punct/g,v).getRegex(),Je=k(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Ve=k(j).replace("(?:-->|$)","-->").getRegex(),Ye=k("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",Ve).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),D=/(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/,et=k(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",D).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),he=k(/^!?\[(label)\]\[(ref)\]/).replace("label",D).replace("ref",F).getRegex(),ke=k(/^!?\[(ref)\](?:\[\])?/).replace("ref",F).getRegex(),tt=k("reflink|nolink(?!\\()","g").replace("reflink",he).replace("nolink",ke).getRegex(),ne=/[hH][tT][tT][pP][sS]?|[fF][tT][pP]/,W={_backpedal:_,anyPunctuation:Xe,autolink:Je,blockSkip:He,br:oe,code:Ie,del:_,delLDelim:_,delRDelim:_,emStrongLDelim:Ze,emStrongRDelimAst:Qe,emStrongRDelimUnd:je,escape:Ae,link:et,nolink:ke,punctuation:Be,reflink:he,reflinkSearch:tt,tag:Ye,text:Ee,url:_},nt={...W,link:k(/^!?\[(label)\]\((.*?)\)/).replace("label",D).getRegex(),reflink:k(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",D).getRegex()},Z={...W,emStrongRDelimAst:Fe,emStrongLDelim:Ne,delLDelim:Ue,delRDelim:We,url:k(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol",ne).replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,text:k(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol",ne).getRegex()},rt={...Z,br:k(oe).replace("{2,}","*").getRegex(),text:k(Z.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},E={normal:U,gfm:ze,pedantic:Ce},z={normal:W,gfm:Z,breaks:rt,pedantic:nt};var st={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},de=u=>st[u];function O(u,e){if(e){if(m.escapeTest.test(u))return u.replace(m.escapeReplace,de)}else if(m.escapeTestNoEncode.test(u))return u.replace(m.escapeReplaceNoEncode,de);return u}function X(u){try{u=encodeURI(u).replace(m.percentDecode,"%");}catch{return null}return u}function J(u,e){let t=u.replace(m.findPipe,(i,s,a)=>{let o=false,l=s;for(;--l>=0&&a[l]==="\\";)o=!o;return o?"|":" |"}),n=t.split(m.splitPipe),r=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(m.slashPipe,"|");return n}function C(u,e,t){let n=u.length;if(n===0)return "";let r=0;for(;r<n;){let i=u.charAt(n-r-1);if(i===e&&true)r++;else break}return u.slice(0,n-r)}function ge(u,e){if(u.indexOf(e[1])===-1)return  -1;let t=0;for(let n=0;n<u.length;n++)if(u[n]==="\\")n++;else if(u[n]===e[0])t++;else if(u[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function fe(u,e=0){let t=e,n="";for(let r of u)if(r==="	"){let i=4-t%4;n+=" ".repeat(i),t+=i;}else n+=r,t++;return n}function me(u,e,t,n,r){let i=e.href,s=e.title||null,a=u[1].replace(r.other.outputLinkReplace,"$1");n.state.inLink=true;let o={type:u[0].charAt(0)==="!"?"image":"link",raw:t,href:i,title:s,text:a,tokens:n.inlineTokens(a)};return n.state.inLink=false,o}function it(u,e,t){let n=u.match(t.other.indentCodeCompensation);if(n===null)return e;let r=n[1];return e.split(`
`).map(i=>{let s=i.match(t.other.beginningSpace);if(s===null)return i;let[a]=s;return a.length>=r.length?i.slice(r.length):i}).join(`
`)}var w=class{options;rules;lexer;constructor(e){this.options=e||T;}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return {type:"space",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,"");return {type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:C(n,`
`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],r=it(n,t[3]||"",this.rules);return {type:"code",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):t[2],text:r}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let r=C(n,"#");(this.options.pedantic||!r||this.rules.other.endingSpaceChar.test(r))&&(n=r.trim());}return {type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return {type:"hr",raw:C(t[0],`
`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=C(t[0],`
`).split(`
`),r="",i="",s=[];for(;n.length>0;){let a=false,o=[],l;for(l=0;l<n.length;l++)if(this.rules.other.blockquoteStart.test(n[l]))o.push(n[l]),a=true;else if(!a)o.push(n[l]);else break;n=n.slice(l);let p=o.join(`
`),c=p.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");r=r?`${r}
${p}`:p,i=i?`${i}
${c}`:c;let d=this.lexer.state.top;if(this.lexer.state.top=true,this.lexer.blockTokens(c,s,true),this.lexer.state.top=d,n.length===0)break;let h=s.at(-1);if(h?.type==="code")break;if(h?.type==="blockquote"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.blockquote(f);s[s.length-1]=S,r=r.substring(0,r.length-R.raw.length)+S.raw,i=i.substring(0,i.length-R.text.length)+S.text;break}else if(h?.type==="list"){let R=h,f=R.raw+`
`+n.join(`
`),S=this.list(f);s[s.length-1]=S,r=r.substring(0,r.length-h.raw.length)+S.raw,i=i.substring(0,i.length-R.raw.length)+S.raw,n=f.substring(s.at(-1).raw.length).split(`
`);continue}}return {type:"blockquote",raw:r,tokens:s,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),r=n.length>1,i={type:"list",raw:"",ordered:r,start:r?+n.slice(0,-1):"",loose:false,items:[]};n=r?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=r?n:"[*+-]");let s=this.rules.other.listItemRegex(n),a=false;for(;e;){let l=false,p="",c="";if(!(t=s.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let d=fe(t[2].split(`
`,1)[0],t[1].length),h=e.split(`
`,1)[0],R=!d.trim(),f=0;if(this.options.pedantic?(f=2,c=d.trimStart()):R?f=t[1].length+1:(f=d.search(this.rules.other.nonSpaceChar),f=f>4?1:f,c=d.slice(f),f+=t[1].length),R&&this.rules.other.blankLine.test(h)&&(p+=h+`
`,e=e.substring(h.length+1),l=true),!l){let S=this.rules.other.nextBulletRegex(f),V=this.rules.other.hrRegex(f),Y=this.rules.other.fencesBeginRegex(f),ee=this.rules.other.headingBeginRegex(f),xe=this.rules.other.htmlBeginRegex(f),be=this.rules.other.blockquoteBeginRegex(f);for(;e;){let G=e.split(`
`,1)[0],A;if(h=G,this.options.pedantic?(h=h.replace(this.rules.other.listReplaceNesting,"  "),A=h):A=h.replace(this.rules.other.tabCharGlobal,"    "),Y.test(h)||ee.test(h)||xe.test(h)||be.test(h)||S.test(h)||V.test(h))break;if(A.search(this.rules.other.nonSpaceChar)>=f||!h.trim())c+=`
`+A.slice(f);else {if(R||d.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||Y.test(d)||ee.test(d)||V.test(d))break;c+=`
`+h;}R=!h.trim(),p+=G+`
`,e=e.substring(G.length+1),d=A.slice(f);}}i.loose||(a?i.loose=true:this.rules.other.doubleBlankLine.test(p)&&(a=true)),i.items.push({type:"list_item",raw:p,task:!!this.options.gfm&&this.rules.other.listIsTask.test(c),loose:false,text:c,tokens:[]}),i.raw+=p;}let o=i.items.at(-1);if(o)o.raw=o.raw.trimEnd(),o.text=o.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let l of i.items){if(this.lexer.state.top=false,l.tokens=this.lexer.blockTokens(l.text,[]),l.task){if(l.text=l.text.replace(this.rules.other.listReplaceTask,""),l.tokens[0]?.type==="text"||l.tokens[0]?.type==="paragraph"){l.tokens[0].raw=l.tokens[0].raw.replace(this.rules.other.listReplaceTask,""),l.tokens[0].text=l.tokens[0].text.replace(this.rules.other.listReplaceTask,"");for(let c=this.lexer.inlineQueue.length-1;c>=0;c--)if(this.rules.other.listIsTask.test(this.lexer.inlineQueue[c].src)){this.lexer.inlineQueue[c].src=this.lexer.inlineQueue[c].src.replace(this.rules.other.listReplaceTask,"");break}}let p=this.rules.other.listTaskCheckbox.exec(l.raw);if(p){let c={type:"checkbox",raw:p[0]+" ",checked:p[0]!=="[ ]"};l.checked=c.checked,i.loose?l.tokens[0]&&["paragraph","text"].includes(l.tokens[0].type)&&"tokens"in l.tokens[0]&&l.tokens[0].tokens?(l.tokens[0].raw=c.raw+l.tokens[0].raw,l.tokens[0].text=c.raw+l.tokens[0].text,l.tokens[0].tokens.unshift(c)):l.tokens.unshift({type:"paragraph",raw:c.raw,text:c.raw,tokens:[c]}):l.tokens.unshift(c);}}if(!i.loose){let p=l.tokens.filter(d=>d.type==="space"),c=p.length>0&&p.some(d=>this.rules.other.anyLine.test(d.raw));i.loose=c;}}if(i.loose)for(let l of i.items){l.loose=true;for(let p of l.tokens)p.type==="text"&&(p.type="paragraph");}return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return {type:"html",block:true,raw:t[0],pre:t[1]==="pre"||t[1]==="script"||t[1]==="style",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),r=t[2]?t[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):t[3];return {type:"def",tag:n,raw:t[0],href:r,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=J(t[1]),r=t[2].replace(this.rules.other.tableAlignChars,"").split("|"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:t[0],header:[],align:[],rows:[]};if(n.length===r.length){for(let a of r)this.rules.other.tableAlignRight.test(a)?s.align.push("right"):this.rules.other.tableAlignCenter.test(a)?s.align.push("center"):this.rules.other.tableAlignLeft.test(a)?s.align.push("left"):s.align.push(null);for(let a=0;a<n.length;a++)s.header.push({text:n[a],tokens:this.lexer.inline(n[a]),header:true,align:s.align[a]});for(let a of i)s.rows.push(J(a,s.header.length).map((o,l)=>({text:o,tokens:this.lexer.inline(o),header:false,align:s.align[l]})));return s}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return {type:"heading",raw:t[0],depth:t[2].charAt(0)==="="?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`
`?t[1].slice(0,-1):t[1];return {type:"paragraph",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return {type:"text",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return {type:"escape",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return !this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=true:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=false),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=true:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=false),{type:"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:false,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let s=C(n.slice(0,-1),"\\");if((n.length-s.length)%2===0)return}else {let s=ge(t[2],"()");if(s===-2)return;if(s>-1){let o=(t[0].indexOf("!")===0?5:4)+t[1].length+s;t[2]=t[2].substring(0,s),t[0]=t[0].substring(0,o).trim(),t[3]="";}}let r=t[2],i="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(r);s&&(r=s[1],i=s[3]);}else i=t[3]?t[3].slice(1,-1):"";return r=r.trim(),this.rules.other.startAngleBracket.test(r)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?r=r.slice(1):r=r.slice(1,-1)),me(t,{href:r&&r.replace(this.rules.inline.anyPunctuation,"$1"),title:i&&i.replace(this.rules.inline.anyPunctuation,"$1")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let r=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),i=t[r.toLowerCase()];if(!i){let s=n[0].charAt(0);return {type:"text",raw:s,text:s}}return me(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=""){let r=this.rules.inline.emStrongLDelim.exec(e);if(!r||r[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(r[1]||r[2]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=0,c=r[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+s);(r=c.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a)continue;if(o=[...a].length,r[3]||r[4]){l+=o;continue}else if((r[5]||r[6])&&s%3&&!((s+o)%3)){p+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l+p);let d=[...r[0]][0].length,h=e.slice(0,s+r.index+d+o);if(Math.min(s,o)%2){let f=h.slice(1,-1);return {type:"em",raw:h,text:f,tokens:this.lexer.inlineTokens(f)}}let R=h.slice(2,-2);return {type:"strong",raw:h,text:R,tokens:this.lexer.inlineTokens(R)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal," "),r=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return r&&i&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return {type:"br",raw:t[0]}}del(e,t,n=""){let r=this.rules.inline.delLDelim.exec(e);if(!r)return;if(!(r[1]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,a,o,l=s,p=this.rules.inline.delRDelim;for(p.lastIndex=0,t=t.slice(-1*e.length+s);(r=p.exec(t))!=null;){if(a=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!a||(o=[...a].length,o!==s))continue;if(r[3]||r[4]){l+=o;continue}if(l-=o,l>0)continue;o=Math.min(o,o+l);let c=[...r[0]][0].length,d=e.slice(0,s+r.index+c+o),h=d.slice(s,-s);return {type:"del",raw:d,text:h,tokens:this.lexer.inlineTokens(h)}}}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,r;return t[2]==="@"?(n=t[1],r="mailto:"+n):(n=t[1],r=n),{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,r;if(t[2]==="@")n=t[0],r="mailto:"+n;else {let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??"";while(i!==t[0]);n=t[0],t[1]==="www."?r="http://"+t[0]:r=t[0];}return {type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return {type:"text",raw:t[0],text:t[0],escaped:n}}}};var x=class u{tokens;options;state;inlineQueue;tokenizer;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||T,this.options.tokenizer=this.options.tokenizer||new w,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:false,inRawBlock:false,top:true};let t={other:m,block:E.normal,inline:z.normal};this.options.pedantic?(t.block=E.pedantic,t.inline=z.pedantic):this.options.gfm&&(t.block=E.gfm,this.options.breaks?t.inline=z.breaks:t.inline=z.gfm),this.tokenizer.rules=t;}static get rules(){return {block:E,inline:z}}static lex(e,t){return new u(t).lex(e)}static lexInline(e,t){return new u(t).inlineTokens(e)}lex(e){e=e.replace(m.carriageReturn,`
`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens);}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=false){for(this.options.pedantic&&(e=e.replace(m.tabCharGlobal,"    ").replace(m.spaceLine,""));e;){let r;if(this.options.extensions?.block?.some(s=>(r=s.call({lexer:this},e,t))?(e=e.substring(r.raw.length),t.push(r),true):false))continue;if(r=this.tokenizer.space(e)){e=e.substring(r.raw.length);let s=t.at(-1);r.raw.length===1&&s!==void 0?s.raw+=`
`:t.push(r);continue}if(r=this.tokenizer.code(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(r=this.tokenizer.fences(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.heading(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.hr(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.blockquote(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.list(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.html(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.def(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.raw,this.inlineQueue.at(-1).src=s.text):this.tokens.links[r.tag]||(this.tokens.links[r.tag]={href:r.href,title:r.title},t.push(r));continue}if(r=this.tokenizer.table(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.lheading(e)){e=e.substring(r.raw.length),t.push(r);continue}let i=e;if(this.options.extensions?.startBlock){let s=1/0,a=e.slice(1),o;this.options.extensions.startBlock.forEach(l=>{o=l.call({lexer:this},a),typeof o=="number"&&o>=0&&(s=Math.min(s,o));}),s<1/0&&s>=0&&(i=e.substring(0,s+1));}if(this.state.top&&(r=this.tokenizer.paragraph(i))){let s=t.at(-1);n&&s?.type==="paragraph"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r),n=i.length!==e.length,e=e.substring(r.raw.length);continue}if(r=this.tokenizer.text(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(e){let s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=true,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,r=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,r.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let i;for(;(r=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)i=r[2]?r[2].length:0,n=n.slice(0,r.index+i)+"["+"a".repeat(r[0].length-i-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);n=this.options.hooks?.emStrongMask?.call({lexer:this},n)??n;let s=false,a="";for(;e;){s||(a=""),s=false;let o;if(this.options.extensions?.inline?.some(p=>(o=p.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),true):false))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let p=t.at(-1);o.type==="text"&&p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e,n,a)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let l=e;if(this.options.extensions?.startInline){let p=1/0,c=e.slice(1),d;this.options.extensions.startInline.forEach(h=>{d=h.call({lexer:this},c),typeof d=="number"&&d>=0&&(p=Math.min(p,d));}),p<1/0&&p>=0&&(l=e.substring(0,p+1));}if(o=this.tokenizer.inlineText(l)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(a=o.raw.slice(-1)),s=true;let p=t.at(-1);p?.type==="text"?(p.raw+=o.raw,p.text+=o.text):t.push(o);continue}if(e){let p="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(p);break}else throw new Error(p)}}return t}};var y=class{options;parser;constructor(e){this.options=e||T;}space(e){return ""}code({text:e,lang:t,escaped:n}){let r=(t||"").match(m.notSpaceStart)?.[0],i=e.replace(m.endingNewline,"")+`
`;return r?'<pre><code class="language-'+O(r)+'">'+(n?i:O(i,true))+`</code></pre>
`:"<pre><code>"+(n?i:O(i,true))+`</code></pre>
`}blockquote({tokens:e}){return `<blockquote>
${this.parser.parse(e)}</blockquote>
`}html({text:e}){return e}def(e){return ""}heading({tokens:e,depth:t}){return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`}hr(e){return `<hr>
`}list(e){let t=e.ordered,n=e.start,r="";for(let a=0;a<e.items.length;a++){let o=e.items[a];r+=this.listitem(o);}let i=t?"ol":"ul",s=t&&n!==1?' start="'+n+'"':"";return "<"+i+s+`>
`+r+"</"+i+`>
`}listitem(e){return `<li>${this.parser.parse(e.tokens)}</li>
`}checkbox({checked:e}){return "<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"> '}paragraph({tokens:e}){return `<p>${this.parser.parseInline(e)}</p>
`}table(e){let t="",n="";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let r="";for(let i=0;i<e.rows.length;i++){let s=e.rows[i];n="";for(let a=0;a<s.length;a++)n+=this.tablecell(s[a]);r+=this.tablerow({text:n});}return r&&(r=`<tbody>${r}</tbody>`),`<table>
<thead>
`+t+`</thead>
`+r+`</table>
`}tablerow({text:e}){return `<tr>
${e}</tr>
`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?"th":"td";return (e.align?`<${n} align="${e.align}">`:`<${n}>`)+t+`</${n}>
`}strong({tokens:e}){return `<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return `<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return `<code>${O(e,true)}</code>`}br(e){return "<br>"}del({tokens:e}){return `<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let r=this.parser.parseInline(n),i=X(e);if(i===null)return r;e=i;let s='<a href="'+e+'"';return t&&(s+=' title="'+O(t)+'"'),s+=">"+r+"</a>",s}image({href:e,title:t,text:n,tokens:r}){r&&(n=this.parser.parseInline(r,this.parser.textRenderer));let i=X(e);if(i===null)return O(n);e=i;let s=`<img src="${e}" alt="${n}"`;return t&&(s+=` title="${O(t)}"`),s+=">",s}text(e){return "tokens"in e&&e.tokens?this.parser.parseInline(e.tokens):"escaped"in e&&e.escaped?e.text:O(e.text)}};var $=class{strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return ""+e}image({text:e}){return ""+e}br(){return ""}checkbox({raw:e}){return e}};var b=class u{options;renderer;textRenderer;constructor(e){this.options=e||T,this.options.renderer=this.options.renderer||new y,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new $;}static parse(e,t){return new u(t).parse(e)}static parseInline(e,t){return new u(t).parseInline(e)}parse(e){let t="";for(let n=0;n<e.length;n++){let r=e[n];if(this.options.extensions?.renderers?.[r.type]){let s=r,a=this.options.extensions.renderers[s.type].call({parser:this},s);if(a!==false||!["space","hr","heading","code","table","blockquote","list","html","def","paragraph","text"].includes(s.type)){t+=a||"";continue}}let i=r;switch(i.type){case "space":{t+=this.renderer.space(i);break}case "hr":{t+=this.renderer.hr(i);break}case "heading":{t+=this.renderer.heading(i);break}case "code":{t+=this.renderer.code(i);break}case "table":{t+=this.renderer.table(i);break}case "blockquote":{t+=this.renderer.blockquote(i);break}case "list":{t+=this.renderer.list(i);break}case "checkbox":{t+=this.renderer.checkbox(i);break}case "html":{t+=this.renderer.html(i);break}case "def":{t+=this.renderer.def(i);break}case "paragraph":{t+=this.renderer.paragraph(i);break}case "text":{t+=this.renderer.text(i);break}default:{let s='Token with "'+i.type+'" type was not found.';if(this.options.silent)return console.error(s),"";throw new Error(s)}}}return t}parseInline(e,t=this.renderer){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let a=this.options.extensions.renderers[i.type].call({parser:this},i);if(a!==false||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){n+=a||"";continue}}let s=i;switch(s.type){case "escape":{n+=t.text(s);break}case "html":{n+=t.html(s);break}case "link":{n+=t.link(s);break}case "image":{n+=t.image(s);break}case "checkbox":{n+=t.checkbox(s);break}case "strong":{n+=t.strong(s);break}case "em":{n+=t.em(s);break}case "codespan":{n+=t.codespan(s);break}case "br":{n+=t.br(s);break}case "del":{n+=t.del(s);break}case "text":{n+=t.text(s);break}default:{let a='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(a),"";throw new Error(a)}}}return n}};var P=class{options;block;constructor(e){this.options=e||T;}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens","emStrongMask"]);static passThroughHooksRespectAsync=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}emStrongMask(e){return e}provideLexer(){return this.block?x.lex:x.lexInline}provideParser(){return this.block?b.parse:b.parseInline}};var B=class{defaults=M();options=this.setOptions;parse=this.parseMarkdown(true);parseInline=this.parseMarkdown(false);Parser=b;Renderer=y;TextRenderer=$;Lexer=x;Tokenizer=w;Hooks=P;constructor(...e){this.use(...e);}walkTokens(e,t){let n=[];for(let r of e)switch(n=n.concat(t.call(this,r)),r.type){case "table":{let i=r;for(let s of i.header)n=n.concat(this.walkTokens(s.tokens,t));for(let s of i.rows)for(let a of s)n=n.concat(this.walkTokens(a.tokens,t));break}case "list":{let i=r;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=r;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(s=>{let a=i[s].flat(1/0);n=n.concat(this.walkTokens(a,t));}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)));}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let r={...n};if(r.async=this.defaults.async||r.async||false,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error("extension name required");if("renderer"in i){let s=t.renderers[i.name];s?t.renderers[i.name]=function(...a){let o=i.renderer.apply(this,a);return o===false&&(o=s.apply(this,a)),o}:t.renderers[i.name]=i.renderer;}if("tokenizer"in i){if(!i.level||i.level!=="block"&&i.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=t[i.level];s?s.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level==="block"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level==="inline"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]));}"childTokens"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens);}),r.extensions=t),n.renderer){let i=this.defaults.renderer||new y(this.defaults);for(let s in n.renderer){if(!(s in i))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let a=s,o=n.renderer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c||""};}r.renderer=i;}if(n.tokenizer){let i=this.defaults.tokenizer||new w(this.defaults);for(let s in n.tokenizer){if(!(s in i))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let a=s,o=n.tokenizer[a],l=i[a];i[a]=(...p)=>{let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.tokenizer=i;}if(n.hooks){let i=this.defaults.hooks||new P;for(let s in n.hooks){if(!(s in i))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let a=s,o=n.hooks[a],l=i[a];P.passThroughHooks.has(s)?i[a]=p=>{if(this.defaults.async&&P.passThroughHooksRespectAsync.has(s))return (async()=>{let d=await o.call(i,p);return l.call(i,d)})();let c=o.call(i,p);return l.call(i,c)}:i[a]=(...p)=>{if(this.defaults.async)return (async()=>{let d=await o.apply(i,p);return d===false&&(d=await l.apply(i,p)),d})();let c=o.apply(i,p);return c===false&&(c=l.apply(i,p)),c};}r.hooks=i;}if(n.walkTokens){let i=this.defaults.walkTokens,s=n.walkTokens;r.walkTokens=function(a){let o=[];return o.push(s.call(this,a)),i&&(o=o.concat(i.call(this,a))),o};}this.defaults={...this.defaults,...r};}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return x.lex(e,t??this.defaults)}parser(e,t){return b.parse(e,t??this.defaults)}parseMarkdown(e){return (n,r)=>{let i={...r},s={...this.defaults,...i},a=this.onError(!!s.silent,!!s.async);if(this.defaults.async===true&&i.async===false)return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return a(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return a(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(s.hooks&&(s.hooks.options=s,s.hooks.block=e),s.async)return (async()=>{let o=s.hooks?await s.hooks.preprocess(n):n,p=await(s.hooks?await s.hooks.provideLexer():e?x.lex:x.lexInline)(o,s),c=s.hooks?await s.hooks.processAllTokens(p):p;s.walkTokens&&await Promise.all(this.walkTokens(c,s.walkTokens));let h=await(s.hooks?await s.hooks.provideParser():e?b.parse:b.parseInline)(c,s);return s.hooks?await s.hooks.postprocess(h):h})().catch(a);try{s.hooks&&(n=s.hooks.preprocess(n));let l=(s.hooks?s.hooks.provideLexer():e?x.lex:x.lexInline)(n,s);s.hooks&&(l=s.hooks.processAllTokens(l)),s.walkTokens&&this.walkTokens(l,s.walkTokens);let c=(s.hooks?s.hooks.provideParser():e?b.parse:b.parseInline)(l,s);return s.hooks&&(c=s.hooks.postprocess(c)),c}catch(o){return a(o)}}}onError(e,t){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,e){let r="<p>An error occurred:</p><pre>"+O(n.message+"",true)+"</pre>";return t?Promise.resolve(r):r}if(t)return Promise.reject(n);throw n}}};var L=new B;function g(u,e){return L.parse(u,e)}g.options=g.setOptions=function(u){return L.setOptions(u),g.defaults=L.defaults,H(g.defaults),g};g.getDefaults=M;g.defaults=T;g.use=function(...u){return L.use(...u),g.defaults=L.defaults,H(g.defaults),g};g.walkTokens=function(u,e){return L.walkTokens(u,e)};g.parseInline=L.parseInline;g.Parser=b;g.parser=b.parse;g.Renderer=y;g.TextRenderer=$;g.Lexer=x;g.lexer=x.lex;g.Tokenizer=w;g.Hooks=P;g.parse=g;g.options;g.setOptions;g.use;g.walkTokens;g.parseInline;b.parse;x.lex;

/**
 * Renders a Kanban board with the given properties
 * @param options - Properties for the Kanban board
 * @returns HTML representation of the Kanban board
 */
function renderKanban(options) {
    const { kanbanId, className, viewMode, showTaskCount, template, columns, parser } = options;
    // Get the Kanban template
    const kanbanTemplate = template || DEFAULT_TEMPLATE$3;
    // Generate view switcher HTML
    const viewSwitcher = generateViewSwitcher(kanbanId, viewMode, className);
    // Generate all three view modes
    const boardView = renderColumnView(columns, className, showTaskCount, parser);
    const tableView = renderTableView(columns, className, parser);
    const listView = renderColumnView(columns, className, showTaskCount, parser);
    // Select the initial view
    let columnsHtml = '';
    switch (viewMode) {
        case 'board':
            columnsHtml = boardView;
            break;
        case 'table':
            columnsHtml = tableView;
            break;
        case 'list':
            columnsHtml = listView;
            break;
    }
    // Add a script to store all views (safely serialized) as a data block
    // This avoids issues with script execution restrictions (CSP, innerHTML)
    const viewsScript = `
    <script type="application/json" id="${kanbanId}-views">
      ${JSON.stringify({
        board: boardView,
        table: tableView,
        list: listView,
    }).replace(/<\/script>/g, '<\\/script>')}
    </script>
  `;
    // Return the template with all placeholders replaced
    return kanbanTemplate
        .replace(/{kanbanId}/g, kanbanId)
        .replace(/{className}/g, className)
        .replace(/{viewMode}/g, viewMode)
        .replace(/{columnsHtml}/g, columnsHtml)
        .replace(/{viewSwitcher}/g, viewSwitcher) + viewsScript;
}
/**
 * Generate view switcher buttons
 */
function generateViewSwitcher(kanbanId, currentView, className) {
    const views = ['board', 'table', 'list'];
    return views
        .map((view) => {
        const isActive = view === currentView;
        const buttonClass = `${className}-view-button${isActive ? ' active' : ''}`;
        const viewCapitalized = view.charAt(0).toUpperCase() + view.slice(1);
        // Inline script to switch views without external dependencies
        // checks for kb.__views and lazily loads from a data script if needed
        const onclick = `(function(el){try{var kb=document.getElementById('${kanbanId}');if(!kb)return;kb.setAttribute('data-view-mode','${view}');if(!kb.__views){var d=document.getElementById('${kanbanId}-views');if(d){try{kb.__views=JSON.parse(d.textContent)}catch(e){console.error('Parse error',e)}}}var cont=kb.querySelector('.${className}-container');if(cont&&kb.__views&&kb.__views['${view}']){cont.innerHTML=kb.__views['${view}'];}kb.querySelectorAll('.${className}-view-button').forEach(function(btn){btn.classList.remove('active')});el.classList.add('active');}catch(e){console.error('View switch error:',e);}})(this)`;
        return `<button class="${buttonClass}" onclick="${onclick}" type="button">${viewCapitalized}</button>`;
    })
        .join('\n    ');
}
/**
 * Parse tasks from column tokens
 */
function parseTasks(tokens, parser) {
    const tasks = [];
    for (const token of tokens) {
        // Task from list items
        if (token.type === 'list' && !token.ordered) {
            for (const item of token.items) {
                // Handle single-token text which might contain multiple lines (title + desc/tags)
                // This happens with 'loose: false' lists where compact items are single tokens
                if (item.tokens.length === 1 && (item.tokens[0].type === 'paragraph' || item.tokens[0].type === 'text')) {
                    const firstToken = item.tokens[0];
                    // Use the 'text' property if available as it usually has the raw content
                    const rawText = (firstToken).text || firstToken.raw || '';
                    const parts = rawText.split(/\r?\n/);
                    if (parts.length > 1) {
                        // Re-lex each line as individual tokens
                        const newTokens = [];
                        for (const part of parts) {
                            if (!part.trim())
                                continue;
                            // Use marked lexer to tokenize the line
                            const lineTokens = g.lexer(part);
                            newTokens.push(...lineTokens);
                        }
                        if (newTokens.length > 0) {
                            item.tokens = newTokens;
                        }
                    }
                }
                // Get the first text token as a title
                let title = '';
                let description = '';
                const tags = [];
                if (item.tokens && item.tokens.length > 0) {
                    // The first paragraph is the title (preserve HTML formatting for nested Markdown)
                    if (item.tokens[0].type === 'paragraph' || item.tokens[0].type === 'text') {
                        const firstTokens = item.tokens[0].tokens || [item.tokens[0]];
                        title = parser.parseInline(firstTokens);
                    }
                    // Look for additional paragraphs as description and extract tags
                    for (let i = 1; i < item.tokens.length; i++) {
                        const t = item.tokens[i];
                        // Check if this is a paragraph containing ONLY tags (starts with #)
                        // If so, extract tags and don't render it as content
                        if (t.type === 'paragraph' || t.type === 'text') {
                            const text = t.raw || t.text || '';
                            if (text.trim().match(/^#\w+/)) {
                                const foundTags = text.match(/#\w+/g) || [];
                                tags.push(...foundTags.map((tag) => tag.substring(1)));
                                continue;
                            }
                        }
                        // For all other content (or paragraphs that aren't just tags),
                        // render using the parser to support nested extensions (accordion, etc.)
                        description += parser.parse([t]);
                    }
                }
                if (title) {
                    const task = { title };
                    if (description)
                        task.description = description;
                    if (tags.length > 0)
                        task.tags = tags;
                    tasks.push(task);
                }
            }
        }
    }
    return tasks;
}
/**
 * Render task HTML with support for nested Markdown
 */
function renderTask(task, color, className) {
    const tagsHtml = task.tags && task.tags.length > 0
        ? `<div class="${className}-task-tags">
        ${task.tags.map(tag => `<span class="${className}-task-tag">${tag}</span>`).join('')}
       </div>`
        : '';
    const descriptionHtml = task.description
        ? `<div class="${className}-task-description">${task.description}</div>`
        : '';
    return `
    <div class="${className}-task" style="border-left-color: ${color};">
      <div class="${className}-task-title">${task.title}</div>
      ${descriptionHtml}
      ${tagsHtml}
    </div>
  `;
}
/**
 * Render a column-based view (board or list)
 */
function renderColumnView(columns, className, showTaskCount, parser) {
    return columns
        .map((column) => {
        const tasks = parseTasks(column.tokens || [], parser);
        const taskCount = showTaskCount
            ? `<span class="${className}-column-count">${tasks.length}</span>`
            : '';
        const tasksHtml = tasks.map((task) => renderTask(task, column.props.color || '#6c757d', className)).join('');
        return `
        <div class="${className}-column">
          <div class="${className}-column-header" style="--kanban-color: ${column.props.color || '#6c757d'};">
            <h3 class="${className}-column-title">${column.props.label}</h3>
            ${taskCount}
          </div>
          <div class="${className}-column-tasks">
            ${tasksHtml}
          </div>
        </div>
      `;
    })
        .join('');
}
/**
 * Render table view
 */
function renderTableView(columns, className, parser) {
    const allTasks = [];
    columns.forEach((column) => {
        const tasks = parseTasks(column.tokens || [], parser);
        tasks.forEach((task) => {
            allTasks.push({ column, task });
        });
    });
    const rows = allTasks
        .map(({ column, task }) => `
      <tr>
        <td>
          <span class="${className}-column-label" style="background-color: ${column.props.color || '#6c757d'};">
            ${column.props.label}
          </span>
        </td>
        <td>${task.title}</td>
        <td>${task.description || '-'}</td>
        <td>${task.tags ? task.tags.map(tag => `<span class="${className}-task-tag">${tag}</span>`).join(' ') : '-'}</td>
      </tr>
    `)
        .join('');
    return `
    <table class="${className}-table">
      <thead>
        <tr>
          <th>Status</th>
          <th>Task</th>
          <th>Description</th>
          <th>Tags</th>
        </tr>
      </thead>
      <tbody>
        ${rows}
      </tbody>
    </table>
  `;
}

/**
 * Create a Kanban board tokenizer for the Markdown parser.
 * @param options - Configuration options
 * @returns Marked extension object
 */
function createTokenizer$5(options) {
    const { className, defaultView, showTaskCount, template } = options;
    return {
        name: 'kanban',
        level: 'block',
        tokenizer(src) {
            // Check for the Kanban block pattern
            const blockMatch = validateRegex$3('kanbanBlock', src);
            if (!blockMatch)
                return undefined;
            const [raw, propString, content] = blockMatch;
            // Parse properties from the propString
            const props = constructProps$3('kanbanBlock', propString);
            // Extract columns from content
            const columns = [];
            // Check if kanbanColumnRegex is available
            if (!kanbanColumnRegex) {
                return undefined;
            }
            kanbanColumnRegex.lastIndex = 0;
            let columnMatch;
            while ((columnMatch = kanbanColumnRegex.exec(content)) !== null) {
                const [columnRaw, columnPropString, columnContent] = columnMatch;
                const columnProps = constructProps$3('kanbanColumnBlock', columnPropString);
                // Tokenize the column content
                const tokens = this.lexer.blockTokens(columnContent.trim());
                columns.push({
                    type: 'kanban-column',
                    raw: columnRaw,
                    id: `column-${Math.random().toString(36).substring(2, 11)}`,
                    props: {
                        label: columnProps['label'] || 'Untitled',
                        color: columnProps['color'] || '#6c757d',
                    },
                    tasks: [],
                    tokens,
                });
            }
            // Generate a unique ID for the Kanban board
            const kanbanId = `kanban-${Math.random().toString(36).substring(2, 11)}`;
            // Return a token with all properties
            return {
                type: 'kanban',
                raw,
                tokens: columns,
                meta: {
                    kanbanId,
                    className,
                    viewMode: props['view'] || defaultView,
                    showTaskCount,
                    template,
                },
            };
        },
    };
}
/**
 * Create the renderer extension for Kanban
 * @returns Renderer extension object
 */
function createRenderer$5() {
    return {
        name: 'kanban',
        renderer(token) {
            const kanbanToken = token;
            // 'this' context is provided by marked.js and contains the parser instance
            return renderKanban({
                ...kanbanToken.meta,
                columns: kanbanToken.tokens,
                parser: this.parser,
            });
        },
    };
}

/**
 * Marked Extended Kanban extension
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedKanban(options = {}) {
    // Validate view mode option
    if (options.defaultView && !['board', 'table', 'list'].includes(options.defaultView)) {
        console.warn(`[marked-extended-kanban] Invalid defaultView value: ${options.defaultView}. Using default 'board'.`);
        options.defaultView = 'board';
    }
    // Set sensible defaults
    const config = { ...DEFAULT_OPTIONS$7, ...options };
    // Inject styles if needed
    if (config.injectStyles)
        ensureStyles$4('marked-extended-kanban-styles', DEFAULT_STYLES$4);
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type !== 'kanban')
                return;
            // Apply custom token modifications if configured
            if (config.customizeToken && typeof config.customizeToken === 'function') {
                config.customizeToken(token);
            }
        },
        extensions: [createTokenizer$5(config), createRenderer$5()],
    };
}

/**
 * Converts a letter to its corresponding integer value
 * @param letter - The letter to convert (e.g., 'a', 'b', 'c')
 * @returns The integer value (e.g., 'a' -> 1, 'z' -> 26)
 */
function letterToInt(letter) {
    return letter.toLowerCase().charCodeAt(0) - 96;
}
/**
 * Converts a Roman numeral to its integer value
 * @param roman - The Roman numeral to convert
 * @returns The integer value
 */
function romanToInt(roman) {
    const romanMap = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    };
    roman = roman.toUpperCase();
    let total = 0;
    for (let i = 0; i < roman.length; i++) {
        const current = romanMap[roman[i]];
        const next = romanMap[roman[i + 1]];
        total += next && current < next ? -current : current;
    }
    return total;
}
// Regular expression patterns for list detection
const romanUpper = '(?:C|XC|L?X{0,3}(?:IX|IV|V?I{0,3}))';
const romanLower = '(?:c|xc|l?x{0,3}(?:ix|iv|v?i{0,3}))';
// Fixed regex pattern - carefully balanced parentheses
const bulletPattern = `(?:[*+-]|(?:\\d{1,9}|[a-zA-Z]|${romanUpper}|${romanLower})[.)])`;
const rule = `^( {0,3}${bulletPattern})([ \\t][^\\n]+?)?(?:\\n|$)`;

/**
 * Creates a tokenizer function for parsing lists in Markdown
 * @returns The list tokenizing function
 */
function createTokenizer$4() {
    return function tokenizeList(src) {
        let cap = new RegExp(rule).exec(src);
        if (!cap)
            return undefined;
        const bullet = cap[1].trim();
        const isOrdered = bullet !== '*' && bullet !== '-' && bullet !== '+';
        let bull;
        let type = '';
        let expectedValue = 1;
        let startValue = 1;
        // Detect list type (Roman, alphabetic, numeric) and extract start value
        if (isOrdered) {
            if (bullet.match(new RegExp(`^${romanUpper}[.)]$`))) {
                type = 'I';
                bull = `${romanUpper}\\${bullet.slice(-1)}`;
                startValue = romanToInt(bullet.slice(0, -1));
            }
            else if (bullet.match(new RegExp(`^${romanLower}[.)]$`))) {
                type = 'i';
                bull = `${romanLower}\\${bullet.slice(-1)}`;
                startValue = romanToInt(bullet.slice(0, -1));
            }
            else if (bullet.match(/^[a-z][.)]$/)) {
                type = 'a';
                bull = `[a-z]\\${bullet.slice(-1)}`;
                startValue = letterToInt(bullet.slice(0, -1));
            }
            else if (bullet.match(/^[A-Z][.)]$/)) {
                type = 'A';
                bull = `[A-Z]\\${bullet.slice(-1)}`;
                startValue = letterToInt(bullet.slice(0, -1));
            }
            else {
                type = '1';
                bull = `\\d{1,9}\\${bullet.slice(-1)}`;
                startValue = parseInt(bullet.slice(0, -1), 10);
            }
            expectedValue = startValue;
        }
        else {
            bull = this.options?.pedantic ? bullet : '[*+-]';
        }
        const list = {
            type: 'list',
            raw: '',
            ordered: isOrdered,
            listType: type,
            loose: false,
            start: isOrdered ? startValue : undefined,
            items: [],
        };
        // Get next list item
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
        let endsWithBlankLine = false;
        // Check if current bullet point can start a new List Item
        while (src) {
            let itemContents = '';
            let endEarly = false;
            if (!(cap = itemRegex.exec(src)))
                break;
            let raw = cap[0];
            const bullet = cap[1].trim();
            src = src.substring(raw.length);
            const line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
            const nextLine = src.split('\n', 1)[0];
            const blankLine = !line.trim();
            let indent;
            if (this.options?.pedantic) {
                indent = 2;
                itemContents = line.trimStart();
            }
            else if (blankLine) {
                indent = cap[1].length + 1;
            }
            else {
                const firstNonSpacePos = cap[2].search(/[^ ]/); // Find first non-space char
                const indentSpaces = firstNonSpacePos > 4 ? 1 : firstNonSpacePos; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                itemContents = line.slice(indentSpaces);
                indent = indentSpaces + cap[1].length;
            }
            if (blankLine && /^[ \t]*$/.test(nextLine)) {
                // Items begin with at most one blank line
                raw += nextLine + '\n';
                src = src.substring(nextLine.length + 1);
                endEarly = true;
            }
            if (!endEarly) {
                const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|(?:\\d{1,9}|[a-zA-Z]|${romanUpper}|${romanLower})[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
                const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
                const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
                const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<[a-z].*>`, 'i');
                // Check if following lines should be included in List Item
                while (src) {
                    const rawLine = src.split('\n', 1)[0];
                    const nextLineWithoutTabs = rawLine.replace(/\t/g, '    ');
                    if (fencesBeginRegex.test(nextLineWithoutTabs)
                        || headingBeginRegex.test(nextLineWithoutTabs)
                        || htmlBeginRegex.test(nextLineWithoutTabs)
                        || nextBulletRegex.test(nextLineWithoutTabs)
                        || hrRegex.test(nextLineWithoutTabs))
                        break;
                    if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLineWithoutTabs.trim()) {
                        itemContents += '\n' + nextLineWithoutTabs.slice(indent);
                    }
                    else {
                        itemContents += '\n' + nextLineWithoutTabs;
                    }
                    raw += rawLine + '\n';
                    src = src.substring(rawLine.length + 1);
                }
            }
            if (!list.loose) {
                // If the previous item ended with a blank line, the list is loose
                if (endsWithBlankLine) {
                    list.loose = true;
                }
                else if (/\n[ \t]*\n[ \t]*$/.test(raw)) {
                    endsWithBlankLine = true;
                }
            }
            let isTask = null;
            let isChecked = false;
            // Check for task list items
            if (this.options?.gfm) {
                isTask = /^\[[ xX]] /.exec(itemContents);
                if (isTask) {
                    isChecked = isTask[0] !== '[ ] ';
                    itemContents = itemContents.replace(/^\[[ xX]] +/, '');
                }
            }
            let value = null;
            if (!isOrdered) ;
            else if (type === '1') {
                value = parseInt(bullet.slice(0, -1), 10);
            }
            else if (type === 'a' || type === 'A') {
                value = letterToInt(bullet.slice(0, -1));
            }
            else if (type === 'i' || type === 'I') {
                value = romanToInt(bullet.slice(0, -1));
            }
            list.items.push({
                type: 'list_item',
                raw,
                task: !!isTask,
                checked: isChecked,
                loose: false,
                text: itemContents,
                value,
                skipped: isOrdered && value !== expectedValue,
                tokens: [],
            });
            expectedValue = value !== null ? value + 1 : expectedValue;
            list.raw += raw;
        }
        if (list.items.length === 0)
            return undefined;
        // Finalize the list
        finalizeList(list, this.lexer);
        return list;
    };
}
/**
 * Finalizes a list by processing tokens and marking items as loose if needed
 * @param list - The list token to finalize
 * @param lexer - The marked lexer instance
 */
function finalizeList(list, lexer) {
    if (list.items.length === 0)
        return;
    // Trim trailing newline from last item
    const lastItem = list.items[list.items.length - 1];
    lastItem.raw = lastItem.raw.trimEnd();
    lastItem.text = lastItem.text.trimEnd();
    list.raw = list.raw.trimEnd();
    // Handle child tokens
    for (const item of list.items) {
        lexer.state.top = false;
        item.tokens = lexer.blockTokens(item.text, []);
        // Check if item contains nested lists for better loose detection
        const hasNestedBlock = item.tokens.some((token) => token.type === 'list'
            || token.type === 'blockquote'
            || token.type === 'code'
            || token.type === 'table');
        // If item has nested block elements, mark it as loose for proper spacing
        if (hasNestedBlock && list.loose) {
            item.loose = true;
        }
    }
    // Mark list as loose if needed
    if (list.loose) {
        for (const item of list.items) {
            item.loose = true;
        }
    }
}

/**
 * Creates renderer functions for lists and list items
 * @param options - Configuration options
 * @returns The list and listitem renderer functions
 */
function createRenderer$4(options) {
    return {
        /**
         * Renderer for list tokens with enhanced support for start attribute and list types
         * @param token - The list token to render
         * @returns HTML for the list
         */
        list(token) {
            const ordered = token.ordered;
            const extToken = token;
            const listType = extToken.listType || '1';
            let body = '';
            // Render list items
            for (const item of token.items) {
                body += this.listitem(item);
            }
            const type = ordered ? 'ol' : 'ul';
            const attributes = [];
            // Add type attribute for non-numeric ordered lists
            if (ordered && listType !== '1') {
                attributes.push(`type="${listType}"`);
            }
            // Add the start attribute if a list doesn't start at 1/a/i/A/me
            if (ordered && options.useStartAttribute && extToken.start && extToken.start > 1) {
                attributes.push(`start="${extToken.start}"`);
            }
            const attrStr = attributes.length > 0 ? ' ' + attributes.join(' ') : '';
            return `<${type}${attrStr}>\n${body}</${type}>\n`;
        },
        /**
         * Renderer for list item tokens with improved checkbox handling
         * @param item - The list item token to render
         * @returns HTML for the list item
         */
        listitem(item) {
            let itemBody = '';
            const extItem = item;
            // Handle task list items with improved checkbox rendering
            if (item.task) {
                const checkbox = createCheckbox(!!item.checked, options, extItem.raw);
                if (item.loose) {
                    // Handle loose task items - insert checkbox into first paragraph
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                        const paragraphToken = item.tokens[0];
                        // Prepend checkbox to paragraph text
                        paragraphToken.text = checkbox + ' ' + paragraphToken.text;
                        // Also, update the inline tokens if they exist
                        if (paragraphToken.tokens && paragraphToken.tokens.length > 0) {
                            if (paragraphToken.tokens[0].type === 'text') {
                                const textToken = paragraphToken.tokens[0];
                                textToken.text = checkbox + ' ' + textToken.text;
                                textToken.raw = checkbox + ' ' + (textToken.raw || textToken.text);
                            }
                            else {
                                // Insert checkbox as first token
                                paragraphToken.tokens.unshift({
                                    type: 'html',
                                    raw: checkbox + ' ',
                                    text: checkbox + ' ',
                                });
                            }
                        }
                    }
                    else {
                        // No paragraph, add checkbox as HTML token
                        item.tokens.unshift({
                            type: 'html',
                            raw: checkbox + ' ',
                            text: checkbox + ' ',
                        });
                    }
                }
                else {
                    // Handle tight task items - add checkbox directly to output
                    itemBody += checkbox + ' ';
                }
            }
            // Parse the tokens with proper loose/tight handling
            const parsedContent = this.parser.parse(item.tokens, item.loose);
            // Trim excessive whitespace from parsed content for tight lists
            if (!item.loose && !item.task) {
                itemBody += parsedContent.trim();
            }
            else {
                itemBody += parsedContent;
            }
            const attributes = [];
            // Add a value attribute for skipped numbers in ordered lists
            if (extItem.skipped && extItem.value !== null) {
                attributes.push(`value="${extItem.value}"`);
            }
            const attrStr = attributes.length > 0 ? ' ' + attributes.join(' ') : '';
            return `<li${attrStr}>${itemBody}</li>\n`;
        },
    };
}
// Counter for generating unique checkbox IDs
let checkboxIdCounter = 0;
/**
 * Creates an accessible checkbox HTML element
 * @param checked - Whether the checkbox is checked
 * @param options - Configuration options
 * @param itemRaw - Raw Markdown text for this item (for source tracking)
 * @returns HTML string for the checkbox
 */
function createCheckbox(checked, options, itemRaw) {
    const attributes = ['type="checkbox"'];
    // Generate unique ID for this checkbox
    const checkboxId = `task-checkbox-${++checkboxIdCounter}`;
    attributes.push(`id="${checkboxId}"`);
    // Add a disabled attribute if not interactive
    if (!options.interactiveCheckboxes) {
        attributes.push('disabled');
    }
    if (checked) {
        attributes.push('checked');
    }
    // Add a custom class if provided
    if (options.checkboxClass) {
        attributes.push(`class="${escapeHtml(options.checkboxClass)}"`);
    }
    // Add an ARIA label for accessibility
    if (options.checkboxAriaLabel) {
        const label = checked ? 'Checked task item' : 'Unchecked task item';
        attributes.push(`aria-label="${label}"`);
    }
    // Add data attributes for source tracking (when interactive)
    if (options.interactiveCheckboxes) {
        if (itemRaw) {
            attributes.push(`data-raw="${escapeHtml(itemRaw)}"`);
        }
        // Add onclick handler that calls the callback
        if (options.onCheckboxChange !== undefined) {
            // Create an inline handler that extracts metadata and calls the global callback
            const onClickScript = `
        (function(e) {
          const checkbox = e.target;
          const metadata = {
            rawText: checkbox.getAttribute('data-raw')
          };
          if (window.markedListsCallback) {
            window.markedListsCallback('${checkboxId}', checkbox.checked, metadata);
          }
        })(event)
      `.trim().replace(/\s+/g, ' ');
            attributes.push(`onclick="${onClickScript}"`);
        }
    }
    return `<input ${attributes.join(' ')}>`;
}
/**
 * Escapes HTML special characters to prevent XSS
 * @param text - Text to escape
 * @returns Escaped text
 */
function escapeHtml(text) {
    const htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;',
    };
    return text.replace(/[&<>"']/g, (char) => htmlEscapes[char] || char);
}

/**
 * Default configuration options
 */
const DEFAULT_OPTIONS$6 = {
    checkboxClass: '',
    checkboxAriaLabel: true,
    useStartAttribute: true,
    preserveTightness: true,
    interactiveCheckboxes: false,
    onCheckboxChange: undefined,
};
/**
 * Adds support for extended lists in marked.
 * This extension adds support for:
 * - Ordered lists with different types (numeric, alphabetic, roman)
 * - Task lists with checkboxes
 * - Value attribute on list items for skipped numbers
 * - Start attribute for lists beginning at non-1 values
 * - Configurable checkbox rendering with accessibility support
 *
 * @param options - Configuration options
 * @returns The marked extension object
 */
function markedExtendedLists(options = {}) {
    // Merge user options with defaults
    const config = { ...DEFAULT_OPTIONS$6, ...options };
    // Setup callback system for interactive checkboxes
    if (config.interactiveCheckboxes && config.onCheckboxChange !== undefined && typeof window !== 'undefined') {
        // Initialize the global callback registry
        if (!window.markedListsCallbacks) {
            window.markedListsCallbacks = {};
        }
        // Store the callback - will be referenced by checkbox IDs
        window.markedListsCallback = config.onCheckboxChange;
    }
    return {
        tokenizer: {
            // @ts-expect-error - Marked's tokenizer type signature doesn't match this extended implementation
            list: createTokenizer$4(),
        },
        renderer: createRenderer$4(config),
    };
}

const ensureStyles$3 = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables$3(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables$3 = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$4(key), 'g'), value);
    }, styles);
};
const escapeRegExp$4 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * Interactive navigation script for presentations
 */
const NAVIGATION_SCRIPT = `
(function() {
  if (typeof window === 'undefined') return;

  // Initialize presentation state
  window.__presentationState__ = {
    currentSlide: 0,
    totalSlides: 0,
    mode: 'presentation',
    autoplay: false,
    autoplayInterval: 0,
    keyboardEnabled: false // Start with keyboard navigation disabled
  };

  let autoplayTimer = null;
  let presentationFocused = false;

  function initPresentation() {
    const container = document.querySelector('.marked-extended-slide-presentation');
    if (!container) {
      console.log('[Presentation] No presentation container found');
      return;
    }

    const slides = container.querySelectorAll('.marked-extended-slide-slide');
    console.log('[Presentation] Found', slides.length, 'slides');
    window.__presentationState__.totalSlides = slides.length;

    if (slides.length > 0) {
      showSlide(0);
    }

    // Setup controls
    setupControls(container);

    // Setup keyboard navigation
    setupKeyboardNavigation();

    // Setup touch navigation
    setupTouchNavigation(container);

    // Setup hash navigation
    setupHashNavigation();
    
    console.log('[Presentation] Initialized successfully');
  }

  function showSlide(index) {
    const container = document.querySelector('.marked-extended-slide-presentation');
    if (!container) return;

    const slides = container.querySelectorAll('.marked-extended-slide-slide');
    const { totalSlides } = window.__presentationState__;

    // Clamp index
    index = Math.max(0, Math.min(index, totalSlides - 1));
    window.__presentationState__.currentSlide = index;

    // Update slides
    slides.forEach((slide, i) => {
      slide.classList.remove('active', 'prev', 'next');
      if (i === index) {
        slide.classList.add('active');
      } else if (i < index) {
        slide.classList.add('prev');
      } else {
        slide.classList.add('next');
      }
    });

    // Update progress
    updateProgress();

    // Update URL hash
    updateHash(index);

    // Trigger custom event
    container.dispatchEvent(new CustomEvent('slidechange', {
      detail: { currentSlide: index, totalSlides }
    }));
  }

  function updateProgress() {
    const progressBar = document.querySelector('.marked-extended-slide-progress-bar');
    if (!progressBar) return;

    const { currentSlide, totalSlides } = window.__presentationState__;
    const progress = ((currentSlide + 1) / totalSlides) * 100;
    progressBar.style.width = progress + '%';
  }

  function setupControls(container) {
    const prevBtn = container.querySelector('.marked-extended-slide-prev');
    const nextBtn = container.querySelector('.marked-extended-slide-next');
    const overviewBtn = container.querySelector('.marked-extended-slide-overview');
    const fullscreenBtn = container.querySelector('.marked-extended-slide-fullscreen');

    console.log('[Presentation] Setting up controls:', {
      prevBtn: !!prevBtn,
      nextBtn: !!nextBtn,
      overviewBtn: !!overviewBtn,
      fullscreenBtn: !!fullscreenBtn
    });

    if (prevBtn) {
      prevBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[Presentation] Previous button clicked');
        navigateSlide(-1);
      });
    }

    if (nextBtn) {
      nextBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[Presentation] Next button clicked');
        navigateSlide(1);
      });
    }

    if (overviewBtn) {
      overviewBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[Presentation] Overview button clicked');
        toggleOverview();
      });
    }

    if (fullscreenBtn) {
      fullscreenBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[Presentation] Fullscreen button clicked');
        toggleFullscreen(container);
      });
    }

    // Add keyboard toggle button
    addKeyboardToggle(container);

    // Track focus on presentation container
    container.addEventListener('mouseenter', () => {
      presentationFocused = true;
    });

    container.addEventListener('mouseleave', () => {
      presentationFocused = false;
    });

    container.addEventListener('click', () => {
      presentationFocused = true;
    });
  }

  function addKeyboardToggle(container) {
    const controls = container.querySelector('.marked-extended-slide-controls');
    if (!controls) return;

    // Create keyboard toggle button
    const keyboardBtn = document.createElement('button');
    keyboardBtn.className = 'marked-extended-slide-control marked-extended-slide-keyboard-toggle';
    keyboardBtn.setAttribute('aria-label', 'Toggle keyboard navigation');
    keyboardBtn.setAttribute('title', 'Toggle keyboard shortcuts (Ctrl+Shift+K or Alt+K)');
    keyboardBtn.innerHTML = \`
      <svg viewBox="0 0 24 24">
        <path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/>
        <path class="keyboard-disabled-indicator" d="M 2 2 L 22 22" stroke="currentColor" stroke-width="2" display="none"/>
      </svg>
    \`;
    
    keyboardBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleKeyboardNavigation();
    });

    // Insert before the first control
    controls.insertBefore(keyboardBtn, controls.firstChild);
    
    // Update the button state
    updateKeyboardToggleUI();
  }

  function toggleKeyboardNavigation() {
    window.__presentationState__.keyboardEnabled = !window.__presentationState__.keyboardEnabled;
    updateKeyboardToggleUI();
    
    const status = window.__presentationState__.keyboardEnabled ? 'enabled' : 'disabled';
    console.log(\`[Presentation] Keyboard navigation \${status}\`);
  }

  function updateKeyboardToggleUI() {
    const keyboardBtn = document.querySelector('.marked-extended-slide-keyboard-toggle');
    const indicator = keyboardBtn?.querySelector('.keyboard-disabled-indicator');
    
    if (keyboardBtn && indicator) {
      if (window.__presentationState__.keyboardEnabled) {
        keyboardBtn.classList.add('active');
        indicator.setAttribute('display', 'none');
        keyboardBtn.setAttribute('aria-label', 'Keyboard navigation enabled (click to disable)');
      } else {
        keyboardBtn.classList.remove('active');
        indicator.setAttribute('display', 'block');
        keyboardBtn.setAttribute('aria-label', 'Keyboard navigation disabled (click to enable)');
      }
    }
  }

  function setupKeyboardNavigation() {
    document.addEventListener('keydown', (e) => {
      // Ctrl+Shift+K or Alt+K to toggle keyboard navigation (works anywhere)
      if (((e.ctrlKey && e.shiftKey) || e.altKey) && (e.key === 'k' || e.key === 'K')) {
        const presentation = document.querySelector('.marked-extended-slide-presentation');
        if (presentation) {
          e.preventDefault();
          toggleKeyboardNavigation();
          return;
        }
      }

      // Skip if in input/textarea/contenteditable
      if (e.target.matches('input, textarea, [contenteditable="true"]')) return;

      // Check if keyboard navigation is enabled or if presentation is focused
      if (!window.__presentationState__.keyboardEnabled && !presentationFocused) {
        return; // Don't handle shortcuts
      }

      // Check if we're in fullscreen mode (always allow shortcuts in fullscreen)
      const inFullscreen = document.fullscreenElement !== null;
      
      if (!inFullscreen && !presentationFocused && !window.__presentationState__.keyboardEnabled) {
        return;
      }

      // Don't handle single-key shortcuts if they might be used in text input
      // Only handle them when presentation is clearly in focus
      const isSafeForSingleKey = presentationFocused || inFullscreen || window.__presentationState__.keyboardEnabled;

      switch(e.key) {
        case 'ArrowRight':
        case 'PageDown':
          e.preventDefault();
          navigateSlide(1);
          break;
        case ' ':
          // Space only works when safe to avoid interfering with typing
          if (isSafeForSingleKey) {
            e.preventDefault();
            navigateSlide(1);
          }
          break;
        case 'ArrowLeft':
        case 'PageUp':
          e.preventDefault();
          navigateSlide(-1);
          break;
        case 'Home':
          e.preventDefault();
          showSlide(0);
          break;
        case 'End':
          e.preventDefault();
          showSlide(window.__presentationState__.totalSlides - 1);
          break;
        case 'o':
        case 'O':
        case 'Escape':
          if (isSafeForSingleKey || e.key === 'Escape') {
            e.preventDefault();
            toggleOverview();
          }
          break;
        case 'f':
        case 'F':
          if (isSafeForSingleKey) {
            e.preventDefault();
            const container = document.querySelector('.marked-extended-slide-presentation');
            if (container) toggleFullscreen(container);
          }
          break;
      }
    });
  }

  function setupTouchNavigation(container) {
    let touchStartX = 0;
    let touchStartY = 0;

    container.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });

    container.addEventListener('touchend', (e) => {
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;

      // Swipe horizontal
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
        if (deltaX > 0) {
          navigateSlide(-1);
        } else {
          navigateSlide(1);
        }
      }
    });
  }

  function setupHashNavigation() {
    window.addEventListener('hashchange', () => {
      const hash = window.location.hash.slice(1);
      const slideIndex = parseInt(hash, 10);
      if (!isNaN(slideIndex) && slideIndex >= 0) {
        showSlide(slideIndex);
      }
    });

    // Check initial hash
    const hash = window.location.hash.slice(1);
    const slideIndex = parseInt(hash, 10);
    if (!isNaN(slideIndex) && slideIndex >= 0) {
      showSlide(slideIndex);
    }
  }

  function navigateSlide(direction) {
    const { currentSlide, mode } = window.__presentationState__;
    
    if (mode === 'overview') {
      toggleOverview();
      return;
    }

    showSlide(currentSlide + direction);
  }

  function toggleOverview() {
    const container = document.querySelector('.marked-extended-slide-presentation');
    if (!container) return;

    const isOverview = container.classList.toggle('overview-mode');
    window.__presentationState__.mode = isOverview ? 'overview' : 'presentation';

    if (isOverview) {
      // Add click handlers to slides in overview
      const slides = container.querySelectorAll('.marked-extended-slide-slide');
      slides.forEach((slide, index) => {
        slide.addEventListener('click', function handler() {
          toggleOverview();
          showSlide(index);
          slide.removeEventListener('click', handler);
        });
      });
    }
  }

  function toggleFullscreen(element) {
    if (!document.fullscreenElement) {
      element.requestFullscreen().catch(err => {
        console.error('Error attempting to enable fullscreen:', err);
      });
    } else {
      document.exitFullscreen();
    }
  }

  function updateHash(index) {
    window.history.replaceState(null, null, '#' + index);
  }

  // Export API
  window.presentation = {
    next: () => navigateSlide(1),
    prev: () => navigateSlide(-1),
    goto: (index) => showSlide(index),
    toggleOverview,
    toggleFullscreen: () => {
      const container = document.querySelector('.marked-extended-slide-presentation');
      if (container) toggleFullscreen(container);
    },
    toggleKeyboard: toggleKeyboardNavigation,
    getCurrentSlide: () => window.__presentationState__.currentSlide,
    getTotalSlides: () => window.__presentationState__.totalSlides,
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPresentation);
  } else {
    // Run immediately if DOM is already loaded
    initPresentation();
  }

  // Re-initialize when new presentations are added (for dynamic content)
  // Use MutationObserver to watch for new presentation elements
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length > 0) {
        const hasPresentation = Array.from(mutation.addedNodes).some(node => {
          if (node.nodeType === 1) { // Element node
            return node.classList?.contains('marked-extended-slide-presentation') ||
                   node.querySelector?.('.marked-extended-slide-presentation');
          }
          return false;
        });
        
        if (hasPresentation) {
          // Wait a bit for all DOM updates to complete
          setTimeout(() => {
            initPresentation();
          }, 100);
        }
      }
    }
  });

  // Start observing the document body for added nodes
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });

  // Expose initialization function for manual triggering
  window.initPresentation = initPresentation;
})();
`;
const ensureScript = (id, script) => {
    if (typeof window === 'undefined')
        return;
    // Check if script is already injected
    if (document.getElementById(id)) {
        // Script already exists, try to reinitialize
        if (typeof window.initPresentation === 'function') {
            window.initPresentation();
        }
        return;
    }
    const scriptEl = document.createElement('script');
    scriptEl.id = id;
    scriptEl.textContent = script;
    document.body.appendChild(scriptEl);
};

/**
 * The default configuration options for the slide component.
 */
const DEFAULT_OPTIONS$5 = {
    className: 'marked-extended-slide',
    prefixId: 'slide-',
    transition: 'slide',
    transitionDuration: '0.6s',
    defaultLayout: 'default',
    showSlideNumbers: true,
    showControls: true,
    showProgress: true,
    keyboardNavigation: true,
    touchNavigation: true,
    overviewMode: true,
    aspectRatio: '16:9',
    theme: 'default',
    template: null,
    containerTemplate: null,
    customizeToken: null,
    customizePresentation: null,
    injectStyles: true,
    injectScript: true,
};
/**
 * Default template for individual slides
 */
const DEFAULT_SLIDE_TEMPLATE = `
<section id="{slideId}" 
         class="{className}-slide {className}-layout-{layout} {customClass}"
         data-slide-number="{slideNumber}"
         data-transition="{transition}"
         data-background="{background}"
         data-background-image="{backgroundImage}"
         data-background-size="{backgroundSize}"
         data-background-position="{backgroundPosition}"
         style="{slideStyles}">
  <div class="{className}-slide-content">
    {content}
  </div>
  {slideNumberDisplay}
  {notes}
</section>
`;
/**
 * Default template for the presentation container
 */
const DEFAULT_CONTAINER_TEMPLATE = `
<div class="{className}-presentation" 
     data-theme="{theme}"
     data-aspect-ratio="{aspectRatio}"
     data-transition="{transition}">
  {controls}
  {progress}
  <div class="{className}-slides-container">
    {slides}
  </div>
  {metadata}
</div>
`;
/**
 * Template for navigation controls
 */
const CONTROLS_TEMPLATE = `
<div class="{className}-controls">
  <button class="{className}-control {className}-prev" aria-label="Previous slide">
    <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
  </button>
  <button class="{className}-control {className}-next" aria-label="Next slide">
    <svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
  </button>
  <button class="{className}-control {className}-overview" aria-label="Toggle overview">
    <svg viewBox="0 0 24 24"><path d="M3 3h8v8H3zm10 0h8v8h-8zM3 13h8v8H3zm10 0h8v8h-8z"/></svg>
  </button>
  <button class="{className}-control {className}-fullscreen" aria-label="Toggle fullscreen">
    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
  </button>
</div>
`;
/**
 * Template for progress bar
 */
const PROGRESS_TEMPLATE = `
<div class="{className}-progress">
  <div class="{className}-progress-bar" style="width: 0"></div>
</div>
`;
/**
 * Template for slide numbers
 */
const SLIDE_NUMBER_TEMPLATE = `
<div class="{className}-slide-number" aria-label="Slide {current} of {total}">
  <span class="{className}-slide-current">{current}</span>
  <span class="{className}-slide-separator">/</span>
  <span class="{className}-slide-total">{total}</span>
</div>
`;
/**
 * Template for speaker notes
 */
const NOTES_TEMPLATE = `
<aside class="{className}-notes" aria-hidden="true">
  {notes}
</aside>
`;
/**
 * Template for metadata section
 */
const METADATA_TEMPLATE = `
<div class="{className}-metadata" style="display: none;">
  <meta name="presentation-title" content="{title}">
  <meta name="presentation-author" content="{author}">
  <meta name="presentation-date" content="{date}">
  <meta name="presentation-total-slides" content="{totalSlides}">
</div>
`;
/**
 * Default structural styles for the presentation (minimal, layout-only)
 */
const DEFAULT_STYLES$3 = `
  :root {
    --slide-width: 960px;
    --slide-height: 540px;
    --control-size: 40px;
  }
  .marked-extended-slide-presentation { position: relative; width: 100%; height: 100vh; overflow: hidden; }
  .marked-extended-slide-slides-container { position: relative; width: 100%; height: 100%; perspective: 1000px; }
  .marked-extended-slide-slide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: var(--slide-width); height: var(--slide-height); padding: 2rem; box-sizing: border-box; display: none; overflow: hidden; }
  .marked-extended-slide-slide:first-of-type { display: flex; flex-direction: column; opacity: 1; z-index: 2; }
  .marked-extended-slide-slide.active { display: flex; flex-direction: column; opacity: 1; z-index: 2; }
  .marked-extended-slide-slide.prev { opacity: 0; transform: translate(-150%, -50%); }
  .marked-extended-slide-slide.next { opacity: 0; transform: translate(50%, -50%); }
  .marked-extended-slide-slide-content { flex: 1; overflow: auto; }
  .marked-extended-slide-layout-cover { justify-content: center; align-items: center; text-align: center; }
  .marked-extended-slide-layout-center { justify-content: center; align-items: center; }
  .marked-extended-slide-layout-two-cols .marked-extended-slide-slide-content { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
  .marked-extended-slide-layout-image-right .marked-extended-slide-slide-content { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
  .marked-extended-slide-layout-image-left .marked-extended-slide-slide-content { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
  .marked-extended-slide-layout-full { padding: 0; }
  .marked-extended-slide-layout-full .marked-extended-slide-slide-content { width: 100%; height: 100%; }
  .marked-extended-slide-layout-statement { justify-content: center; align-items: center; text-align: center; }
  .marked-extended-slide-layout-quote { justify-content: center; align-items: center; }
  .marked-extended-slide-layout-section { justify-content: center; align-items: center; text-align: center; }
  .marked-extended-slide-controls { position: fixed; bottom: 2rem; right: 2rem; display: flex; gap: 0.5rem; z-index: 100; }
  .marked-extended-slide-control { width: var(--control-size); height: var(--control-size); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; }
  .marked-extended-slide-control svg { width: 24px; height: 24px; fill: currentColor; }
  .marked-extended-slide-keyboard-toggle { position: relative; }
  .marked-extended-slide-progress { position: fixed; bottom: 0; left: 0; width: 100%; height: 3px; z-index: 100; }
  .marked-extended-slide-progress-bar { height: 100%; }
  .marked-extended-slide-slide-number { position: absolute; bottom: 1rem; right: 1rem; z-index: 10; }
  .marked-extended-slide-notes { display: none; }
  .marked-extended-slide-presentation.overview-mode .marked-extended-slide-slides-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 2rem; padding: 2rem; overflow-y: auto; }
  .marked-extended-slide-presentation.overview-mode .marked-extended-slide-slide { position: relative; display: block; transform: scale(0.3); transform-origin: center; cursor: pointer; top: 0; left: 0; }
  @media (max-width: 1200px) { .marked-extended-slide-slide { transform: translate(-50%, -50%) scale(0.8); } }
  @media (max-width: 768px) {
    .marked-extended-slide-slide { transform: translate(-50%, -50%) scale(0.5); width: 100vw; height: 56.25vw; }
    .marked-extended-slide-controls { bottom: 1rem; right: 1rem; }
  }
  @media print {
    .marked-extended-slide-slide { position: relative; display: block !important; transform: none !important; opacity: 1 !important; page-break-after: always; margin: 0; }
    .marked-extended-slide-controls, .marked-extended-slide-progress { display: none !important; }
  }
`;

/**
 * Parse slide properties from a front-matter-like section
 */
/**
 * Build inline styles from slide metadata
 */
function buildSlideStyles(background, backgroundImage, backgroundSize, backgroundPosition) {
    const styles = [];
    if (background) {
        styles.push(`background: ${background}`);
    }
    if (backgroundImage) {
        styles.push(`background-image: url('${backgroundImage}')`);
        if (backgroundSize) {
            styles.push(`background-size: ${backgroundSize}`);
        }
        else {
            styles.push('background-size: cover');
        }
        if (backgroundPosition) {
            styles.push(`background-position: ${backgroundPosition}`);
        }
        else {
            styles.push('background-position: center');
        }
    }
    return styles.join('; ');
}
/**
 * Generate a unique ID
 */
function generateUniqueId(prefix) {
    return `${prefix}${Math.random().toString(36).substring(2, 11)}`;
}
/**
 * Replace placeholders in template
 */
function replaceTemplatePlaceholders(template, replacements) {
    let result = template;
    for (const [key, value] of Object.entries(replacements)) {
        const placeholder = `{${key}}`;
        result = result.replace(new RegExp(placeholder, 'g'), value || '');
    }
    return result;
}

/**
 * Renders an individual slide
 */
function renderSlide(options) {
    const { slideNumber, totalSlides, meta, tokens, parser, presentationMeta, template, } = options;
    const { className, prefixId } = presentationMeta;
    // Generate unique ID for this slide
    const slideId = generateUniqueId(prefixId);
    // Render the content using the parser which has all extensions loaded
    const markedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
    // Build inline styles for background
    const slideStyles = buildSlideStyles(meta.background, meta.backgroundImage, meta.backgroundSize, meta.backgroundPosition);
    // Render slide number if enabled and not hidden for this slide
    const slideNumberHtml = !meta.hideSlideNumber && presentationMeta.showSlideNumbers
        ? replaceTemplatePlaceholders(SLIDE_NUMBER_TEMPLATE, {
            className,
            current: String(slideNumber),
            total: String(totalSlides),
        })
        : '';
    // Render speaker notes if present
    const notesHtml = meta.notes
        ? replaceTemplatePlaceholders(NOTES_TEMPLATE, {
            className,
            notes: meta.notes,
        })
        : '';
    // Get the slide template
    const slideTemplate = template || DEFAULT_SLIDE_TEMPLATE;
    // Replace all placeholders
    return replaceTemplatePlaceholders(slideTemplate, {
        slideId,
        className,
        layout: meta.layout,
        customClass: meta.class || '',
        slideNumber: String(slideNumber),
        transition: meta.transition || presentationMeta.transition,
        background: meta.background || '',
        backgroundImage: meta.backgroundImage || '',
        backgroundSize: meta.backgroundSize || 'cover',
        backgroundPosition: meta.backgroundPosition || 'center',
        slideStyles,
        content: markedContent,
        slideNumberDisplay: slideNumberHtml, // Changed from slideNumberHtml to slideNumberDisplay
        notes: notesHtml,
    });
}
/**
 * Renders the entire presentation
 */
function renderPresentation(options, slideOptions) {
    const { slides, meta, parser } = options;
    const { className } = meta;
    // Render all slides
    const slidesHtml = slides
        .map((slide, index) => renderSlide({
        slideNumber: index + 1,
        totalSlides: slides.length,
        meta: slide.meta,
        tokens: slide.tokens || [],
        parser,
        presentationMeta: meta,
        template: slideOptions.template,
    }))
        .join('\n');
    // Render controls if enabled
    const controlsHtml = meta.showControls
        ? replaceTemplatePlaceholders(CONTROLS_TEMPLATE, { className })
        : '';
    // Render progress bar if enabled
    const progressHtml = meta.showProgress
        ? replaceTemplatePlaceholders(PROGRESS_TEMPLATE, { className })
        : '';
    // Render metadata
    const metadataHtml = replaceTemplatePlaceholders(METADATA_TEMPLATE, {
        className,
        title: meta.title || '',
        author: meta.author || '',
        date: meta.date || '',
        totalSlides: String(slides.length),
    });
    // Get container template
    const containerTemplate = meta.containerTemplate || DEFAULT_CONTAINER_TEMPLATE;
    // Replace all placeholders in container
    return replaceTemplatePlaceholders(containerTemplate, {
        className,
        theme: meta.theme,
        aspectRatio: meta.aspectRatio,
        transition: meta.transition,
        controls: controlsHtml,
        progress: progressHtml,
        slides: slidesHtml,
        metadata: metadataHtml,
    });
}

/**
 * Create the tokenizer for presentations
 * Uses custom block syntax to avoid conflicts with markdown horizontal rules
 *
 * Syntax:
 * ::::presentation{...props}
 * ::::slide{...props}
 * Content here
 * ::::slideend
 * ::::presentationend
 */
function createPresentationTokenizer(options) {
    const { defaultLayout } = options;
    return {
        name: 'presentation',
        level: 'block',
        start(src) {
            const match = src.match(/::::presentation/);
            return match?.index;
        },
        tokenizer(src) {
            // Match the entire presentation block containing multiple slides
            const presentationMatch = src.match(/^::::presentation(?:\{(.*?)\})?\s*\n([\s\S]*?)::::presentationend\s*(?:\n|$)/);
            if (presentationMatch) {
                const [raw, propString, content] = presentationMatch;
                // Parse presentation-level properties
                const presentationProps = parsePropString(propString || '');
                // Split content into individual slides using ::::slide blocks
                const slideMatches = [...content.matchAll(/::::slide(?:\{(.*?)\})?\s*\n([\s\S]*?)::::slideend\s*(?:\n|$)/g)];
                const slides = [];
                for (const slideMatch of slideMatches) {
                    const [slideRaw, slidePropString, slideContent] = slideMatch;
                    // Parse slide properties
                    const slideProps = parsePropString(slidePropString || '');
                    // Parse slide metadata
                    const slideMeta = {
                        layout: slideProps['layout'] || defaultLayout,
                        background: slideProps['background'],
                        backgroundImage: slideProps['backgroundImage'] || slideProps['background'],
                        backgroundSize: slideProps['backgroundSize'],
                        backgroundPosition: slideProps['backgroundPosition'],
                        transition: slideProps['transition'],
                        class: slideProps['class'],
                        notes: slideProps['notes'],
                        hideSlideNumber: slideProps['hideSlideNumber'] === 'true',
                    };
                    // Tokenize slide content
                    const tokens = this.lexer.blockTokens(slideContent.trim());
                    slides.push({
                        type: 'slide',
                        raw: slideRaw,
                        tokens,
                        meta: slideMeta,
                    });
                }
                // If no slides found, return undefined
                if (slides.length === 0) {
                    return undefined;
                }
                // Return presentation token
                return {
                    type: 'presentation',
                    raw,
                    slides,
                    meta: {
                        title: presentationProps['title'],
                        author: presentationProps['author'],
                        date: presentationProps['date'],
                        theme: presentationProps['theme'] || options.theme,
                        transition: presentationProps['transition'] || options.transition,
                        transitionDuration: presentationProps['transitionDuration'] || options.transitionDuration,
                        showControls: presentationProps['showControls'] !== 'false' && options.showControls,
                        showProgress: presentationProps['showProgress'] !== 'false' && options.showProgress,
                        showSlideNumbers: presentationProps['showSlideNumbers'] !== 'false' && options.showSlideNumbers,
                        aspectRatio: presentationProps['aspectRatio'] || options.aspectRatio,
                        className: options.className,
                        prefixId: options.prefixId,
                        containerTemplate: options.containerTemplate,
                    },
                };
            }
            return undefined;
        },
    };
}
/**
 * Parse property string like 'title="My Title" theme="dark"'
 */
function parsePropString(propString) {
    const props = {};
    if (!propString || !propString.trim()) {
        return props;
    }
    // Match key="value" or key='value' or key=value patterns
    const matches = propString.matchAll(/(\w+)=(?:"([^"]*)"|'([^']*)'|([^\s]+))/g);
    for (const match of matches) {
        const key = match[1];
        props[key] = match[2] || match[3] || match[4];
    }
    return props;
}
/**
 * Create the renderer for presentations
 */
function createPresentationRenderer(options) {
    return {
        name: 'presentation',
        renderer(token) {
            const presentationToken = token;
            return renderPresentation({
                slides: presentationToken.slides,
                meta: presentationToken.meta,
                parser: this.parser,
            }, options);
        },
    };
}
/**
 * Create the renderer for individual slides (in case they're rendered separately)
 */
function createSlideRenderer(options) {
    return {
        name: 'slide',
        renderer(token) {
            const slideToken = token;
            return renderSlide({
                slideNumber: 1,
                totalSlides: 1,
                meta: slideToken.meta,
                tokens: slideToken.tokens || [],
                parser: this.parser,
                presentationMeta: {
                    className: options.className,
                    prefixId: options.prefixId,
                    theme: options.theme,
                    transition: options.transition,
                    transitionDuration: options.transitionDuration,
                    showControls: options.showControls,
                    showProgress: options.showProgress,
                    showSlideNumbers: options.showSlideNumbers,
                    aspectRatio: options.aspectRatio,
                    containerTemplate: options.containerTemplate,
                },
                template: options.template,
            });
        },
    };
}

/**
 * Marked Extended Slide extension
 * Creates presentation slides using custom block syntax
 *
 * @example
 * ```markdown
 * ::::presentation{title="My Presentation" theme="dark"}
 *
 * ::::slide{layout="cover"}
 * # Welcome
 *
 * This is the first slide
 * ::::slideend
 *
 * ::::slide
 * ## Second Slide
 *
 * - Point 1
 * - Point 2
 * ::::slideend
 *
 * ::::slide{layout="cover" background="linear-gradient(to right, #667eea 0%, #764ba2 100%)"}
 * # Thank You!
 * ::::slideend
 *
 * ::::presentationend
 * ```
 *
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedSlide(options = {}) {
    // Set sensible defaults
    const config = { ...DEFAULT_OPTIONS$5, ...options };
    // Inject styles if needed
    if (config.injectStyles) {
        ensureStyles$3('marked-extended-slide-styles', DEFAULT_STYLES$3);
    }
    // Inject navigation script if needed
    if (config.injectScript) {
        ensureScript('marked-extended-slide-script', NAVIGATION_SCRIPT);
    }
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type === 'presentation') {
                const presentationToken = token;
                // Apply custom presentation modifications if configured
                if (config.customizePresentation && typeof config.customizePresentation === 'function') {
                    config.customizePresentation(presentationToken);
                }
                // Manually walk through slides since they're nested in the presentation
                if (presentationToken.slides) {
                    for (const slide of presentationToken.slides) {
                        if (config.customizeToken && typeof config.customizeToken === 'function') {
                            config.customizeToken(slide);
                        }
                    }
                }
            }
        },
        extensions: [
            createPresentationTokenizer(config),
            createPresentationRenderer(config),
            createSlideRenderer(config),
        ],
    };
}

const ensureStyles$2 = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables$2(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables$2 = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$3(key), 'g'), value);
    }, styles);
};
const escapeRegExp$3 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * Default configuration options for the spoiler extension
 */
const DEFAULT_OPTIONS$4 = {
    className: 'marked-extended-spoiler',
    prefixId: 'spoiler-',
    template: null,
    customizeToken: null,
    injectStyles: true,
    cssVariables: {
        '{animationDuration}': '0.4s',
        '{padding}': '16px',
        '{borderRadius}': '8px',
        '{transitionTiming}': 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
};
/**
 * Predefined themes for spoilers
 */
const SPOILER_THEMES = {
    default: {
        overlayBg: 'linear-gradient(145deg, rgba(30, 30, 30, 0.95), rgba(15, 15, 15, 0.98))',
        textColor: '#ffffff',
        shadow: '0 4px 20px rgba(0, 0, 0, 0.25), 0 1px 3px rgba(0, 0, 0, 0.1)',
    },
    dark: {
        overlayBg: 'linear-gradient(145deg, rgba(20, 20, 20, 0.95), rgba(5, 5, 5, 0.99))',
        textColor: '#e0e0e0',
        shadow: '0 4px 20px rgba(0, 0, 0, 0.4), 0 1px 3px rgba(0, 0, 0, 0.2)',
    },
    light: {
        overlayBg: 'linear-gradient(145deg, rgba(245, 245, 245, 0.95), rgba(230, 230, 230, 0.98))',
        textColor: '#333333',
        shadow: '0 4px 20px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05)',
    },
    danger: {
        overlayBg: 'linear-gradient(145deg, rgba(220, 53, 69, 0.95), rgba(180, 40, 50, 0.98))',
        textColor: '#ffffff',
        shadow: '0 4px 20px rgba(220, 53, 69, 0.25), 0 1px 3px rgba(220, 53, 69, 0.1)',
    },
    info: {
        overlayBg: 'linear-gradient(145deg, rgba(13, 110, 253, 0.95), rgba(10, 88, 202, 0.98))',
        textColor: '#ffffff',
        shadow: '0 4px 20px rgba(13, 110, 253, 0.25), 0 1px 3px rgba(13, 110, 253, 0.1)',
    },
    warning: {
        overlayBg: 'linear-gradient(145deg, rgba(255, 193, 7, 0.95), rgba(255, 160, 0, 0.98))',
        textColor: '#000000',
        shadow: '0 4px 20px rgba(255, 193, 7, 0.25), 0 1px 3px rgba(255, 193, 7, 0.1)',
    },
    success: {
        overlayBg: 'linear-gradient(145deg, rgba(25, 135, 84, 0.95), rgba(20, 108, 67, 0.98))',
        textColor: '#ffffff',
        shadow: '0 4px 20px rgba(25, 135, 84, 0.25), 0 1px 3px rgba(25, 135, 84, 0.1)',
    },
};
/**
 * Default HTML template for spoiler rendering
 */
const DEFAULT_TEMPLATE$2 = `
<div id="{spoilerId}" class="{className}" tabindex="0" role="button" aria-expanded="false" aria-label="Spoiler - click or hover to reveal">
  <div class="{className}-content">
    {content}
  </div>
  <div class="{className}-overlay">
    <div class="{className}-overlay-content">
      {customTitle}
      <div class="{className}-reveal-hint">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
          <circle cx="12" cy="12" r="3"/>
          <line x1="3" y1="3" x2="21" y2="21" stroke-width="2" stroke-linecap="round"/>
        </svg>
        {customSubTitle}
      </div>
    </div>
  </div>
  <div class="{className}-particles">
    {particlesContent}
  </div>
</div>
<script>
(function() {
  const spoiler = document.getElementById('{spoilerId}');
  if (spoiler) {
    spoiler.addEventListener('click', function(e) {
      // Don't toggle if clicking on interactive elements (checkboxes, links, buttons, inputs)
      const target = e.target;
      if (target.tagName === 'INPUT' || 
          target.tagName === 'BUTTON' || 
          target.tagName === 'A' ||
          target.closest('input, button, a, summary')) {
        return; // Let the element handle its own click
      }
      
      const isExpanded = this.getAttribute('aria-expanded') === 'true';
      this.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
    });
    
    spoiler.addEventListener('keydown', function(e) {
      // Only handle keyboard on the spoiler itself, not on child elements
      if (e.target !== spoiler) return;
      
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        const isExpanded = this.getAttribute('aria-expanded') === 'true';
        this.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
      }
    });
  }
})();
</script>
<style>
  #{spoilerId} {
    box-shadow: {themeShadow};

    & > .{className}-overlay {
      background: {themeBackground};
      color: {themeTextColor};
    }
  }

  {particleStyles}
</style>
`;
/**
 * Default structural CSS styles for the spoiler extension (minimal, layout-only)
 */
const DEFAULT_STYLES$2 = `
.marked-extended-spoiler { position: relative; margin: 1.5em 0; overflow: hidden; min-height: 80px; cursor: pointer; user-select: none; outline: none; }
.marked-extended-spoiler:focus-visible { outline: 2px solid var(--spoiler-focus-color, #4a9eff); outline-offset: 2px; }
.marked-extended-spoiler:hover > .marked-extended-spoiler-content,
.marked-extended-spoiler:focus > .marked-extended-spoiler-content,
.marked-extended-spoiler[aria-expanded="true"] > .marked-extended-spoiler-content { opacity: 1 !important; filter: none !important; transform: scale(1); user-select: text; pointer-events: auto; }
.marked-extended-spoiler:hover > .marked-extended-spoiler-overlay,
.marked-extended-spoiler:focus > .marked-extended-spoiler-overlay,
.marked-extended-spoiler[aria-expanded="true"] > .marked-extended-spoiler-overlay,
.marked-extended-spoiler:hover > .marked-extended-spoiler-particles,
.marked-extended-spoiler:focus > .marked-extended-spoiler-particles,
.marked-extended-spoiler[aria-expanded="true"] > .marked-extended-spoiler-particles { opacity: 0; pointer-events: none; }
.marked-extended-spoiler-content { padding: {padding}; width: 100%; box-sizing: border-box; position: relative; z-index: 1; pointer-events: none; }
.marked-extended-spoiler-content img { max-width: 100%; width: 100%; height: auto; display: block; object-fit: cover; margin: 0.5em 0; }
.marked-extended-spoiler-content p:first-child { margin-top: 0; }
.marked-extended-spoiler-content p:last-child { margin-bottom: 0; }
.marked-extended-spoiler-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; opacity: 1; z-index: 2; }
.marked-extended-spoiler-overlay::before { content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: -1; pointer-events: none; }
.marked-extended-spoiler-overlay-content { text-align: center; padding: 1em; display: flex; flex-direction: column; align-items: center; gap: 0.75em; }
.spoiler-title { display: block; }
.marked-extended-spoiler-reveal-hint { display: flex; align-items: center; gap: 0.5em; }
.marked-extended-spoiler-reveal-hint svg { width: 20px; height: 20px; }
.marked-extended-spoiler-particles { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 1; z-index: 3; overflow: hidden; }
.marked-extended-spoiler-particles .particle { position: absolute; will-change: transform, opacity; backface-visibility: hidden; pointer-events: none; }
@media (max-width: 768px) {
  .marked-extended-spoiler { margin: 1em 0; }
  .marked-extended-spoiler-content { padding: 12px; }
}
@media print {
  .marked-extended-spoiler-overlay, .marked-extended-spoiler-particles { display: none !important; }
  .marked-extended-spoiler-content { opacity: 1 !important; filter: none !important; }
}
`;

function random(min, max) {
    return Math.random() * (max - min) + min;
}
function randomInt(min, max) {
    return Math.floor(random(min, max + 1));
}
function generateParticles(spoilerId, theme = 'default') {
    const particleCount = 20;
    const isLightTheme = theme === 'light' || theme === 'warning';
    const colors = isLightTheme
        ? ['rgba(80, 80, 80, 0.5)', 'rgba(100, 100, 100, 0.4)', 'rgba(60, 60, 60, 0.6)']
        : ['rgba(255, 255, 255, 0.4)', 'rgba(200, 200, 200, 0.3)', 'rgba(180, 180, 180, 0.5)'];
    const shapes = ['50%', '0%', 'polygon(50% 0%, 0% 100%, 100% 100%)'];
    const getRandomShape = () => shapes[randomInt(0, shapes.length - 1)];
    const getRandomColor = () => colors[randomInt(0, colors.length - 1)];
    let particlesContent = '';
    let particleStyles = `#${spoilerId} > .marked-extended-spoiler-particles .particle { background: radial-gradient(circle, currentColor 0%, transparent 70%); filter: blur(${isLightTheme ? 1.5 : 1}px); mix-blend-mode: ${isLightTheme ? 'multiply' : 'screen'}; }`;
    for (let i = 1; i <= particleCount; i++) {
        const size = random(3, 12);
        const top = random(0, 100);
        const left = random(0, 100);
        const opacity = random(0.3, 0.7);
        const duration = random(2, 5);
        const delay = random(0, 3);
        particlesContent += `<div class="particle p${i}"></div>`;
        particleStyles += `#${spoilerId} > .marked-extended-spoiler-particles .p${i} { width: ${size}px; height: ${size}px; top: ${top}%; left: ${left}%; opacity: ${opacity}; color: ${getRandomColor()}; clip-path: ${getRandomShape()}; animation: float-${spoilerId}-${i} ${duration}s ease-in-out infinite; animation-delay: ${delay}s; } @keyframes float-${spoilerId}-${i} { 0%, 100% { transform: translate3d(0, 0, 0); opacity: ${opacity * 0.8}; } 50% { transform: translate3d(${random(-15, 15)}px, ${random(-20, 5)}px, 0); opacity: ${Math.min(opacity * 1.2, 0.9)}; } }`;
    }
    particleStyles += `#${spoilerId}:hover > .marked-extended-spoiler-particles .particle { opacity: 0 !important; transition: opacity 0.3s ease; } @media (prefers-reduced-motion: reduce) { #${spoilerId} > .marked-extended-spoiler-particles .particle { animation: none !important; opacity: 0.2 !important; } }`;
    return { particlesContent, particleStyles };
}

/**
 * Renders the spoiler content with overlay and particle effects
 * @param options - Rendering options
 * @param tokens - Tokens to render within the spoiler
 * @param parser - Parser instance from marked.js renderer context
 * @returns HTML string for the spoiler
 */
function renderSpoiler(options, tokens, parser) {
    const { prefixId, title, subtitle, theme = 'default', className, template } = options;
    // Generate unique ID
    const spoilerId = `${prefixId}${Math.random().toString(36).substring(2, 11)}`;
    // Create custom title with icon
    const customTitle = title
        ? `<span class="spoiler-title">🔒 ${title}</span>`
        : '<span class="spoiler-title">🔒</span>';
    const customSubTitle = subtitle ? `<span>${subtitle}</span>` : '<span>Click or hover to reveal</span>';
    // Parse content using the parser context to support nested extensions
    const markedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
    // Use custom template or default
    const spoilerTemplate = template || DEFAULT_TEMPLATE$2;
    // Get theme styles
    const themeStyles = SPOILER_THEMES[theme] || SPOILER_THEMES['default'];
    // Calculate enhanced shadow for hover
    const themeShadow = themeStyles.shadow;
    const themeShadowHover = themeShadow
        .replace(/(\d+)px/g, (match) => `${parseInt(match) * 1.8}px`)
        .replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/g, (_, r, g, b, a) => `rgba(${r}, ${g}, ${b}, ${Math.min(parseFloat(a) * 1.5, 1)})`);
    // Generate particles
    const { particlesContent, particleStyles } = generateParticles(spoilerId, theme);
    // Replace all placeholders
    return spoilerTemplate
        .replace(/{spoilerId}/g, spoilerId)
        .replace(/{content}/g, markedContent)
        .replace(/{customTitle}/g, customTitle)
        .replace(/{customSubTitle}/g, customSubTitle)
        .replace(/{className}/g, className)
        .replace(/{themeBackground}/g, themeStyles.overlayBg)
        .replace(/{themeTextColor}/g, themeStyles.textColor)
        .replace(/{themeShadow}/g, themeShadow)
        .replace(/{themeShadowHover}/g, themeShadowHover)
        .replace(/{particlesContent}/g, particlesContent)
        .replace(/{particleStyles}/g, particleStyles);
}

/**
 * Regular expression for parsing properties from attribute strings
 * Matches patterns like: property="value"
 */
const propRegex$2 = /\s*(\w+)="([^"]+)"/g;
/**
 * Element patterns configuration for spoiler blocks
 */
const elementPatterns$2 = {
    spoilerBlock: {
        start: '::::spoiler',
        end: '::::spoilerend',
        aliases: [':spr', ':spoiler'],
        endAliases: [':sprend', ':spoilerend'],
    },
};
/**
 * Supported properties by element type
 */
const supportedPropsByElement$2 = {
    spoilerBlock: [
        { name: 'title', defaultValue: '' },
        { name: 'subtitle', defaultValue: '' },
        { name: 'theme', defaultValue: 'default' },
    ],
};
/**
 * Parses balanced opening and closing tags with proper nesting support
 * @param src - Source string to parse
 * @param elementType - Type of element to parse
 * @returns RegExpExecArray or null if no match
 */
function parseBalancedTags$1(src, elementType) {
    const pattern = elementPatterns$2[elementType];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    // Find which start pattern matches
    let startPos = 0;
    if (src.startsWith(start)) {
        startPos = start.length;
    }
    else {
        for (const alias of aliases) {
            if (src.startsWith(alias)) {
                startPos = alias.length;
                break;
            }
        }
        if (startPos === 0)
            return null;
    }
    // Find property block
    let depth = 1;
    const propEnd = src.indexOf('}', startPos);
    if (propEnd === -1)
        return null;
    const propString = src.substring(startPos, propEnd);
    const contentStart = propEnd + 1;
    let pos = contentStart;
    // Parse nested content with depth tracking
    while (pos < src.length && depth > 0) {
        // Find next start tag
        const mainStartPos = src.indexOf(start, pos);
        let nextStartPos = mainStartPos;
        for (const alias of aliases) {
            const aliasPos = src.indexOf(alias, pos);
            if (aliasPos !== -1 && (nextStartPos === -1 || aliasPos < nextStartPos)) {
                nextStartPos = aliasPos;
            }
        }
        // Find next end tag
        let foundEndPattern = end;
        let nextEndPos = src.indexOf(end, pos);
        for (const endAlias of endAliases) {
            const endAliasPos = src.indexOf(endAlias, pos);
            if (endAliasPos !== -1 && (nextEndPos === -1 || endAliasPos < nextEndPos)) {
                nextEndPos = endAliasPos;
                foundEndPattern = endAlias;
            }
        }
        if (nextEndPos === -1)
            return null;
        // Handle nested tags
        if (nextStartPos !== -1 && nextStartPos < nextEndPos) {
            depth++;
            let matchedPattern = start;
            if (nextStartPos === mainStartPos) {
                matchedPattern = start;
            }
            else {
                for (const alias of aliases) {
                    if (src.indexOf(alias, pos) === nextStartPos) {
                        matchedPattern = alias;
                        break;
                    }
                }
            }
            pos = nextStartPos + matchedPattern.length;
            continue;
        }
        // Check if we've closed all nested tags
        if (--depth === 0) {
            const content = src.substring(contentStart, nextEndPos);
            const fullMatch = src.substring(0, nextEndPos + foundEndPattern.length);
            const result = [fullMatch, propString, content];
            result.index = 0;
            result.input = src;
            return result;
        }
        pos = nextEndPos + foundEndPattern.length;
    }
    return null;
}
/**
 * Validates and parses element patterns from source string
 * @param element - Element type or RegExp to validate
 * @param src - Source string to parse
 * @returns RegExpExecArray or null if no match
 */
const validateRegex$2 = (element, src) => {
    if (element instanceof RegExp) {
        return element.exec(src);
    }
    switch (element) {
        case 'spoilerBlock':
            return parseBalancedTags$1(src, element);
        default:
            throw new Error(`Unknown element: ${element}`);
    }
};
/**
 * Constructs properties object from property string
 * @param element - Element type
 * @param propString - String containing properties
 * @returns Record of property names to values
 */
const constructProps$2 = (element, propString) => {
    const supportedProps = supportedPropsByElement$2[element];
    if (!supportedProps) {
        throw new Error(`Unknown element: ${element}`);
    }
    // Initialize with default values
    const props = {};
    supportedProps.forEach((prop) => {
        props[prop.name] = prop.defaultValue;
    });
    // Parse and override with actual values
    propRegex$2.lastIndex = 0;
    let propMatch;
    while ((propMatch = propRegex$2.exec(propString)) !== null) {
        const [, name, value] = propMatch;
        if (supportedProps.some((p) => p.name === name)) {
            props[name] = value;
        }
    }
    return props;
};

/**
 * Creates the spoiler tokenizer
 * @param options - Configuration options
 * @returns Marked tokenizer extension
 */
function createTokenizer$3(options) {
    const { className, prefixId, template } = options;
    const element = 'spoilerBlock';
    return {
        name: 'spoiler',
        level: 'block',
        tokenizer(src) {
            const blockMatch = validateRegex$2(element, src);
            if (!blockMatch)
                return undefined;
            const [raw, propString, content] = blockMatch;
            // Parse properties
            const props = constructProps$2(element, propString);
            // Tokenize the content to support nested extensions
            const tokens = this.lexer.blockTokens(content.trim());
            // Return token with metadata and tokens
            return {
                type: 'spoiler',
                raw,
                tokens,
                meta: {
                    prefixId,
                    title: props.title,
                    subtitle: props.subtitle,
                    theme: props.theme,
                    className,
                    template,
                },
            };
        },
    };
}
/**
 * Creates the spoiler renderer
 * @returns Marked renderer extension
 */
function createRenderer$3() {
    return {
        name: 'spoiler',
        renderer(token) {
            const spoilerToken = token;
            // Pass tokens and parser to the renderer for proper nested extension support
            return renderSpoiler(spoilerToken.meta, spoilerToken.tokens || [], this.parser);
        },
    };
}

/**
 * Marked Extended Spoiler extension
 *
 * Adds support for interactive spoiler blocks with reveal effects.
 *
 * @param options - Configuration options
 * @returns Marked extension object
 *
 * @example
 * ```typescript
 * import { marked } from 'marked';
 * import markedExtendedSpoiler from '@fsegurai/marked-extended-spoiler';
 *
 * marked.use(markedExtendedSpoiler({
 *   injectStyles: true,
 *   className: 'my-spoiler',
 * }));
 *
 * const markdown = `
 * ::::spoiler{title="Plot Twist" theme="danger"}
 * The hero was the villain all along!
 * ::::spoilerend
 * `;
 * ```
 */
function markedExtendedSpoiler(options = {}) {
    // Merge options with defaults
    const config = { ...DEFAULT_OPTIONS$4, ...options };
    // Inject styles if enabled
    if (config.injectStyles) {
        ensureStyles$2('marked-extended-spoiler-styles', DEFAULT_STYLES$2, config.cssVariables);
    }
    return {
        walkTokens(token) {
            // Apply custom token modifications if configured
            if (token.type === 'spoiler' && config.customizeToken) {
                config.customizeToken(token);
            }
        },
        extensions: [createTokenizer$3(config), createRenderer$3()],
    };
}

/**
 * Creates an HTML table cell with appropriate attributes
 *
 * @param text - The text content of the cell
 * @param cell - Cell object with rowspan and colspan properties
 * @param type - The type of cell ('th' or 'td')
 * @param align - Alignment of the cell ('left', 'right', 'center', or null)
 * @returns HTML string for the cell
 */
const getTableCell = (text, cell, type, align) => {
    if (!cell.rowspan)
        return '';
    const tag = `<${type}`
        + `${cell.colspan > 1 ? ` colspan=${cell.colspan}` : ''}`
        + `${cell.rowspan > 1 ? ` rowspan=${cell.rowspan}` : ''}`
        + `${align ? ` align=${align}` : ''}>`;
    return `${tag + text}</${type}>\n`;
};
/**
 * Splits a table row into cells and processes row/column spans
 *
 * @param tableRow - The raw table row text
 * @param count - Number of columns to normalize to (null for no normalization)
 * @param prevRow - Previous row for handling row spans
 * @param maxColspan - Maximum number of columns a cell can span (null for no limit)
 * @returns Array of processed table cells
 */
const splitCells = (tableRow, count, prevRow = null, maxColspan = null) => {
    const cells = [...tableRow.matchAll(/(?:[^|\\]|\\.?)+(?:\|+|$)/g)].map((x) => x[0]);
    // Remove the first / last cell in a row if whitespace only and no leading/trailing pipe
    if (!cells[0]?.trim())
        cells.shift();
    if (!cells[cells.length - 1]?.trim())
        cells.pop();
    return processSpans(cells, count, prevRow || [], maxColspan);
};
/**
 * Check if two cell ranges overlap
 */
const cellsOverlap = (startPos1, endPos1, startPos2, endPos2) => {
    return startPos1 <= endPos2 && endPos1 >= startPos2;
};
/**
 * Find a matching cell in the previous row that overlaps with the current cell's position
 */
const findMatchingCell = (prevRow, startPosition, endPosition) => {
    for (const prevCell of prevRow) {
        const prevStartPosition = prevCell.position || 0;
        const prevEndPosition = prevStartPosition + prevCell.colspan - 1;
        if (cellsOverlap(startPosition, endPosition, prevStartPosition, prevEndPosition)) {
            return prevCell;
        }
    }
    return null;
};
/**
 * Handle rowspan logic for a cell with its matching previous row cell
 */
const handleRowSpan = (cell, prevCell, cellText, colspanCells) => {
    const textWithoutCaret = cellText.slice(0, -1);
    // Both cells have colspan > 1 (complex case)
    if (cell.colspan > 1 && prevCell.colspan > 1) {
        // Exact match - simple merge
        if (cell.colspan === prevCell.colspan && cell.position === prevCell.position) {
            return mergeRowSpanCells(cell, prevCell, textWithoutCaret);
        }
        // Complex case - track for later processing
        const key = `${cell.position}-${cell.colspan}`;
        colspanCells.set(key, {
            original: prevCell,
            newCell: cell,
        });
        return false; // Keep cell visible for now
    }
    // Standard case-merge cells
    return mergeRowSpanCells(cell, prevCell, textWithoutCaret);
};
/**
 * Merge two cells for rowspan functionality
 */
const mergeRowSpanCells = (cell, prevCell, textToAppend) => {
    const target = prevCell.rowSpanTarget ?? prevCell;
    cell.rowSpanTarget = target;
    target.text += ` ${textToAppend}`;
    target.rowspan += 1;
    cell.rowspan = 0;
    return true;
};
/**
 * Process row and column spans in table cells
 *
 * @param cells - Raw cells to process
 * @param count - Number of columns to normalize to
 * @param prevRow - Previous row for handling row spans
 * @param maxColspan - Maximum number of columns a cell can span
 * @returns Processed table cells
 */
const processSpans = (cells, count, prevRow = [], maxColspan = null) => {
    let numCols = 0;
    let i;
    let trimmedCell;
    // Track colspan cells that need rowspan
    const colspanCells = new Map();
    const processedCells = [];
    // First pass: Process each cell's colspan
    for (i = 0; i < cells.length; i++) {
        trimmedCell = cells[i].split(/\|+$/)[0];
        // Calculate colspan and apply maxColspan limit if specified
        let colspan = Math.max(cells[i].length - trimmedCell.length, 1);
        if (maxColspan !== null && colspan > maxColspan)
            colspan = maxColspan;
        processedCells[i] = {
            rowspan: 1,
            colspan: colspan,
            text: trimmedCell.trim().replace(/\\\|/g, '|'),
            position: numCols, // Store the original column position for better tracking
        };
        numCols += processedCells[i].colspan;
    }
    // Second pass: Process rowspan by matching cells by position
    for (i = 0; i < processedCells.length; i++) {
        const cell = processedCells[i];
        const cellText = cell.text;
        // Handle Rowspan - cells ending with ^
        if (cellText.slice(-1) === '^' && prevRow.length > 0) {
            let targetFound = false;
            const startPosition = cell.position;
            const endPosition = startPosition + cell.colspan - 1;
            // Try to find a matching cell in the previous row using optimized overlap detection
            const matchingCell = findMatchingCell(prevRow, startPosition, endPosition);
            if (matchingCell) {
                targetFound = handleRowSpan(cell, matchingCell, cellText, colspanCells);
            }
            // If no target was found, but it's a rowspan cell, handle as normal text
            if (!targetFound && cell.rowspan > 0)
                cell.text = cell.text.slice(0, -1);
        }
    }
    // Process any complex colspan+rowspan combinations we tracked
    colspanCells.forEach((spanData) => {
        const { original, newCell } = spanData;
        if (original && newCell) {
            // Here we could apply more sophisticated merging logic
            // For now, just mark that these cells have a relationship
            newCell.complexRowSpan = true;
            newCell.relatedCell = original;
        }
    });
    // Normalize column count
    return normalizeColumnCount(processedCells, count, numCols);
};
/**
 * Ensures the row has the correct number of columns
 *
 * @param cells - The cells to normalize
 * @param count - The target column count (null for no normalization)
 * @param numCols - Current number of columns
 * @returns Normalized cells
 */
const normalizeColumnCount = (cells, count, numCols) => {
    // If the count is null, don't normalize
    if (count === null)
        return cells;
    if (numCols > count) {
        // We need to keep track of the total column count
        let currentColCount = 0;
        const cellsToKeep = [];
        for (const cell of cells) {
            if (currentColCount + cell.colspan <= count) {
                // This cell fits completely
                cellsToKeep.push(cell);
                currentColCount += cell.colspan;
            }
            else if (currentColCount < count) {
                // This cell partially fits - adjust its colspan
                const adjustedCell = { ...cell };
                adjustedCell.colspan = count - currentColCount;
                cellsToKeep.push(adjustedCell);
                currentColCount = count;
            }
            else {
                // This cell doesn't fit at all
                break;
            }
        }
        return cellsToKeep;
    }
    else {
        while (numCols < count) {
            cells.push({
                colspan: 1,
                rowspan: 1,
                text: '',
                position: numCols,
            });
            numCols += 1;
        }
    }
    return cells;
};

/**
 * Create a tokenizer for extended tables
 *
 * @param options - Configuration options
 * @returns Tokenizer function
 */
function createTokenizer$2(options) {
    const { detectFooter = false, strictCaptions = false, maxColspan = null } = options;
    return function tokenizer(src) {
        // The existing regex with optional caption support
        // Uses stricter caption regex if strictCaptions is true
        const captionPattern = strictCaptions
            ? '(?:\\[([^\\]]+)\\] *\\n)' // Required caption with strict format
            : '(?:\\[([^\\]]+)\\] *\\n)?'; // Optional caption with flexible format
        const regex = new RegExp('^'
            + captionPattern
            + '([^\\n ].*\\|.*\\n(?: *[^\\s].*\\n)*?)' // Header
            + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
            + '(?:\\n((?:(?! *\\n| {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})' // Cells
            + '(?:\\n+|$)| {0,3}#{1,6} | {0,3}>| {4}[^\\n]| {0,3}(?:`{3,}'
            + '(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n| {0,3}(?:[*+-]|1[.)]) |'
            + '<\\/?(?:address|article|aside|base|basefont|blockquote|body|'
            + 'caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?: +|\\n|\\/?>)|<(?:script|pre|style|textarea|!--)).*(?:\\n|$))*)\\n*|$)');
        const cap = regex.exec(src);
        if (!cap)
            return undefined;
        // Use internal type during parsing
        const item = {
            type: 'spanTable',
            raw: cap[0],
            header: cap[2].replace(/\n$/, '').split('\n'),
            align: cap[3].replace(/^ *|\| *$/g, '').split(/ *\| */),
            rows: cap[4] ? cap[4].replace(/\n$/, '').split('\n') : [],
        };
        // Add caption if found
        if (cap[1]) {
            item.caption = cap[1].trim();
            item.captionTokens = [];
            this.lexer.inline(item.caption, item.captionTokens);
        }
        // Process header rows - convert first string to TableRow
        item.header[0] = splitCells(item.header[0], null, null, maxColspan);
        const firstHeaderRow = item.header[0];
        const colCount = firstHeaderRow.reduce((length, header) => length + header.colspan, 0);
        if (colCount !== item.align.length)
            return undefined;
        // Process alignment
        processAlignment(item);
        // Process remaining headers and rows
        processRows(item, colCount, this.lexer, maxColspan);
        // Mark footer row if detectFooter is true and we have at least one row
        if (detectFooter && item.rows.length > 0) {
            item.hasFooter = true;
            const lastRowIndex = item.rows.length - 1;
            item.footerRow = item.rows[lastRowIndex];
            item.rows.splice(lastRowIndex, 1); // Remove from regular rows
        }
        // At this point, all strings have been converted to TableRow[], so we can return as SpanTableToken
        return item;
    };
}
/**
 * Process alignment tokens
 */
function processAlignment(item) {
    for (let i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i] || '')) {
            item.align[i] = 'right';
        }
        else if (/^ *:-+: *$/.test(item.align[i] || '')) {
            item.align[i] = 'center';
        }
        else if (/^ *:-+ *$/.test(item.align[i] || '')) {
            item.align[i] = 'left';
        }
        else {
            item.align[i] = null;
        }
    }
}
/**
 * Process header and body rows
 */
function processRows(item, colCount, lexer, maxColspan) {
    // Process header rows after the first
    for (let i = 1; i < item.header.length; i++) {
        item.header[i] = splitCells(item.header[i], colCount, item.header[i - 1], maxColspan);
    }
    // Process body rows
    for (let i = 0; i < item.rows.length; i++) {
        item.rows[i] = splitCells(item.rows[i], colCount, i > 0 ? item.rows[i - 1] : null, maxColspan);
    }
    // Add inline tokens to header cells (all are TableRow at this point)
    for (const row of item.header) {
        for (const cell of row) {
            cell.tokens = [];
            lexer.inline(cell.text, cell.tokens);
        }
    }
    // Add inline tokens to body cells (all are TableRow at this point)
    for (const row of item.rows) {
        for (const cell of row) {
            cell.tokens = [];
            lexer.inline(cell.text, cell.tokens);
        }
    }
    // Add inline tokens to the footer row if it exists
    if (item.footerRow) {
        for (const cell of item.footerRow) {
            cell.tokens = [];
            lexer.inline(cell.text, cell.tokens);
        }
    }
}

/**
 * Create a renderer for extended tables
 *
 * @param options - Configuration options
 * @returns Renderer function
 */
function createRenderer$2(options) {
    const { useTheadTbody = true, useTfoot = false, className, captionTop = true, handleComplexSpans = true, } = options;
    return function renderer(token) {
        // Cast the generic token to our specific SpanTableToken type
        const tableToken = token;
        // Add table class if specified
        let output = className ? `<table class="${className}">\n` : '<table>\n';
        // Add a caption if tableToken has one
        if (tableToken.caption) {
            const captionHtml = `<caption>${this.parser.parseInline(tableToken.captionTokens || [])}</caption>\n`;
            if (captionTop)
                output += captionHtml;
        }
        // Render a header with or without thead
        if (useTheadTbody) {
            output += renderHeaderWithThead(tableToken, this.parser, handleComplexSpans);
        }
        else {
            output += renderHeaderSimple(tableToken, this.parser, handleComplexSpans);
        }
        // Render the body if it exists
        if (tableToken.rows.length || tableToken.footerRow) {
            // Handle standard rows
            if (useTheadTbody) {
                output += '<tbody>\n';
                for (const row of tableToken.rows) {
                    output += renderRow(row, tableToken.align, this.parser, 'td', handleComplexSpans);
                }
                output += '</tbody>\n';
            }
            else {
                for (const row of tableToken.rows) {
                    output += renderRow(row, tableToken.align, this.parser, 'td', handleComplexSpans);
                }
            }
            // Handle footer row (either from detectFooter or useTfoot)
            if (tableToken.footerRow && useTfoot) {
                output += '<tfoot>\n';
                output += renderRow(tableToken.footerRow, tableToken.align, this.parser, 'td', handleComplexSpans);
                output += '</tfoot>\n';
            }
            else if (tableToken.footerRow) {
                // If there's a footer row from detectFooter but we're not using tfoot
                output += renderRow(tableToken.footerRow, tableToken.align, this.parser, 'td', handleComplexSpans);
            }
            else if (useTfoot && tableToken.rows.length > 0) {
                // If useTfoot is true but no footer was detected, use the last row
                const lastRow = tableToken.rows.pop();
                if (lastRow) {
                    output += '<tfoot>\n';
                    output += renderRow(lastRow, tableToken.align, this.parser, 'td', handleComplexSpans);
                    output += '</tfoot>\n';
                }
            }
        }
        // Add caption at bottom if specified
        if (tableToken.caption && !captionTop) {
            output += `<caption>${this.parser.parseInline(tableToken.captionTokens || [])}</caption>\n`;
        }
        output += '</table>\n';
        return output;
    };
}
/**
 * Render a table header with thead tag
 */
function renderHeaderWithThead(token, parser, handleComplexSpans = true) {
    let output = '<thead>\n';
    for (const headerRow of token.header) {
        output += renderRow(headerRow, token.align, parser, 'th', handleComplexSpans);
    }
    output += '</thead>\n';
    return output;
}
/**
 * Render a table header without thead tag
 */
function renderHeaderSimple(token, parser, handleComplexSpans = true) {
    let output = '';
    for (const headerRow of token.header) {
        output += renderRow(headerRow, token.align, parser, 'th', handleComplexSpans);
    }
    return output;
}
/**
 * Render a single table row
 */
function renderRow(row, align, parser, cellType, handleComplexSpans = true) {
    let output = '<tr>\n';
    let col = 0;
    for (const cell of row) {
        // Skip cells that are part of a rowspan
        if (cell.rowspan > 0) {
            const cellAlign = align[col] || null;
            const text = parser.parseInline(cell.tokens || []);
            // Check for complex spanning case
            if (handleComplexSpans && cell.complexRowSpan) {
                // Special handling for complex row+column spans
                // Here we could render differently based on the complexity
                output += getComplexTableCell(text, cell, cellType, cellAlign);
            }
            else {
                // Standard cell rendering
                output += getTableCell(text, cell, cellType, cellAlign);
            }
        }
        col += cell.colspan;
    }
    output += '</tr>\n';
    return output;
}
/**
 * Creates a table cell with special handling for complex spanning cases
 */
function getComplexTableCell(text, cell, type, align) {
    if (!cell.rowspan)
        return '';
    // For complex cases, we might want to add special classes or data attributes
    const tag = `<${type}`
        + `${cell.colspan > 1 ? ` colspan=${cell.colspan}` : ''}`
        + `${cell.rowspan > 1 ? ` rowspan=${cell.rowspan}` : ''}`
        + `${align ? ` align=${align}` : ''}`
        + ' class="complex-span">'; // Add a class to identify complex spans
    return `${tag + text}</${type}>\n`;
}

/**
 * Default configuration options for the extended tables extension.
 * These options control the rendering behavior of tables in Markdown.
 */
const DEFAULT_OPTIONS$3 = {
    useTheadTbody: true,
    useTfoot: false,
    className: null,
    captionTop: true,
    detectFooter: false,
    strictCaptions: false,
    maxColspan: null,
    handleComplexSpans: true,
};

/**
 * Adds support for extended tables in marked.
 * This extension enhances Markdown tables with advanced features:
 * - Row spanning with the `^` character
 * - Column spanning using multiple pipe characters `|`
 * - Multi-row headers
 * - Table captions using [Caption] syntax
 * - Column alignment using `:---:` syntax
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedTables(options = {}) {
    const config = { ...DEFAULT_OPTIONS$3, ...options };
    return {
        extensions: [
            {
                name: 'spanTable',
                level: 'block',
                start(src) {
                    return src.match(/^\n *([^\n ].*\|.*)\n/)?.index;
                },
                tokenizer: createTokenizer$2(config),
                renderer: createRenderer$2(config),
            },
        ],
    };
}

const ensureStyles$1 = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables$1(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables$1 = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$2(key), 'g'), value);
    }, styles);
};
const escapeRegExp$2 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

// Counter for generating unique IDs for tab containers
const tabCounter = { value: 0 };
/**
 * Default configuration options for the extended tabs component.
 *
 * @constant {Object} DEFAULT_OPTIONS
 * @property {string} className - The CSS class name applied to the tabs container.
 * @property {boolean} persistSelection - Determines if the selection state should be persisted across sessions.
 * @property {string} animation - The animation style for tab transitions, either 'fade', 'slide', or 'none'.
 * @property {boolean} autoActivate - If true, the first tab is automatically activated when no tab is marked as active.
 * @property {?string} template - A custom template for rendering the tabs, or null to use the default template.
 * @property {?Function} customizeToken - A function for customizing tab-related tokens, or null for default handling.
 * @property {boolean} injectStyles - Indicates whether default styles should be injected into the document.
 */
const DEFAULT_OPTIONS$2 = {
    className: 'marked-extended-tabs-container',
    persistSelection: true,
    animation: 'fade', // 'fade', 'slide', or 'none'
    autoActivate: true, // Automatically activate first tab if none marked active
    template: null,
    customizeToken: null,
    injectStyles: true,
};
/**
 * DEFAULT_TEMPLATE is a template string used to generate the HTML structure
 * for a custom tab component. It contains placeholders that are dynamically
 * replaced with actual values during runtime to customize the generated markup.
 *
 * Placeholders:
 * - {tabsContainerId}: The unique identifier for the container of the tabs.
 * - {className}: The CSS class names to be applied to the container.
 * - {animation}: The data-animation attribute value for defining the animation type.
 * - {inputsNav}: Additional HTML or elements used in the navigation section of the tabs.
 * - {navList}: The list of navigation items for the tabs, rendered as part of the tablist.
 * - {content}: The content to be displayed in the tabs' content area.
 * - {stylesBehavior}: Inline styles or behaviors injected into the template.
 */
const DEFAULT_TEMPLATE$1 = `
  <div id="{tabsContainerId}" class="{className}" data-animation="{animation}">
    {inputsNav}
    <div class="marked-extended-tabs-nav" role="tablist">{navList}</div>
    <div class="marked-extended-tabs-content">{content}</div>
    {stylesBehavior}
  </div>
`;
/**
 * Default structural CSS styles for tabs (minimal, layout-only).
 * Visual/theming styles are in the demo theme file.
 */
const DEFAULT_STYLES$1 = `
.marked-extended-tabs-container { margin: 1rem 0; overflow: hidden; }
.marked-extended-tabs-container .marked-extended-tabs-input { position: absolute; opacity: 0; pointer-events: none; }
.marked-extended-tabs-container .marked-extended-tabs-nav { display: flex; justify-content: space-evenly; list-style: none; margin: 0; padding: 0; overflow-x: auto; }
.marked-extended-tabs-nav .marked-extended-tabs-label { display: flex; flex: 1 1 auto; justify-content: center; align-items: center; flex-direction: row; flex-wrap: wrap; gap: 0.5rem; padding: 0.75rem 1rem; cursor: pointer; border: none; }
.marked-extended-tabs-nav .marked-extended-tabs-label .marked-extended-tabs-icon { display: inline-flex; align-items: center; justify-content: center; }
.marked-extended-tabs-container .marked-extended-tabs-content { padding: 1rem; }
.marked-extended-tabs-content img { max-width: 100%; width: 100% !important; height: auto; display: block; object-fit: cover; margin: 0; }
.marked-extended-tabs-content .marked-extended-tabs-content-pane { display: none; }
@media (max-width: 768px) {
  .marked-extended-tabs-nav .marked-extended-tabs-label { padding: 0.5rem 0.75rem; gap: 0.4rem; }
}
@media (max-width: 480px) {
  .marked-extended-tabs-nav .marked-extended-tabs-label { flex-direction: column; text-align: center; padding: 0.5rem; }
}
`;
/**
 * Generates a CSS style string for tabs, defining how each tab is displayed and animated
 * based on the provided container ID, tab data, and animation type.
 *
 * @param {string} tabsContainerId - The ID of the container element that wraps the tabs.
 * @param {Array<{id: string}>} tabsData - An array of objects representing tabs,
 *                                         each object must have a unique `id`.
 * @param {string} animation - The type of animation to apply when switching tabs.
 *                              Acceptable values are 'fade', 'slide', or 'none'.
 * @return {string} A string of CSS styles defining the behavior of the tabs and their animations.
 */
function createTabsStyles(tabsContainerId, tabsData, animation) {
    return `<style>    
    /* CSS-only tab selection - show selected tab */
    ${tabsData
        .map((tab) => {
        const inputId = `input-${tab.id}`;
        const labelId = `label-${tab.id}`;
        const tabId = tab.id;
        return `
        /* Show tab content when corresponding input is checked */
        #${tabsContainerId} #${inputId}:checked ~ .marked-extended-tabs-content #${tabId} {
          display: block;
          animation: ${animation === 'fade' ? 'tab-fade-in' : animation === 'slide' ? 'tab-slide-in' : 'none'} 0.3s ease-in-out;
        }
        
        /* Style for active tab */
        #${tabsContainerId} #${inputId}:checked ~ .marked-extended-tabs-nav #${labelId} {
          // background: light-dark(#2d333b, #fff);
          background: var(--marked-extended-tabs-selected-background) !important;
          border-bottom: 2px solid var(--md-sys-color-primary) !important;
          font-weight: 600 !important;
        }
      `;
    })
        .join('')}
    
    /* Animation keyframes */
    ${animation === 'fade'
        ? `
      @keyframes tab-fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }
    `
        : ''}
    
    ${animation === 'slide'
        ? `
      @keyframes tab-slide-in {
        from { transform: translateY(10px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
    `
        : ''}
  </style>`;
}

/**
 * Regular expression for parsing properties from attribute strings
 * Matches patterns like: property="value"
 */
const propRegex$1 = /\s*(\w+)="([^"]+)"/g;
/**
 * Element patterns configuration for tabs blocks
 */
const elementPatterns$1 = {
    tabBlock: {
        start: '::::tabs',
        end: '::::tabsend',
        aliases: [':tbs', ':tabs'],
        endAliases: [':tbsend', ':tabsend'],
    },
    tabItemBlock: {
        start: ':::tab',
        end: ':::tabend',
        aliases: [':tab'],
        endAliases: [':tabend'],
    },
};
/**
 * Supported properties by element type
 */
const supportedPropsByElement$1 = {
    tabItemBlock: [
        { name: 'label', defaultValue: '' },
        { name: 'active', defaultValue: 'false' },
        { name: 'icon', defaultValue: null },
    ],
};
/**
 * Parses balanced opening and closing tags with proper nesting support
 * @param src - Source string to parse
 * @param elementType - Type of element to parse
 * @returns RegExpExecArray or null if no match
 */
function parseBalancedTags(src, elementType) {
    const pattern = elementPatterns$1[elementType];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    // Find which start pattern matches
    let matchedStart = '';
    if (src.startsWith(start)) {
        matchedStart = start;
    }
    else {
        for (const alias of aliases) {
            if (src.startsWith(alias)) {
                matchedStart = alias;
                break;
            }
        }
    }
    if (!matchedStart)
        return null;
    const startPos = matchedStart.length;
    // Parse property block (optional)
    let propString = '';
    let contentStart = startPos;
    // Skip whitespace and check for property block
    let scanPos = startPos;
    while (scanPos < src.length && src[scanPos] === ' ') {
        scanPos++;
    }
    if (scanPos < src.length && src[scanPos] === '{') {
        const propEnd = src.indexOf('}', scanPos);
        if (propEnd !== -1) {
            propString = src.substring(startPos, propEnd);
            contentStart = propEnd + 1;
        }
    }
    // Parse nested content with depth tracking
    let depth = 1;
    let pos = contentStart;
    while (pos < src.length && depth > 0) {
        // Find next start tag
        const mainStartPos = src.indexOf(start, pos);
        let nextStartPos = mainStartPos;
        for (const alias of aliases) {
            const aliasPos = src.indexOf(alias, pos);
            if (aliasPos !== -1 && (nextStartPos === -1 || aliasPos < nextStartPos)) {
                nextStartPos = aliasPos;
            }
        }
        // Find next end tag
        let foundEndPattern = end;
        let nextEndPos = src.indexOf(end, pos);
        for (const endAlias of endAliases) {
            const endAliasPos = src.indexOf(endAlias, pos);
            if (endAliasPos !== -1 && (nextEndPos === -1 || endAliasPos < nextEndPos)) {
                nextEndPos = endAliasPos;
                foundEndPattern = endAlias;
            }
        }
        if (nextEndPos === -1)
            return null;
        // Handle nested tags
        if (nextStartPos !== -1 && nextStartPos < nextEndPos) {
            depth++;
            let matchedPattern = start;
            if (nextStartPos === mainStartPos) {
                matchedPattern = start;
            }
            else {
                for (const alias of aliases) {
                    if (src.indexOf(alias, pos) === nextStartPos) {
                        matchedPattern = alias;
                        break;
                    }
                }
            }
            pos = nextStartPos + matchedPattern.length;
            continue;
        }
        // Check if we've closed all nested tags
        if (--depth === 0) {
            const content = src.substring(contentStart, nextEndPos);
            const fullMatch = src.substring(0, nextEndPos + foundEndPattern.length);
            const result = [fullMatch, propString, content];
            result.index = 0;
            result.input = src;
            return result;
        }
        pos = nextEndPos + foundEndPattern.length;
    }
    return null;
}
/**
 * Validates and parses element patterns from source string
 * @param element - Element type or RegExp to validate
 * @param src - Source string to parse
 * @returns RegExpExecArray or null if no match
 */
const validateRegex$1 = (element, src) => {
    if (element instanceof RegExp) {
        return element.exec(src);
    }
    switch (element) {
        case 'tabBlock':
        case 'tabItemBlock':
            return parseBalancedTags(src, element);
        default:
            throw new Error(`Unknown element: ${element}`);
    }
};
/**
 * Constructs properties object from property string
 * @param element - Element type
 * @param propString - String containing properties
 * @returns Record of property names to values
 */
const constructProps$1 = (element, propString) => {
    const supportedProps = supportedPropsByElement$1[element];
    if (!supportedProps) {
        throw new Error(`Unknown element: ${element}`);
    }
    // Initialize with default values
    const props = {};
    supportedProps.forEach((prop) => {
        props[prop.name] = prop.defaultValue;
    });
    // Parse and override with actual values
    propRegex$1.lastIndex = 0;
    let propMatch;
    while ((propMatch = propRegex$1.exec(propString)) !== null) {
        const [, name, value] = propMatch;
        if (supportedProps.some((p) => p.name === name)) {
            props[name] = value;
        }
    }
    return props;
};

/**
 * Renders the tab component using a CSS-only approach (no JavaScript)
 * @param options - Rendering options
 * @param parser - Parser instance from marked.js renderer context
 * @returns HTML string for the tabs
 */
function renderTabs(options, parser) {
    const { tabsContainerId, tabsData, className, animation = 'fade', template } = options;
    // Get the tab template
    const tabsTemplate = template || DEFAULT_TEMPLATE$1;
    if (!tabsData || tabsData.length === 0) {
        return '<div class="error-message">No tab content found</div>';
    }
    let inputsNav = '';
    let navList = '';
    let markedContent = '';
    for (const tab of tabsData) {
        const { id, tokens, props } = tab;
        const { active, icon, label } = props;
        const inputId = `input-${id}`;
        const labelId = `label-${id}`;
        const isChecked = active ? 'checked' : '';
        const ariaSelected = active ? 'true' : 'false';
        const iconHtml = icon ? `<span class="marked-extended-tabs-icon">${icon}</span>` : '';
        // Inputs first
        inputsNav += `<input type="radio" name="${tabsContainerId}-tabs" id="${inputId}" class="marked-extended-tabs-input" ${isChecked}>`;
        // Navigation labels
        navList += `
      <label for="${inputId}" id="${labelId}" class="marked-extended-tabs-label" role="tab" aria-selected="${ariaSelected}" data-tab-id="${id}">
        ${iconHtml}<span class="tab-label">${label}</span>
      </label>`;
        // Render the content using the parser context which has all extensions loaded
        // This allows nested extensions to be properly rendered
        const parsedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
        // Tab content
        markedContent += `
      <div class="marked-extended-tabs-content-pane" id="${id}" role="tabpanel" aria-labelledby="${inputId}">
        ${parsedContent}
      </div>`;
    }
    const styles = createTabsStyles(tabsContainerId, tabsData, animation);
    return tabsTemplate
        .replace(/{tabsContainerId}/g, tabsContainerId)
        .replace(/{className}/g, className)
        .replace(/{animation}/g, animation)
        .replace(/{inputsNav}/g, inputsNav)
        .replace(/{navList}/g, navList)
        .replace(/{content}/g, markedContent)
        .replace(/{stylesBehavior}/g, styles);
}

/**
 * Creates a tokenizer function for the tab extension
 */
function createTokenizer$1(options) {
    const { animation, autoActivate, className, persistSelection, template } = options;
    const tabElement = 'tabBlock';
    const tabItemElement = 'tabItemBlock';
    return {
        name: 'tabs',
        level: 'block',
        tokenizer(src) {
            const blockMatch = validateRegex$1(tabElement, src);
            if (!blockMatch)
                return undefined;
            // The first position is the full match, the second is props, the third is content
            const [raw, , tabContent] = blockMatch;
            // Generate unique ID for this tab container
            const tabsContainerId = `tabs-container-${++tabCounter.value}`;
            // Find individual tabs directly in the extracted tab content
            const items = [];
            let tabIndex = 0;
            let remainingContent = tabContent;
            while (remainingContent) {
                // Skip whitespace
                remainingContent = remainingContent.trimStart();
                if (!remainingContent)
                    break;
                const tabMatch = validateRegex$1(tabItemElement, remainingContent);
                if (!tabMatch) {
                    // If we have content but it doesn't match a tab item, strictly speaking this might be invalid content 
                    // inside a tabs container, or we could just breaking to avoid infinite loop.
                    break;
                }
                const [itemRaw, propsStr, tabContentStr] = tabMatch;
                // Parse properties with defaults
                const rawProps = constructProps$1(tabItemElement, propsStr);
                // If no label is provided, use a default
                const label = rawProps['label'] || `Tab ${tabIndex + 1}`;
                // Convert string 'true'/'false' to boolean for the active property
                const active = rawProps['active'] === 'true';
                // Tokenize the tab content using this.lexer.blockTokens
                // This ensures nested extensions are properly tokenized
                const innerTokens = this.lexer.blockTokens(tabContentStr.trim());
                // Add to tabs data - include raw so it satisfies Tokens.Generic
                items.push({
                    type: 'tab-item',
                    raw: itemRaw,
                    id: `${tabsContainerId}-tab-${tabIndex}`,
                    props: {
                        label,
                        active,
                        icon: rawProps['icon'] || undefined,
                    },
                    tokens: innerTokens,
                });
                tabIndex++;
                // Advance cursor
                remainingContent = remainingContent.substring(itemRaw.length);
            }
            // If no tabs were found, return undefined
            if (items.length === 0)
                return undefined;
            // Apply auto-activation if enabled, and no tab is explicitly marked as active
            if (autoActivate) {
                const hasActiveTab = items.some((tab) => tab.props.active);
                if (!hasActiveTab && items.length > 0) {
                    items[0].props.active = true;
                }
            }
            // Create a token with metadata for the renderer
            return {
                type: 'tabs',
                raw,
                tokens: items,
                meta: {
                    tabsContainerId,
                    className,
                    persistSelection,
                    animation,
                    autoActivate,
                    template,
                },
            };
        },
    };
}
/**
 * Create the renderer extension for tabs
 */
function createRenderer$1() {
    return {
        name: 'tabs',
        renderer(token) {
            const tabsToken = token;
            // Pass meta and parser to the renderer for proper nested extension support
            return renderTabs({ ...tabsToken.meta, tabsData: tabsToken.tokens }, this.parser);
        },
    };
}

/**
 * Marked Extended Tabs extension
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedTabs(options = {}) {
    // Validate animation option
    if (options.animation && !['fade', 'slide', 'none'].includes(options.animation)) {
        console.warn(`[marked-extended-tabs] Invalid animation value: ${options.animation}. Using default 'fade'.`);
        options.animation = 'fade';
    }
    // Set sensible defaults
    const config = { ...DEFAULT_OPTIONS$2, ...options };
    // Inject styles if needed
    if (config.injectStyles)
        ensureStyles$1('marked-extended-tabs-styles', DEFAULT_STYLES$1);
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type !== 'tabs')
                return;
            // Apply custom token modifications if configured
            if (config.customizeToken && typeof config.customizeToken === 'function') {
                config.customizeToken(token);
            }
        },
        extensions: [createTokenizer$1(config), createRenderer$1()],
    };
}

const ensureStyles = (id, styles, cssVariables = {}) => {
    if (typeof window === 'undefined')
        return;
    window.__injectedStyles__ ?? (window.__injectedStyles__ = {});
    if (!window.__injectedStyles__[id]) {
        const styleEl = document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = replaceCSSVariables(styles, cssVariables);
        document.head.appendChild(styleEl);
        window.__injectedStyles__[id] = true;
    }
};
const replaceCSSVariables = (styles, cssVariables) => {
    if (!cssVariables || Object.keys(cssVariables).length === 0)
        return styles;
    return Object.entries(cssVariables).reduce((acc, [key, value]) => {
        return acc.replace(new RegExp(escapeRegExp$1(key), 'g'), value);
    }, styles);
};
const escapeRegExp$1 = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

// Counter for generating unique IDs for timeline containers
const timelineCounter = { value: 0 };
/**
 * Object representing the default configuration options for customizing
 * the appearance and behavior of the extended timeline component.
 *
 * Properties:
 * - `timelineClass` (string): The CSS class applied to the timeline container element.
 * - `eventClass` (string): The CSS class applied to each timeline event.
 * - `dateFormat` (string|null): Specifies the format for displaying dates. If null, default formatting is used.
 * - `template` (string|null): Provides a custom template for rendering timeline events. If null, a default template is used.
 * - `customizeToken` (function|null): A function for customizing or processing tokens before rendering. If null, no customization is applied.
 * - `injectStyles` (boolean): Indicates whether default styles should be injected into the document. Defaults to `true`.
 */
const DEFAULT_OPTIONS$1 = {
    timelineClass: 'marked-extended-timeline-container',
    eventClass: 'marked-extended-timeline-event',
    dateFormat: null,
    template: null,
    customizeToken: null,
    injectStyles: true,
};
/**
 * A string template used to define the default structure for rendering a timeline component.
 *
 * This template includes placeholders that can be dynamically replaced:
 * - `{timelineContainerId}`: Represents the unique ID assigned to the timeline container.
 * - `{timelineClass}`: Represents the CSS class(es) applied to the timeline container for styling.
 * - `{content}`: Placeholder for the inner content of the timeline.
 *
 * The template is designed to be flexible and customizable by replacing these placeholders
 * with specific values before use.
 */
const DEFAULT_TEMPLATE = `
<div id="{timelineContainerId}" class="{timelineClass}">
  {content}
</div>
`;
/**
 * Default structural CSS styles for timeline (minimal, layout-only).
 * Visual/theming styles are in the demo theme file.
 */
const DEFAULT_STYLES = `
.marked-extended-timeline-container { position: relative; margin: 2rem 0; padding-left: 2rem; }
.marked-extended-timeline-container .marked-extended-timeline-event { position: relative; margin-bottom: 2rem; padding-left: 1rem; }
.marked-extended-timeline-event::before { content: ''; position: absolute; width: 12px; height: 12px; left: -2.6rem; top: 0.25rem; }
.marked-extended-timeline-container .marked-extended-timeline-date { margin-bottom: 0.5rem; }
.marked-extended-timeline-container .marked-extended-timeline-content { margin-left: 0.5rem; }
.marked-extended-timeline-content h1,
.marked-extended-timeline-content h2,
.marked-extended-timeline-content h3,
.marked-extended-timeline-content h4,
.marked-extended-timeline-content h5,
.marked-extended-timeline-content h6 { margin-top: 0; }
`;

/**
 * Regular expression for parsing properties from attribute strings
 * Matches patterns like: property="value"
 */
const propRegex = /\s*(\w+)="([^"]+)"/g;
/**
 * Element patterns configuration for timeline blocks
 */
const elementPatterns = {
    timelineBlock: {
        start: '::::timeline',
        end: '::::timelineend',
        aliases: [':tml', ':timeline'],
        endAliases: [':tmlend', ':timelineend'],
    },
    timelineEventBlock: {
        start: ':::event',
        end: ':::eventend',
        aliases: [':evt', ':event'],
        endAliases: [':evtend', ':eventend'],
    },
};
/**
 * Supported properties by element type
 */
const supportedPropsByElement = {
    timelineEventBlock: [
        { name: 'date', defaultValue: '' },
        { name: 'active', defaultValue: 'false' },
    ],
};
/**
 * Escapes special regex characters in a string
 * @param str - String to escape
 * @returns Escaped string safe for use in RegExp
 */
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
/**
 * Generates regex patterns from element configuration
 * @param elementType - Type of element to generate pattern for
 * @returns Generated pattern with start and end regex strings, or null
 */
function generateRegexFromPattern(elementType) {
    const pattern = elementPatterns[elementType];
    if (!pattern)
        return null;
    const { start, end, aliases = [], endAliases = [] } = pattern;
    const startPatterns = [start, ...aliases].map((p) => escapeRegExp(p)).join('|');
    const endPatterns = [end, ...endAliases].map((p) => escapeRegExp(p)).join('|');
    return {
        startPattern: `(?:${startPatterns})`,
        endPattern: `(?:${endPatterns})`,
    };
}
// Generate regex patterns for timeline elements
const timelinePatterns = generateRegexFromPattern('timelineBlock');
const timelineEventPatterns = generateRegexFromPattern('timelineEventBlock');
/**
 * Regex for matching timeline blocks with nested events
 */
const timelineBlockRegex = timelinePatterns
    ? new RegExp(`^${timelinePatterns.startPattern}\\s*(?:\\n|$)([\\s\\S]*?)${timelinePatterns.endPattern}\\s*(?:\\n|$)`)
    : null;
/**
 * Regex for matching individual timeline event blocks
 * Exported for use in timeline tokenizer
 */
const timelineEventRegex = timelineEventPatterns
    ? new RegExp(`${timelineEventPatterns.startPattern}\\{(.*?)\\}([\\s\\S]*?)${timelineEventPatterns.endPattern}`, 'g')
    : null;
/**
 * Validates and parses element patterns from source string
 * @param element - Element type or RegExp to validate
 * @param src - Source string to parse
 * @returns RegExpExecArray or null if no match
 */
const validateRegex = (element, src) => {
    if (element instanceof RegExp) {
        return element.exec(src);
    }
    switch (element) {
        case 'timelineBlock':
            return timelineBlockRegex ? timelineBlockRegex.exec(src) : null;
        case 'timelineEventBlock':
            return timelineEventRegex ? timelineEventRegex.exec(src) : null;
        default:
            throw new Error(`Unknown element: ${element}`);
    }
};
/**
 * Constructs properties object from property string
 * @param element - Element type
 * @param propString - String containing properties
 * @returns Record of property names to values
 */
const constructProps = (element, propString) => {
    const supportedProps = supportedPropsByElement[element];
    if (!supportedProps) {
        throw new Error(`Unknown element: ${element}`);
    }
    // Initialize with default values
    const props = {};
    supportedProps.forEach((prop) => {
        props[prop.name] = prop.defaultValue;
    });
    // Parse and override with actual values
    propRegex.lastIndex = 0;
    let propMatch;
    while ((propMatch = propRegex.exec(propString)) !== null) {
        const [, name, value] = propMatch;
        if (supportedProps.some((p) => p.name === name)) {
            props[name] = value;
        }
    }
    return props;
};

/**
 * Renders a timeline token into HTML using a parser context for nested content
 */
function renderTimeline(options, parser) {
    const { timelineContainerId, events, timelineClass, eventClass, template } = options;
    // Get the timeline template
    const timelineTemplate = template || DEFAULT_TEMPLATE;
    if (!events || events.length === 0) {
        return '<div class="error-message">No timeline content found</div>';
    }
    let markedContent = '';
    // Build HTML for each timeline event
    for (const event of events) {
        const { id, props, tokens } = event;
        const { date, formattedDate, active } = props;
        const isActive = active ? 'active' : '';
        const ariaSelected = active ? 'true' : 'false';
        // Render the content using the parser context which has all extensions loaded
        // This allows nested extensions to be properly rendered
        const parsedContent = tokens && tokens.length > 0 ? parser.parse(tokens) : '';
        markedContent += `
      <div class="${eventClass} ${isActive}" id="${id}" aria-selected="${ariaSelected}">
        <div class="marked-extended-timeline-date">${formattedDate || date}</div>
        <div class="marked-extended-timeline-content">
          ${parsedContent}
        </div>
      </div>`;
    }
    // Return the complete timeline HTML
    return timelineTemplate
        .replace(/{timelineContainerId}/g, timelineContainerId)
        .replace(/{timelineClass}/g, timelineClass)
        .replace(/{content}/g, markedContent);
}

/**
 * Format a date string based on locale or custom formatter
 */
function formatDate(dateStr, formatter) {
    try {
        const date = new Date(dateStr);
        // Check if the date is valid
        if (isNaN(date.getTime())) {
            return dateStr; // Return original if invalid
        }
        // Use custom formatter if provided
        if (formatter && typeof formatter === 'function') {
            return formatter(date);
        }
        // Default formatting (locale-dependent)
        return date.toLocaleDateString();
    }
    catch (error) {
        console.warn('Error formatting date:', error);
        return dateStr; // Return original on error
    }
}
/**
 * Creates a tokenizer function for the timeline extension
 */
function createTokenizer(options) {
    const { dateFormat } = options;
    const timelineElement = 'timelineBlock';
    const timelineEventElement = 'timelineEventBlock';
    return {
        name: 'timeline',
        level: 'block',
        tokenizer(src) {
            const blockMatch = validateRegex(timelineElement, src);
            if (!blockMatch)
                return undefined;
            // The first position is the full match, the second position is the content
            const [raw, timelineContent] = blockMatch;
            // Generate unique ID for this timeline container
            const timelineContainerId = `timeline-container-${++timelineCounter.value}`;
            // Find individual timeline events
            const tokens = [];
            let eventMatch;
            let eventIndex = 0;
            // Find all timeline events in the content
            if (!timelineEventRegex)
                return undefined;
            // Process each event in the timeline
            while ((eventMatch = timelineEventRegex.exec(timelineContent)) !== null) {
                // Extract event properties and content
                const propsStr = eventMatch[1];
                const eventContentStr = eventMatch[2].trim();
                // Parse properties with defaults
                const rawProps = constructProps(timelineEventElement, propsStr);
                // If no date is provided, use a default
                const date = rawProps['date'] || `Event ${eventIndex + 1}`;
                // Format the date
                const formattedDate = formatDate(date, dateFormat);
                // Convert string 'true'/'false' to boolean for the active property
                const active = rawProps['active'] === 'true';
                // Tokenize the event content using this.lexer.blockTokens
                // This ensures nested extensions are properly tokenized
                const eventTokens = this.lexer.blockTokens(eventContentStr);
                // Add to timeline data
                tokens.push({
                    type: 'timeline-item',
                    raw: eventMatch[0],
                    id: `${timelineContainerId}-event-${eventIndex}`,
                    props: {
                        date,
                        formattedDate,
                        active,
                    },
                    tokens: eventTokens,
                });
                eventIndex++;
            }
            // If no events were found, return undefined
            if (tokens.length === 0)
                return undefined;
            // Create a token with metadata for the renderer
            return {
                type: 'timeline',
                raw,
                tokens,
                meta: {
                    timelineContainerId,
                    // events is no longer used here, we pass tokens property in the token
                    timelineClass: options.timelineClass,
                    eventClass: options.eventClass,
                    dateFormat: options.dateFormat,
                    template: options.template,
                },
            }; // Cast to satisfy mismatched meta interface if strictly checked before render
        },
    };
}
/**
 * Create the renderer extension for timeline
 */
function createRenderer() {
    return {
        name: 'timeline',
        renderer(token) {
            const timelineToken = token;
            // 'this' context is provided by marked.js and contains the parser instance
            // The parser is already configured with all user-defined extensions and renderers
            // Pass tokens as events to the renderer
            return renderTimeline({
                ...timelineToken.meta,
                events: timelineToken.tokens,
            }, this.parser);
        },
    };
}

/**
 * Marked Extended Timeline extension
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedTimeline(options = {}) {
    // Set sensible defaults
    const config = { ...DEFAULT_OPTIONS$1, ...options };
    // Inject styles if needed
    if (config.injectStyles)
        ensureStyles('marked-extended-timeline-styles', DEFAULT_STYLES);
    // Return the extension
    return {
        walkTokens(token) {
            if (token.type !== 'timeline')
                return;
            // Apply custom token modifications if configured
            if (config.customizeToken && typeof config.customizeToken === 'function') {
                config.customizeToken(token);
            }
        },
        extensions: [createTokenizer(config), createRenderer()],
    };
}

/**
 * Default options configuration for typographic processing
 */
const DEFAULT_OPTIONS = {
    quotes: false,
    dashes: false, // There's an issue while inserting CSS variables (--variable) in extension logic if enabled.
    ellipses: false,
    attribute: '3',
    customSymbols: {},
    outputUnicode: false,
};

const specialCharacters = {
    '\\(<<\\)': '«', // Left-pointing double angle quotation mark
    '\\(>>\\)': '»', // Right-pointing double angle quotation mark
    '\\(<-\\)': '←', // Left arrow
    '\\(->\\)': '→', // Right arrow
    '\\(<->\\)': '↔', // Double arrow
    '\\(<=>\\)': '⇔', // Double implies
    '\\(<==>\\)': '⇔', // Left-right double arrow
    '\\(\\=\\>\\)': '⇒', // Implies
    '\\(\\<\\=\\=\\)': '⇐', // Less than or equal to
    '\\(\\=\\=\\>\\)': '⇒', // Implies
    '\\(==\\)': '≡', // Identical to
    '\\(\\<\\)': '≪', // Much less than
    '\\(\\>\\)': '≫', // Much greater than
    '\\(\\<\\=\\)': '≦', // Less than or equal to
    '\\(\\>\\=\\)': '≧', // Greater than or equal to
    '\\(\\<\\>\\)': '≷', // Neither less than nor greater than
    '\\(\\>\\<\\)': '≸', // Neither greater than nor less than
    '\\(\\+\\-\\)': '±', // Plus-minus sign
    '\\(-\\+\\)': '∓', // Minus-plus sign
    '\\(x\\)': '×', // Multiplication sign
    '\\(/\\)': '÷', // Division sign
    '\\(=>\\)': '⇒', // Right double arrow
    '\\(<=\\)': '⇐', // Left double arrow
    '\\(^up\\)': '↑', // Up arrow
    '\\(^down\\)': '↓', // Down arrow
    '\\(^left\\)': '←', // Left arrow
    '\\(^right\\)': '→', // Right arrow
    '\\(^updown\\)': '↕', // Up-down arrow
    '\\(^leftright\\)': '↔', // Left-right arrow
    '\\(--\\)': '—', // Em dash
    '\\(---\\)': '–', // En dash
};
const logicalAndMathematicalSymbols = {
    '\\(\\+\\)': '⊕', // Direct sum
    '\\(\\-\\)': '⊖', // Direct difference
    '\\(\\*\\)': '⊗', // Tensor product
    '\\(\\|\\)': '∣', // Divides
    '\\(\\&\\)': '∧', // Logical and
    '\\(\\|\\|\\)': '∨', // Logical or
    '\\(\\!\\)': '¬', // Logical not
    '\\(\\=\\)': '≠', // Not equal
    '\\(\\~\\)': '≈', // Approximately equal
    '\\(\\^\\)': '∧', // Logical and
    '\\(\\%\\)': '‰', // Per mille
    '\\(\\#\\)': '№', // Numero sign
    '\\(\\@\\)': '⊕', // Circled plus
    '\\(\\$\\)': '¤', // Currency sign
    '\\(sum\\)': '∑', // Summation
    '\\(prod\\)': '∏', // Product
    '\\(sqrt\\)': '√', // Square root
    '\\(cbrt\\)': '∛', // Cube root
    '\\(inf\\)': '∞', // Infinity
    '\\(integral\\)': '∫', // Integral
    '\\(partial\\)': '∂', // Partial differential
    '\\(empty\\)': '∅', // Empty set
    '\\(in\\)': '∈', // Element of
    '\\(notin\\)': '∉', // Not an element of
    '\\(subset\\)': '⊂', // Subset of
    '\\(subseteq\\)': '⊆', // Subset of or equal to
    '\\(nsubset\\)': '⊄', // Not a subset of
    '\\(nsubseteq\\)': '⊈', // Not a subset of or equal to
    '\\(superset\\)': '⊃', // Superset of
    '\\(nsuperset\\)': '⊅', // Not a superset of
    '\\(union\\)': '∪', // Union
    '\\(intersect\\)': '∩', // Intersection
    '\\(forall\\)': '∀', // For all
    '\\(exists\\)': '∃', // There exists
    '\\(nexists\\)': '∄', // There does not exist
};
const typographicSymbols = {
    '\\(C\\^\\)': '©',
    '\\(c\\^\\)': '©',
    '\\(R\\^\\)': '®',
    '\\(r\\^\\)': '®',
    '\\(TM\\^\\)': '™',
    '\\(tm\\^\\)': '™',
    '\\(P\\^\\)': '℗',
    '\\(p\\^\\)': '℗',
    '\\(S\\^\\)': '§',
    '\\(s\\^\\)': '§',
    '\\(D\\^\\)': '†',
    '\\(d\\^\\)': '†',
    '\\(DD\\^\\)': '‡',
    '\\(dd\\^\\)': '‡',
    '\\(P\\*\\)': '¶',
    '\\(p\\*\\)': '¶',
    '\\(euro\\)': '€', // Euro symbol
    '\\(pound\\)': '£', // Pound symbol
    '\\(yen\\)': '¥', // Yen symbol
    '\\(cent\\)': '¢', // Cent symbol
    '\\(colon\\)': '₵', // CRC symbol
    '\\(degree\\)': '°', // Degree symbol
    '\\(micro\\)': 'µ', // Micro symbol
    '\\(middledot\\)': '·', // Middle dot
    '\\(bullet\\)': '•', // Bullet
    '\\(nbsp\\)': ' ', // Non-breaking space
    '\\(endash\\)': '–', // En dash
    '\\(emdash\\)': '—', // Em dash
};
const greekLetters = {
    '\\(Alpha\\)': 'Α',
    '\\(alpha\\)': 'α',
    '\\(Beta\\)': 'Β',
    '\\(beta\\)': 'β',
    '\\(Gamma\\)': 'Γ',
    '\\(gamma\\)': 'γ',
    '\\(Delta\\)': 'Δ',
    '\\(delta\\)': 'δ',
    '\\(Epsilon\\)': 'Ε',
    '\\(epsilon\\)': 'ε',
    '\\(Zeta\\)': 'Ζ',
    '\\(zeta\\)': 'ζ',
    '\\(Eta\\)': 'Η',
    '\\(eta\\)': 'η',
    '\\(Iota\\)': 'Ι',
    '\\(iota\\)': 'ι',
    '\\(Kappa\\)': 'Κ',
    '\\(kappa\\)': 'κ',
    '\\(Lambda\\)': 'Λ',
    '\\(lambda\\)': 'λ',
    '\\(Mu\\)': 'Μ',
    '\\(mu\\)': 'μ',
    '\\(Nabla\\)': '∇',
    '\\(nabla\\)': '∇',
    '\\(Nu\\)': 'Ν',
    '\\(nu\\)': 'ν',
    '\\(Xi\\)': 'Ξ',
    '\\(xi\\)': 'ξ',
    '\\(Omicron\\)': 'Ο',
    '\\(omicron\\)': 'ο',
    '\\(Pi\\)': 'Π',
    '\\(pi\\)': 'π',
    '\\(Rho\\)': 'Ρ',
    '\\(rho\\)': 'ρ',
    '\\(Sigma\\)': 'Σ',
    '\\(sigma\\)': 'σ',
    '\\(Tau\\)': 'Τ',
    '\\(tau\\)': 'τ',
    '\\(Upsilon\\)': 'Υ',
    '\\(upsilon\\)': 'υ',
    '\\(Phi\\)': 'Φ',
    '\\(phi\\)': 'φ',
    '\\(Chi\\)': 'Χ',
    '\\(chi\\)': 'χ',
    '\\(Psi\\)': 'Ψ',
    '\\(psi\\)': 'ψ',
    '\\(Omega\\)': 'Ω',
    '\\(omega\\)': 'ω',
    '\\(Theta\\)': 'Θ',
    '\\(theta\\)': 'θ',
};
const emojiSymbols = {
    '\\(check\\)': '✅', // Check mark
    '\\(cross\\)': '❌', // Cross mark
    '\\(warning\\)': '⚠️', // Warning sign
    '\\(info\\)': 'ℹ️', // Information symbol
    '\\(star\\)': '⭐', // Black star
    '\\(phone\\)': '☎️', // Telephone symbol
    '\\(mail\\)': '✉️', // Envelope
    '\\(music\\)': '🎵', // Musical note
    '\\(sunny\\)': '☀️', // Sun
    '\\(cloud\\)': '☁️', // Cloud
    '\\(umbrella\\)': '☂️', // Umbrella
    '\\(snowflake\\)': '❄️', // Snowflake
    '\\(recycle\\)': '♻️', // Recycling symbol
    '\\(heart\\)': '❤️', // Heart
    '\\(brokenheart\\)': '💔', // Broken heart
    '\\(fire\\)': '🔥', // Fire
    '\\(water\\)': '💧', // Water droplet
    '\\(flag\\)': '🚩', // Triangular flag
    '\\(thumbsup\\)': '👍', // Thumbs up
    '\\(thumbsdown\\)': '👎', // Thumbs down
    '\\(clap\\)': '👏', // Clapping hands
    '\\(wave\\)': '👋', // Waving hand
    '\\(smile\\)': '😊', // Smiling face
    '\\(sad\\)': '😢', // Sad face
    '\\(angry\\)': '😠', // Angry face
    '\\(laugh\\)': '😂', // Laughing face
    '\\(wink\\)': '😉', // Winking face
    '\\(kiss\\)': '😘', // Kissing face
    '\\(surprised\\)': '😲', // Surprised face
    '\\(clock\\)': '🕒', // Clock
    '\\(calendar\\)': '📅', // Calendar
    '\\(gear\\)': '⚙️', // Gear
    '\\(link\\)': '🔗', // Link
    '\\(lock\\)': '🔒', // Lock
    '\\(unlock\\)': '🔓', // Unlock
};
const symbolMappings = {
    ...specialCharacters,
    ...logicalAndMathematicalSymbols,
    ...typographicSymbols,
    ...greekLetters,
    ...emojiSymbols,
};

const processCache = new Map();
const MAX_CACHE_SIZE = 1000;
const tags_to_skip = /<(\/?)(?:pre|code|kbd|script|math)[^>]*>/i;
/**
 * Validate the type of the attribute and normalize it to a string
 * @param attr {string|number} Attribute
 * @return {string|*} Normalized attribute
 */
const attrType = (attr) => {
    return typeof attr === 'number' ? attr.toString() : String(attr).replace(/\s/g, '');
};
/**
 * Main entry point for processing text with typographic enhancements
 * Handles caching to improve performance for repeated text
 *
 * @param {Object} options - Configuration options
 * @param {string} [options.html=''] - HTML text to process
 * @param {string|number} [options.attribute='2'] - Typography style attribute
 * @param {Object} [options.customSymbols={}] - Custom symbol replacement mappings
 * @param {boolean} [options.outputUnicode=false] - Whether to output Unicode characters instead of HTML entities
 * @return {string} Processed HTML with typographic enhancements
 */
const SmartProcess = (options = {}) => {
    const { html = '', attribute = '2', customSymbols = {} } = options;
    if (!html)
        return html;
    // Generate a cache key based on text content and configuration
    const cacheKey = `${html}:${attribute}:${Object.keys(customSymbols).length}`;
    // Return the cached result if available
    if (processCache.has(cacheKey)) {
        return processCache.get(cacheKey);
    }
    // Process text as before
    const result = SmartPants(options);
    // Manage cache size
    if (processCache.size >= MAX_CACHE_SIZE) {
        // Remove the oldest entry when the cache gets too large
        const firstKey = processCache.keys().next().value;
        if (firstKey) {
            processCache.delete(firstKey);
        }
    }
    // Store result in cache
    processCache.set(cacheKey, result);
    return result;
};
/**
 * Core typographic processing function that handles all typographic transformations
 *
 * @param {Object} options - Configuration options
 * @param {string} [options.html=''] - HTML text to process
 * @param {string|number} [options.attribute='2'] - Typography style attribute
 * @param {Object} [options.customSymbols={}] - Custom symbol replacement mappings
 * @param {boolean} [options.outputUnicode=false] - Whether to output Unicode characters instead of HTML entities
 * @return {string} Processed HTML with all requested typographic enhancements
 */
const SmartPants = (options = {}) => {
    const { html = '', attribute = '2', customSymbols = {}, outputUnicode = false, // New parameter to control an output format
     } = options;
    // Combine built-in symbols with custom symbols
    const allReplacements = {
        ...symbolMappings,
        ...customSymbols,
    };
    // Normalize the attr input
    const attr = attrType(attribute);
    // Initialize flags
    const smartyOptions = {
        quotes: 0,
        backticks: 0,
        dashes: 0,
        ellipses: 0,
        stupefy: 0,
        convert_quot: 0,
    };
    // Parse the attribute settings
    const parseAttr = (attr) => {
        const configMap = {
            '0': () => {
                /* Do nothing */
            },
            '1': () => {
                smartyOptions.quotes = 1;
                smartyOptions.backticks = 1;
                smartyOptions.dashes = 1;
                smartyOptions.ellipses = 1;
            },
            '2': () => {
                smartyOptions.quotes = 1;
                smartyOptions.backticks = 1;
                smartyOptions.dashes = 2;
                smartyOptions.ellipses = 1;
            },
            '3': () => {
                smartyOptions.quotes = 1;
                smartyOptions.backticks = 1;
                smartyOptions.dashes = 3;
                smartyOptions.ellipses = 1;
            },
            '-1': () => {
                smartyOptions.stupefy = 1;
            }, // Special "stupefy" mode
        };
        // If attr is one of the predefined values, execute the associated function
        if (configMap[attr]) {
            configMap[attr]();
        }
        else {
            // For custom attributes (q, b, d, etc.), set respective flags
            for (const c of attr) {
                switch (c) {
                    case 'q':
                        smartyOptions.quotes = 1;
                        break;
                    case 'b':
                        smartyOptions.backticks = 1;
                        break;
                    case 'B':
                        smartyOptions.backticks = 2;
                        break;
                    case 'd':
                        smartyOptions.dashes = 1;
                        break;
                    case 'D':
                        smartyOptions.dashes = 2;
                        break;
                    case 'i':
                        smartyOptions.dashes = 3;
                        break;
                    case 'e':
                        smartyOptions.ellipses = 1;
                        break;
                    case 'w':
                        smartyOptions.convert_quot = 1;
                        break;
                }
            }
        }
    };
    parseAttr(attr);
    const tokens = _tokenize(html);
    let result = '';
    let in_pre = false;
    let prev_token_last_char = '';
    // Process each token
    tokens.forEach((cur_token) => {
        if (cur_token[0] === 'tag') {
            result += cur_token[1];
            const matched = tags_to_skip.exec(cur_token[1]);
            if (matched)
                in_pre = matched[1] !== '/';
        }
        else {
            let t = cur_token[1];
            const last_char = t.slice(-1); // Last char before processing
            if (!in_pre) {
                t = ProcessEscapes(t);
                if (smartyOptions.convert_quot) {
                    t = t.replace(/$quot;/g, '"');
                }
                // Apply custom replacements
                for (const [key, value] of Object.entries(allReplacements)) {
                    t = t.replace(new RegExp(key, 'g'), String(value));
                }
                // Handle dashes
                if (smartyOptions.dashes) {
                    switch (smartyOptions.dashes) {
                        case 1:
                            t = EducateDashes(t);
                            break;
                        case 2:
                            t = EducateDashesOldSchool(t);
                            break;
                        case 3:
                            t = EducateDashesOldSchoolInverted(t);
                            break;
                    }
                }
                // Handle ellipses
                if (smartyOptions.ellipses)
                    t = EducateEllipses(t);
                // Handle backticks
                if (smartyOptions.backticks) {
                    t = EducateBackticks(t);
                    if (smartyOptions.backticks === 2)
                        t = EducateSingleBackticks(t);
                }
                // Handle quotes
                if (smartyOptions.quotes) {
                    t =
                        t === '\''
                            ? /\S/.test(prev_token_last_char)
                                ? '&#8217;'
                                : '&#8216;'
                            : t === '"'
                                ? /\S/.test(prev_token_last_char)
                                    ? '&#8221;'
                                    : '&#8220;'
                                : EducateQuotes(t);
                }
                // Special "stupefy" mode
                if (smartyOptions.stupefy)
                    t = StupefyEntities(t);
            }
            prev_token_last_char = last_char;
            result += t;
        }
    });
    // Apply unicode conversion if requested
    if (outputUnicode && attr !== '-1') {
        return EducateEntities(result, attr);
    }
    else if (outputUnicode && attr === '-1') {
        return StupefyUTF8Char(result);
    }
    return result;
};
/**
 * Transforms straight quotes into curly quotes while preserving HTML structure
 *
 * @param {Object} options - Configuration options
 * @param {string} [options.html=''] - HTML text to process
 * @param {string|number} [options.attribute='2'] - Typography style attribute
 * @return {string} Processed HTML with smart quotes
 */
const SmartQuotes = (options = {}) => {
    let { html = '' } = options;
    const { attribute = '2' } = options;
    // Normalize the 'attr' value to string and remove spaces if any
    const attr = attrType(attribute);
    // If 'attr' is '0', do nothing and return the text immediately
    if (attr === '0')
        return html;
    // Special case: if text ends with a quote preceded by an HTML tag, add space for context
    let addExtraSpace = false;
    if (/>['"]$/.test(html)) {
        addExtraSpace = true;
        html = html + ' '; // Add space for quote education context
    }
    // Tokenize the text (assuming _tokenize is defined elsewhere)
    const tokens = _tokenize(html);
    let result = '';
    let inPreTag = false; // To track whether we're inside <pre>, <code>, etc.
    let prevTokenLastChar = ''; // To remember the last character of the previous token for context
    // Process each token
    for (const curToken of tokens) {
        if (curToken[0] === 'tag') {
            // If it's an HTML tag, handle it
            result += curToken[1];
            // Check if we're inside <pre>, <code>, or similar tags
            const matched = tags_to_skip.exec(curToken[1]);
            if (matched)
                inPreTag = matched[1] === '/'; // If it's a closing tag, set inPreTag to false
        }
        else {
            // Regular text token
            let tokenText = curToken[1];
            const lastChar = tokenText.charAt(tokenText.length - 1);
            if (!inPreTag) {
                // Process escapes in the text
                tokenText = ProcessEscapes(tokenText);
                // Special handling for single-character quotes
                tokenText =
                    tokenText === '\''
                        ? /\S/.test(prevTokenLastChar)
                            ? '&#8217;'
                            : '&#8216;'
                        : tokenText === '"'
                            ? /\S/.test(prevTokenLastChar)
                                ? '&#8221;'
                                : '&#8220;'
                            : EducateQuotes(tokenText);
            }
            // Update the context for the next token
            prevTokenLastChar = lastChar;
            // Add the processed token text to the result
            result += tokenText;
        }
    }
    // If we added an extra space at the end, remove it
    if (addExtraSpace)
        result = result.replace(/ $/, '');
    return result;
};
/**
 * Transforms hyphens into proper en-dashes and em-dashes while preserving the HTML structure
 */
const SmartDashes = (options = {}) => {
    const { html = '', attribute = '2' } = options;
    // Default to EducateDashes for dash education
    let dashSubRef = EducateDashes;
    // Normalize 'attr' to a string and remove spaces
    const attr = attrType(attribute);
    // Handle special attributes
    if (attr === '0')
        return html; // Do nothing
    if (attr === '2')
        dashSubRef = EducateDashesOldSchool; // Use old smart dash shortcuts: "--" for en, "---" for em
    if (attr === '3')
        dashSubRef = EducateDashesOldSchoolInverted; // Inverse of 2: "--" for em, "---" for en
    // Tokenize the input text
    const tokens = _tokenize(html);
    const result = []; // Use an array to collect the result
    // Track whether we are inside <pre> or <code> tags
    let insidePreTag = false;
    // Process each token
    for (const curToken of tokens) {
        if (curToken[0] === 'tag') {
            // Handle HTML tags
            result.push(curToken[1]);
            // Check if we're inside a <pre> or <code> tag
            const matched = tags_to_skip.exec(curToken[1]);
            if (matched)
                insidePreTag = matched[1] !== '/'; // If it's not a closing tag, we're inside
        }
        else {
            let tokenText = curToken[1];
            if (!insidePreTag) {
                tokenText = ProcessEscapes(tokenText); // Process escape sequences
                tokenText = dashSubRef(tokenText); // Apply dash education
            }
            // Add the processed token to the result
            result.push(tokenText);
        }
    }
    // Join the result array into a single string and return it
    return result.join('');
};
/**
 * Transforms sequences of dots into proper ellipses while preserving HTML structure
 */
const SmartEllipses = (options = {}) => {
    const { html = '', attribute = '2' } = options;
    // Normalize 'attr' to a string and remove spaces
    const attr = attrType(attribute);
    // If 'attr' is '0', do nothing and return the text unchanged
    if (attr === '0')
        return html;
    // Tokenize the input text
    const tokens = _tokenize(html);
    const result = []; // Use an array to collect the result
    // Track whether we are inside <pre> or <code> tags
    let insidePreTag = false;
    // Process each token
    for (const curToken of tokens) {
        if (curToken[0] === 'tag') {
            // Handle HTML tags
            result.push(curToken[1]);
            // Check if we're inside a <pre> or <code> tag
            const matched = tags_to_skip.exec(curToken[1]);
            if (matched)
                insidePreTag = matched[1] !== '/'; // If it's not a closing tag, we're inside
        }
        else {
            let tokenText = curToken[1];
            if (!insidePreTag) {
                tokenText = ProcessEscapes(tokenText); // Process escape sequences
                tokenText = EducateEllipses(tokenText); // Apply ellipsis education
            }
            // Add the processed token to the result
            result.push(tokenText);
        }
    }
    // Join the result array into a single string and return it
    return result.join('');
};
/**
 * Educates quotes by converting them to curly quote HTML entities
 *
 * Example input: "Isn't this fun?"
 * Example output: &#8220;Isn&#8217;t this fun?&#8221;
 */
const EducateQuotes = (str) => {
    /**
     * Make our own "punctuation" character class because the POSIX style
     * [:PUNT:] is only available in Perl 5.6 or later:
     *
     * JavaScript doesn't have a punctuation class neither.
     */
    const punct_class = '[!"#\$\%\'()*+,-./:;<=>?\@\[\\\]\^_`{|}~]';
    /**
     * Special case if the very first character is a quote
     * followed by punctuation at a non-word-break. Close the quotes by brute force:
     */
    str = str.replace(new RegExp(`^'(?=${punct_class}\\B)`), '&#8217;');
    str = str.replace(new RegExp(`^"(?=${punct_class}\\B)`), '&#8221;');
    /**
     * Special case for double sets of quotes, e.g.:
     *   <p>He said, "'Quoted' words in a larger quote."</p>
     */
    str = str.replace(/"'(?=\w)/, '&#8220;&#8216;');
    str = str.replace(/'"(?=\w)/, '&#8216;&#8220;');
    /**
     * Special case for decade abbreviations (the '80s):
     */
    str = str.replace(/'(?=\d\d)/, '&#8217;');
    const close_class = '[^\\ \\t\\r\\n\\[\\{\\(\\-]';
    const not_close_class = '[\\ \\t\\r\\n\\[\\{\\(\\-]';
    const dec_dashes = '&#8211;|&#8212;';
    /**
     * Get most opening single quotes
     */
    str = str.replace(new RegExp(`(\\s|&nbsp;|--|&[mn]dash;|${dec_dashes}|&#x201[34])'(?=\\w)`, 'g'), '\$1&#8216;');
    /**
     * Single closing quotes
     */
    str = str.replace(new RegExp(`(${close_class})'`, 'g'), '\$1&#8217;');
    str = str.replace(new RegExp(`(${not_close_class}?)'(?=\\s|s\\b)`, 'g'), '\$1&#8217;');
    /**
     * Any remaining single quotes should be opening ones:
     */
    str = str.replace(/'/g, '&#8216;');
    /**
     * Get most opening double quotes
     */
    str = str.replace(new RegExp(`(\\s|&nbsp;|--|&[mn]dash;|${dec_dashes}|&#x201[34])"(?=\\w)`, 'g'), '\$1&#8220;');
    /**
     * Double closing quotes:
     * s {
     *     ($close_class)?
     *     "
     *     (?(1)|(?=\s)) # If $ 1 is captured, then do nothing;
     *                        # if not, then make sure the next char is whitespace.
     * } {$1&#8221;}xg;
     */
    str = str.replace(new RegExp(`(${close_class})"`, 'g'), '\$1&#8221;');
    str = str.replace(new RegExp(`(${not_close_class}?)"(?=\\s)`, 'g'), '\$1&#8221;');
    /**
     * Any remaining quotes should be opening ones.
     */
    str = str.replace(/"/g, '&#8220;');
    return str;
};
/**
 * @param {string} str String
 * @return {string} The string, with ``backticks'' style double quotes
 *                  translated into HTML curly quote entities.
 *
 * Example input: ``Isn't this fun?''
 * Example output: &#8220;Isn't this fun?&#8221;
 */
const EducateBackticks = (str) => str.replace(/``/g, '&#8220;').replace(/''/g, '&#8221;');
/**
 * @param {string} str String
 * @return {string} The string, with `backticks' style single quotes
 *                  translated into HTML curly quote entities.
 *
 * Example input: `Isn't this fun?'
 * Example output: &#8216;Isn&#8217;t this fun?&#8217;
 */
const EducateSingleBackticks = (str) => str.replace(/`/g, '&#8216;').replace(/'/g, '&#8217;');
/**
 * @param {string} str String
 * @return {string} The string, with each instance of "--" translated to
 *                  an em-dash HTML entity.
 */
const EducateDashes = (str) => str.replace(/--/g, '&#8212;');
/**
 * @param {string} str String
 * @return {string} The string, with each instance of "--" translated to
 *                  an en-dash HTML entity, and each "---" translated to
 *                  an em-dash HTML entity.
 */
const EducateDashesOldSchool = (str) => str.replace(/---/g, '&#8212;').replace(/--/g, '&#8211;');
/**
 * @param {string} str String
 * @return {string} The string, with each instance of "--" translated to
 *                  an em-dash HTML entity, and each "---" translated to
 *                  an en-dash HTML entity. Two reasons why: First, unlike the
 *                  en- and em-dash syntax supported by
 *                  EducateDashesOldSchool(), it's compatible with existing
 *                  entries written before SmartyPants 1.1, back when "--" was
 *                  only used for em-dashes.  Second, em-dashes are more
 *                  common than en-dashes, and so it sort of makes sense that
 *                  the shortcut should be shorter to type. (Thanks to Aaron
 *                  Swartz for the idea.)
 */
const EducateDashesOldSchoolInverted = (str) => str.replace(/---/g, '&#8211;').replace(/--/g, '&#8212;');
/**
 * @param {string} str String
 * @return {string} The string, with each instance of "..." translated to
 *                  an ellipsis HTML entity. Also converts the case where
 *                  there are spaces between the dots.
 *
 * Example input: Huh...?
 * Example output: Huh&#8230;?
 */
const EducateEllipses = (str) => str.replace(/\.\.\./g, '&#8230;').replace(/\. \. \./g, '&#8230;');
/**
 * @param {string} str String
 * @return {string} The string, with each SmartyPants HTML entity translated to
 *                  its ASCII counterpart.
 *
 * Example input: &#8220;Hello &#8212; world.&#8221;
 * Example output: "Hello -- world."
 */
const StupefyEntities = (str) => {
    const entityMap = {
        '&#8211;': '-',
        '&#8212;': '--',
        '&#8216;': '\'',
        '&#8217;': '\'',
        '&#8220;': '"',
        '&#8221;': '"',
        '&#8230;': '...',
    };
    return Object.keys(entityMap).reduce((acc, entity) => {
        return acc.replace(new RegExp(entity, 'g'), entityMap[entity]);
    }, str);
};
/**
 * @return {string} The string, with each SmartyPants HTML entity translated to
 *                  UTF-8 characters.
 *
 * Example input: “Hello &#8217; world.”
 * Example output: "Hello — world."
 * @param text
 * @param attr
 */
const EducateEntities = (text, attr = '1') => {
    let do_quotes;
    let do_backticks;
    let do_dashes;
    let do_ellipses;
    // var do_stupefy:number;
    attr = attrType(attr);
    if (attr === '0')
        return text; // Do nothing
    if (attr === '1') {
        // Do everything, turn all options on.
        do_quotes = 1;
        do_backticks = 1;
        do_dashes = 1;
        do_ellipses = 1;
    }
    if (attr === '2') {
        // Do everything, turn all options on, use old school dash shorthand.
        do_quotes = 1;
        do_backticks = 1;
        do_dashes = 3;
        do_ellipses = 1;
    }
    if (attr === '3') {
        // Do everything, turn all options on, use inverted old school dash shorthand.
        do_quotes = 1;
        do_backticks = 1;
        do_dashes = 3;
        do_ellipses = 1;
        // } else if (attr === '-1') {
        //   // Special "stupefy" mode.
        //   do_stupefy = 1;
    }
    else {
        for (const c of attr) {
            if (c === 'q') {
                do_quotes = 1;
            }
            if (c === 'b') {
                do_backticks = 1;
            }
            if (c === 'B') {
                do_backticks = 2;
            }
            if (c === 'd') {
                do_dashes = 1;
            }
            if (c === 'D') {
                do_dashes = 2;
            }
            if (c === 'i') {
                do_dashes = 3;
            }
            if (c === 'e') {
                do_ellipses = 1;
            }
        }
    }
    if (do_dashes) {
        text = text.replace(/&#8211;/g, '\u2013'); // en-dash
        text = text.replace(/&#8212;/g, '\u2014'); // em-dash
    }
    if (do_quotes || do_backticks) {
        text = text.replace(/&#8216;/g, '\u2018'); // open a single quote
        text = text.replace(/&#8217;/g, '\u2019'); // close single quote
        text = text.replace(/&#8220;/g, '\u201c'); // open double quote
        text = text.replace(/&#8221;/g, '\u201d'); // close double quote
    }
    if (do_ellipses)
        text = text.replace(/&#8230;/g, '\u2026'); // ellipsis
    return text;
};
/**
 * @param {string} str String
 * @return {string} The string, with each SmartyPants UTF-8 chars translated to
 *                  its ASCII counterpart.
 *
 * Example input: &#8220;Hello &#8212; world.&#8221;
 * Example output: "Hello -- world."
 */
const StupefyUTF8Char = (str) => {
    str = str.replace(/\u2013/g, '-'); // en-dash
    str = str.replace(/\u2014/g, '--'); // em-dash
    str = str.replace(/\u2018/g, '\''); // open a single quote
    str = str.replace(/\u2019/g, '\''); // close single quote
    str = str.replace(/\u201c/g, '"'); // open double quote
    str = str.replace(/\u201d/g, '"'); // close double quote
    str = str.replace(/\u2026/g, '...'); // ellipsis
    return str;
};
/**
 * @param {string} str String
 * @return {string} string, with after processing the following backslash
 *                  escape sequences. This is useful if you want to force a "dumb"
 *                  quote or other character to appear.
 *
 *                  Escape Value
 *                  ------  -----
 *                  \\      &#92;
 *                  \"      &#34;
 *                  \'      &#39;
 *                  \.      &#46;
 *                  \-      &#45;
 *                  \`      &#96;
 *
 */
const ProcessEscapes = (str) => {
    str = str.replace(/\\\\/g, '&#92;');
    str = str.replace(/\\"/g, '&#34;');
    str = str.replace(/\\'/g, '&#39;');
    str = str.replace(/\\\./g, '&#46;');
    str = str.replace(/\\-/g, '&#45;');
    str = str.replace(/\\`/g, '&#96;');
    return str;
};
/**
 * @param {string} str String containing HTML markup.
 * @return {Array<Array<string>>} Reference to an array of the tokens comprising the input
 *                        string. Each token is either a tag (possibly with nested
 *                        tags contained therein, such as <a href="<MTFoo>">, or a
 *                        run of text between tags. Each element of the array is a
 *                        two-element array; the first is either 'tag' or 'text';
 *                        the second is the actual value.
 *
 * Based on the _tokenize() subroutine from Brad Choate's MTRegex plugin.
 *     <http://www.bradchoate.com/past/mtregex.php>
 */
const _tokenize = (str) => {
    const tokens = [];
    const match = /<!--[\s\S]*?-->|<\?.*?\?>|<[^>]*>/g;
    let pos = 0;
    let matched;
    while ((matched = match.exec(str))) {
        if (pos < matched.index)
            tokens.push(['text', str.substring(pos, matched.index)]);
        tokens.push(['tag', matched[0]]);
        pos = match.lastIndex;
    }
    if (pos < str.length)
        tokens.push(['text', str.substring(pos)]);
    return tokens;
};

/**
 * Marked Extended Typographic extension
 * @param options - Configuration options
 * @returns Marked extension object
 */
function markedExtendedTypographic(options = {}) {
    const config = { ...DEFAULT_OPTIONS, ...options };
    return {
        tokenizer: {
            inlineText(src) {
                // don't escape inlineText
                const cap = this.rules.inline.text.exec(src);
                /* istanbul ignore next */
                if (!cap)
                    return undefined;
                return {
                    type: 'text',
                    raw: cap[0],
                    text: cap[0],
                };
            },
        },
        hooks: {
            postprocess(html) {
                try {
                    // Apply only the transformations that were requested
                    let result = html;
                    // Apply custom symbols first
                    result = SmartProcess({ html: result, ...config });
                    // Apply requested transformations in sequence
                    if (config.quotes)
                        result = SmartQuotes({ html: result, ...config });
                    if (config.dashes)
                        result = SmartDashes({ html: result, ...config });
                    if (config.ellipses)
                        result = SmartEllipses({ html: result, ...config });
                    return result;
                }
                catch (error) {
                    console.warn('Error in marked-extended-typographic:', error);
                    // Return original HTML on error for graceful fallback
                    return html;
                }
            },
        },
    };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var prism = {exports: {}};

var hasRequiredPrism;

function requirePrism () {
	if (hasRequiredPrism) return prism.exports;
	hasRequiredPrism = 1;
	(function (module) {
		/* **********************************************
		     Begin prism-core.js
		********************************************** */

		/// <reference lib="WebWorker"/>

		var _self = (typeof window !== 'undefined')
			? window   // if in browser
			: (
				(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
					? self // if in worker
					: {}   // if in node js
			);

		/**
		 * Prism: Lightweight, robust, elegant syntax highlighting
		 *
		 * @license MIT <https://opensource.org/licenses/MIT>
		 * @author Lea Verou <https://lea.verou.me>
		 * @namespace
		 * @public
		 */
		var Prism = (function (_self) {

			// Private helper vars
			var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
			var uniqueId = 0;

			// The grammar object for plaintext
			var plainTextGrammar = {};


			var _ = {
				/**
				 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
				 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
				 * additional languages or plugins yourself.
				 *
				 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
				 *
				 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
				 * empty Prism object into the global scope before loading the Prism script like this:
				 *
				 * ```js
				 * window.Prism = window.Prism || {};
				 * Prism.manual = true;
				 * // add a new <script> to load Prism's script
				 * ```
				 *
				 * @default false
				 * @type {boolean}
				 * @memberof Prism
				 * @public
				 */
				manual: _self.Prism && _self.Prism.manual,
				/**
				 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
				 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
				 * own worker, you don't want it to do this.
				 *
				 * By setting this value to `true`, Prism will not add its own listeners to the worker.
				 *
				 * You obviously have to change this value before Prism executes. To do this, you can add an
				 * empty Prism object into the global scope before loading the Prism script like this:
				 *
				 * ```js
				 * window.Prism = window.Prism || {};
				 * Prism.disableWorkerMessageHandler = true;
				 * // Load Prism's script
				 * ```
				 *
				 * @default false
				 * @type {boolean}
				 * @memberof Prism
				 * @public
				 */
				disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

				/**
				 * A namespace for utility methods.
				 *
				 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
				 * change or disappear at any time.
				 *
				 * @namespace
				 * @memberof Prism
				 */
				util: {
					encode: function encode(tokens) {
						if (tokens instanceof Token) {
							return new Token(tokens.type, encode(tokens.content), tokens.alias);
						} else if (Array.isArray(tokens)) {
							return tokens.map(encode);
						} else {
							return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
						}
					},

					/**
					 * Returns the name of the type of the given value.
					 *
					 * @param {any} o
					 * @returns {string}
					 * @example
					 * type(null)      === 'Null'
					 * type(undefined) === 'Undefined'
					 * type(123)       === 'Number'
					 * type('foo')     === 'String'
					 * type(true)      === 'Boolean'
					 * type([1, 2])    === 'Array'
					 * type({})        === 'Object'
					 * type(String)    === 'Function'
					 * type(/abc+/)    === 'RegExp'
					 */
					type: function (o) {
						return Object.prototype.toString.call(o).slice(8, -1);
					},

					/**
					 * Returns a unique number for the given object. Later calls will still return the same number.
					 *
					 * @param {Object} obj
					 * @returns {number}
					 */
					objId: function (obj) {
						if (!obj['__id']) {
							Object.defineProperty(obj, '__id', { value: ++uniqueId });
						}
						return obj['__id'];
					},

					/**
					 * Creates a deep clone of the given object.
					 *
					 * The main intended use of this function is to clone language definitions.
					 *
					 * @param {T} o
					 * @param {Record<number, any>} [visited]
					 * @returns {T}
					 * @template T
					 */
					clone: function deepClone(o, visited) {
						visited = visited || {};

						var clone; var id;
						switch (_.util.type(o)) {
							case 'Object':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = /** @type {Record<string, any>} */ ({});
								visited[id] = clone;

								for (var key in o) {
									if (o.hasOwnProperty(key)) {
										clone[key] = deepClone(o[key], visited);
									}
								}

								return /** @type {any} */ (clone);

							case 'Array':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = [];
								visited[id] = clone;

								(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
									clone[i] = deepClone(v, visited);
								});

								return /** @type {any} */ (clone);

							default:
								return o;
						}
					},

					/**
					 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
					 *
					 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
					 *
					 * @param {Element} element
					 * @returns {string}
					 */
					getLanguage: function (element) {
						while (element) {
							var m = lang.exec(element.className);
							if (m) {
								return m[1].toLowerCase();
							}
							element = element.parentElement;
						}
						return 'none';
					},

					/**
					 * Sets the Prism `language-xxxx` class of the given element.
					 *
					 * @param {Element} element
					 * @param {string} language
					 * @returns {void}
					 */
					setLanguage: function (element, language) {
						// remove all `language-xxxx` classes
						// (this might leave behind a leading space)
						element.className = element.className.replace(RegExp(lang, 'gi'), '');

						// add the new `language-xxxx` class
						// (using `classList` will automatically clean up spaces for us)
						element.classList.add('language-' + language);
					},

					/**
					 * Returns the script element that is currently executing.
					 *
					 * This does __not__ work for line script element.
					 *
					 * @returns {HTMLScriptElement | null}
					 */
					currentScript: function () {
						if (typeof document === 'undefined') {
							return null;
						}
						if (document.currentScript && document.currentScript.tagName === 'SCRIPT' && 1 < 2 /* hack to trip TS' flow analysis */) {
							return /** @type {any} */ (document.currentScript);
						}

						// IE11 workaround
						// we'll get the src of the current script by parsing IE11's error stack trace
						// this will not work for inline scripts

						try {
							throw new Error();
						} catch (err) {
							// Get file src url from stack. Specifically works with the format of stack traces in IE.
							// A stack will look like this:
							//
							// Error
							//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
							//    at Global code (http://localhost/components/prism-core.js:606:1)

							var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
							if (src) {
								var scripts = document.getElementsByTagName('script');
								for (var i in scripts) {
									if (scripts[i].src == src) {
										return scripts[i];
									}
								}
							}
							return null;
						}
					},

					/**
					 * Returns whether a given class is active for `element`.
					 *
					 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
					 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
					 * given class is just the given class with a `no-` prefix.
					 *
					 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
					 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
					 * ancestors have the given class or the negated version of it, then the default activation will be returned.
					 *
					 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
					 * version of it, the class is considered active.
					 *
					 * @param {Element} element
					 * @param {string} className
					 * @param {boolean} [defaultActivation=false]
					 * @returns {boolean}
					 */
					isActive: function (element, className, defaultActivation) {
						var no = 'no-' + className;

						while (element) {
							var classList = element.classList;
							if (classList.contains(className)) {
								return true;
							}
							if (classList.contains(no)) {
								return false;
							}
							element = element.parentElement;
						}
						return !!defaultActivation;
					}
				},

				/**
				 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
				 *
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				languages: {
					/**
					 * The grammar for plain, unformatted text.
					 */
					plain: plainTextGrammar,
					plaintext: plainTextGrammar,
					text: plainTextGrammar,
					txt: plainTextGrammar,

					/**
					 * Creates a deep copy of the language with the given id and appends the given tokens.
					 *
					 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
					 * will be overwritten at its original position.
					 *
					 * ## Best practices
					 *
					 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
					 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
					 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
					 *
					 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
					 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
					 *
					 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
					 * @param {Grammar} redef The new tokens to append.
					 * @returns {Grammar} The new language created.
					 * @public
					 * @example
					 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
					 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
					 *     // at its original position
					 *     'comment': { ... },
					 *     // CSS doesn't have a 'color' token, so this token will be appended
					 *     'color': /\b(?:red|green|blue)\b/
					 * });
					 */
					extend: function (id, redef) {
						var lang = _.util.clone(_.languages[id]);

						for (var key in redef) {
							lang[key] = redef[key];
						}

						return lang;
					},

					/**
					 * Inserts tokens _before_ another token in a language definition or any other grammar.
					 *
					 * ## Usage
					 *
					 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
					 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
					 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
					 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
					 * this:
					 *
					 * ```js
					 * Prism.languages.markup.style = {
					 *     // token
					 * };
					 * ```
					 *
					 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
					 * before existing tokens. For the CSS example above, you would use it like this:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'cdata', {
					 *     'style': {
					 *         // token
					 *     }
					 * });
					 * ```
					 *
					 * ## Special cases
					 *
					 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
					 * will be ignored.
					 *
					 * This behavior can be used to insert tokens after `before`:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'comment', {
					 *     'comment': Prism.languages.markup.comment,
					 *     // tokens after 'comment'
					 * });
					 * ```
					 *
					 * ## Limitations
					 *
					 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
					 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
					 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
					 * deleting properties which is necessary to insert at arbitrary positions.
					 *
					 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
					 * Instead, it will create a new object and replace all references to the target object with the new one. This
					 * can be done without temporarily deleting properties, so the iteration order is well-defined.
					 *
					 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
					 * you hold the target object in a variable, then the value of the variable will not change.
					 *
					 * ```js
					 * var oldMarkup = Prism.languages.markup;
					 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
					 *
					 * assert(oldMarkup !== Prism.languages.markup);
					 * assert(newMarkup === Prism.languages.markup);
					 * ```
					 *
					 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
					 * object to be modified.
					 * @param {string} before The key to insert before.
					 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
					 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
					 * object to be modified.
					 *
					 * Defaults to `Prism.languages`.
					 * @returns {Grammar} The new grammar object.
					 * @public
					 */
					insertBefore: function (inside, before, insert, root) {
						root = root || /** @type {any} */ (_.languages);
						var grammar = root[inside];
						/** @type {Grammar} */
						var ret = {};

						for (var token in grammar) {
							if (grammar.hasOwnProperty(token)) {

								if (token == before) {
									for (var newToken in insert) {
										if (insert.hasOwnProperty(newToken)) {
											ret[newToken] = insert[newToken];
										}
									}
								}

								// Do not insert token which also occur in insert. See #1525
								if (!insert.hasOwnProperty(token)) {
									ret[token] = grammar[token];
								}
							}
						}

						var old = root[inside];
						root[inside] = ret;

						// Update references in other language definitions
						_.languages.DFS(_.languages, function (key, value) {
							if (value === old && key != inside) {
								this[key] = ret;
							}
						});

						return ret;
					},

					// Traverse a language definition with Depth First Search
					DFS: function DFS(o, callback, type, visited) {
						visited = visited || {};

						var objId = _.util.objId;

						for (var i in o) {
							if (o.hasOwnProperty(i)) {
								callback.call(o, i, o[i], type || i);

								var property = o[i];
								var propertyType = _.util.type(property);

								if (propertyType === 'Object' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, null, visited);
								} else if (propertyType === 'Array' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, i, visited);
								}
							}
						}
					}
				},

				plugins: {},

				/**
				 * This is the most high-level function in Prism’s API.
				 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
				 * each one of them.
				 *
				 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
				 *
				 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
				 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
				 * @memberof Prism
				 * @public
				 */
				highlightAll: function (async, callback) {
					_.highlightAllUnder(document, async, callback);
				},

				/**
				 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
				 * {@link Prism.highlightElement} on each one of them.
				 *
				 * The following hooks will be run:
				 * 1. `before-highlightall`
				 * 2. `before-all-elements-highlight`
				 * 3. All hooks of {@link Prism.highlightElement} for each element.
				 *
				 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
				 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
				 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
				 * @memberof Prism
				 * @public
				 */
				highlightAllUnder: function (container, async, callback) {
					var env = {
						callback: callback,
						container: container,
						selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
					};

					_.hooks.run('before-highlightall', env);

					env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

					_.hooks.run('before-all-elements-highlight', env);

					for (var i = 0, element; (element = env.elements[i++]);) {
						_.highlightElement(element, async === true, env.callback);
					}
				},

				/**
				 * Highlights the code inside a single element.
				 *
				 * The following hooks will be run:
				 * 1. `before-sanity-check`
				 * 2. `before-highlight`
				 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
				 * 4. `before-insert`
				 * 5. `after-highlight`
				 * 6. `complete`
				 *
				 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
				 * the element's language.
				 *
				 * @param {Element} element The element containing the code.
				 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
				 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
				 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
				 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
				 *
				 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
				 * asynchronous highlighting to work. You can build your own bundle on the
				 * [Download page](https://prismjs.com/download.html).
				 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
				 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
				 * @memberof Prism
				 * @public
				 */
				highlightElement: function (element, async, callback) {
					// Find language
					var language = _.util.getLanguage(element);
					var grammar = _.languages[language];

					// Set language on the element, if not present
					_.util.setLanguage(element, language);

					// Set language on the parent, for styling
					var parent = element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre') {
						_.util.setLanguage(parent, language);
					}

					var code = element.textContent;

					var env = {
						element: element,
						language: language,
						grammar: grammar,
						code: code
					};

					function insertHighlightedCode(highlightedCode) {
						env.highlightedCode = highlightedCode;

						_.hooks.run('before-insert', env);

						env.element.innerHTML = env.highlightedCode;

						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
					}

					_.hooks.run('before-sanity-check', env);

					// plugins may change/add the parent/element
					parent = env.element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
						parent.setAttribute('tabindex', '0');
					}

					if (!env.code) {
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
						return;
					}

					_.hooks.run('before-highlight', env);

					if (!env.grammar) {
						insertHighlightedCode(_.util.encode(env.code));
						return;
					}

					if (async && _self.Worker) {
						var worker = new Worker(_.filename);

						worker.onmessage = function (evt) {
							insertHighlightedCode(evt.data);
						};

						worker.postMessage(JSON.stringify({
							language: env.language,
							code: env.code,
							immediateClose: true
						}));
					} else {
						insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
					}
				},

				/**
				 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
				 * and the language definitions to use, and returns a string with the HTML produced.
				 *
				 * The following hooks will be run:
				 * 1. `before-tokenize`
				 * 2. `after-tokenize`
				 * 3. `wrap`: On each {@link Token}.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @param {string} language The name of the language definition passed to `grammar`.
				 * @returns {string} The highlighted HTML.
				 * @memberof Prism
				 * @public
				 * @example
				 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
				 */
				highlight: function (text, grammar, language) {
					var env = {
						code: text,
						grammar: grammar,
						language: language
					};
					_.hooks.run('before-tokenize', env);
					if (!env.grammar) {
						throw new Error('The language "' + env.language + '" has no grammar.');
					}
					env.tokens = _.tokenize(env.code, env.grammar);
					_.hooks.run('after-tokenize', env);
					return Token.stringify(_.util.encode(env.tokens), env.language);
				},

				/**
				 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
				 * and the language definitions to use, and returns an array with the tokenized code.
				 *
				 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
				 *
				 * This method could be useful in other contexts as well, as a very crude parser.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @returns {TokenStream} An array of strings and tokens, a token stream.
				 * @memberof Prism
				 * @public
				 * @example
				 * let code = `var foo = 0;`;
				 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
				 * tokens.forEach(token => {
				 *     if (token instanceof Prism.Token && token.type === 'number') {
				 *         console.log(`Found numeric literal: ${token.content}`);
				 *     }
				 * });
				 */
				tokenize: function (text, grammar) {
					var rest = grammar.rest;
					if (rest) {
						for (var token in rest) {
							grammar[token] = rest[token];
						}

						delete grammar.rest;
					}

					var tokenList = new LinkedList();
					addAfter(tokenList, tokenList.head, text);

					matchGrammar(text, tokenList, grammar, tokenList.head, 0);

					return toArray(tokenList);
				},

				/**
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				hooks: {
					all: {},

					/**
					 * Adds the given callback to the list of callbacks for the given hook.
					 *
					 * The callback will be invoked when the hook it is registered for is run.
					 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
					 *
					 * One callback function can be registered to multiple hooks and the same hook multiple times.
					 *
					 * @param {string} name The name of the hook.
					 * @param {HookCallback} callback The callback function which is given environment variables.
					 * @public
					 */
					add: function (name, callback) {
						var hooks = _.hooks.all;

						hooks[name] = hooks[name] || [];

						hooks[name].push(callback);
					},

					/**
					 * Runs a hook invoking all registered callbacks with the given environment variables.
					 *
					 * Callbacks will be invoked synchronously and in the order in which they were registered.
					 *
					 * @param {string} name The name of the hook.
					 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
					 * @public
					 */
					run: function (name, env) {
						var callbacks = _.hooks.all[name];

						if (!callbacks || !callbacks.length) {
							return;
						}

						for (var i = 0, callback; (callback = callbacks[i++]);) {
							callback(env);
						}
					}
				},

				Token: Token
			};
			_self.Prism = _;


			// Typescript note:
			// The following can be used to import the Token type in JSDoc:
			//
			//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

			/**
			 * Creates a new token.
			 *
			 * @param {string} type See {@link Token#type type}
			 * @param {string | TokenStream} content See {@link Token#content content}
			 * @param {string|string[]} [alias] The alias(es) of the token.
			 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
			 * @class
			 * @global
			 * @public
			 */
			function Token(type, content, alias, matchedStr) {
				/**
				 * The type of the token.
				 *
				 * This is usually the key of a pattern in a {@link Grammar}.
				 *
				 * @type {string}
				 * @see GrammarToken
				 * @public
				 */
				this.type = type;
				/**
				 * The strings or tokens contained by this token.
				 *
				 * This will be a token stream if the pattern matched also defined an `inside` grammar.
				 *
				 * @type {string | TokenStream}
				 * @public
				 */
				this.content = content;
				/**
				 * The alias(es) of the token.
				 *
				 * @type {string|string[]}
				 * @see GrammarToken
				 * @public
				 */
				this.alias = alias;
				// Copy of the full string this token was created from
				this.length = (matchedStr || '').length | 0;
			}

			/**
			 * A token stream is an array of strings and {@link Token Token} objects.
			 *
			 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
			 * them.
			 *
			 * 1. No adjacent strings.
			 * 2. No empty strings.
			 *
			 *    The only exception here is the token stream that only contains the empty string and nothing else.
			 *
			 * @typedef {Array<string | Token>} TokenStream
			 * @global
			 * @public
			 */

			/**
			 * Converts the given token or token stream to an HTML representation.
			 *
			 * The following hooks will be run:
			 * 1. `wrap`: On each {@link Token}.
			 *
			 * @param {string | Token | TokenStream} o The token or token stream to be converted.
			 * @param {string} language The name of current language.
			 * @returns {string} The HTML representation of the token or token stream.
			 * @memberof Token
			 * @static
			 */
			Token.stringify = function stringify(o, language) {
				if (typeof o == 'string') {
					return o;
				}
				if (Array.isArray(o)) {
					var s = '';
					o.forEach(function (e) {
						s += stringify(e, language);
					});
					return s;
				}

				var env = {
					type: o.type,
					content: stringify(o.content, language),
					tag: 'span',
					classes: ['token', o.type],
					attributes: {},
					language: language
				};

				var aliases = o.alias;
				if (aliases) {
					if (Array.isArray(aliases)) {
						Array.prototype.push.apply(env.classes, aliases);
					} else {
						env.classes.push(aliases);
					}
				}

				_.hooks.run('wrap', env);

				var attributes = '';
				for (var name in env.attributes) {
					attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
				}

				return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
			};

			/**
			 * @param {RegExp} pattern
			 * @param {number} pos
			 * @param {string} text
			 * @param {boolean} lookbehind
			 * @returns {RegExpExecArray | null}
			 */
			function matchPattern(pattern, pos, text, lookbehind) {
				pattern.lastIndex = pos;
				var match = pattern.exec(text);
				if (match && lookbehind && match[1]) {
					// change the match to remove the text matched by the Prism lookbehind group
					var lookbehindLength = match[1].length;
					match.index += lookbehindLength;
					match[0] = match[0].slice(lookbehindLength);
				}
				return match;
			}

			/**
			 * @param {string} text
			 * @param {LinkedList<string | Token>} tokenList
			 * @param {any} grammar
			 * @param {LinkedListNode<string | Token>} startNode
			 * @param {number} startPos
			 * @param {RematchOptions} [rematch]
			 * @returns {void}
			 * @private
			 *
			 * @typedef RematchOptions
			 * @property {string} cause
			 * @property {number} reach
			 */
			function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
				for (var token in grammar) {
					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
						continue;
					}

					var patterns = grammar[token];
					patterns = Array.isArray(patterns) ? patterns : [patterns];

					for (var j = 0; j < patterns.length; ++j) {
						if (rematch && rematch.cause == token + ',' + j) {
							return;
						}

						var patternObj = patterns[j];
						var inside = patternObj.inside;
						var lookbehind = !!patternObj.lookbehind;
						var greedy = !!patternObj.greedy;
						var alias = patternObj.alias;

						if (greedy && !patternObj.pattern.global) {
							// Without the global flag, lastIndex won't work
							var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
							patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
						}

						/** @type {RegExp} */
						var pattern = patternObj.pattern || patternObj;

						for ( // iterate the token list and keep track of the current token/string position
							var currentNode = startNode.next, pos = startPos;
							currentNode !== tokenList.tail;
							pos += currentNode.value.length, currentNode = currentNode.next
						) {

							if (rematch && pos >= rematch.reach) {
								break;
							}

							var str = currentNode.value;

							if (tokenList.length > text.length) {
								// Something went terribly wrong, ABORT, ABORT!
								return;
							}

							if (str instanceof Token) {
								continue;
							}

							var removeCount = 1; // this is the to parameter of removeBetween
							var match;

							if (greedy) {
								match = matchPattern(pattern, pos, text, lookbehind);
								if (!match || match.index >= text.length) {
									break;
								}

								var from = match.index;
								var to = match.index + match[0].length;
								var p = pos;

								// find the node that contains the match
								p += currentNode.value.length;
								while (from >= p) {
									currentNode = currentNode.next;
									p += currentNode.value.length;
								}
								// adjust pos (and p)
								p -= currentNode.value.length;
								pos = p;

								// the current node is a Token, then the match starts inside another Token, which is invalid
								if (currentNode.value instanceof Token) {
									continue;
								}

								// find the last node which is affected by this match
								for (
									var k = currentNode;
									k !== tokenList.tail && (p < to || typeof k.value === 'string');
									k = k.next
								) {
									removeCount++;
									p += k.value.length;
								}
								removeCount--;

								// replace with the new match
								str = text.slice(pos, p);
								match.index -= pos;
							} else {
								match = matchPattern(pattern, 0, str, lookbehind);
								if (!match) {
									continue;
								}
							}

							// eslint-disable-next-line no-redeclare
							var from = match.index;
							var matchStr = match[0];
							var before = str.slice(0, from);
							var after = str.slice(from + matchStr.length);

							var reach = pos + str.length;
							if (rematch && reach > rematch.reach) {
								rematch.reach = reach;
							}

							var removeFrom = currentNode.prev;

							if (before) {
								removeFrom = addAfter(tokenList, removeFrom, before);
								pos += before.length;
							}

							removeRange(tokenList, removeFrom, removeCount);

							var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
							currentNode = addAfter(tokenList, removeFrom, wrapped);

							if (after) {
								addAfter(tokenList, currentNode, after);
							}

							if (removeCount > 1) {
								// at least one Token object was removed, so we have to do some rematching
								// this can only happen if the current pattern is greedy

								/** @type {RematchOptions} */
								var nestedRematch = {
									cause: token + ',' + j,
									reach: reach
								};
								matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

								// the reach might have been extended because of the rematching
								if (rematch && nestedRematch.reach > rematch.reach) {
									rematch.reach = nestedRematch.reach;
								}
							}
						}
					}
				}
			}

			/**
			 * @typedef LinkedListNode
			 * @property {T} value
			 * @property {LinkedListNode<T> | null} prev The previous node.
			 * @property {LinkedListNode<T> | null} next The next node.
			 * @template T
			 * @private
			 */

			/**
			 * @template T
			 * @private
			 */
			function LinkedList() {
				/** @type {LinkedListNode<T>} */
				var head = { value: null, prev: null, next: null };
				/** @type {LinkedListNode<T>} */
				var tail = { value: null, prev: head, next: null };
				head.next = tail;

				/** @type {LinkedListNode<T>} */
				this.head = head;
				/** @type {LinkedListNode<T>} */
				this.tail = tail;
				this.length = 0;
			}

			/**
			 * Adds a new node with the given value to the list.
			 *
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {T} value
			 * @returns {LinkedListNode<T>} The added node.
			 * @template T
			 */
			function addAfter(list, node, value) {
				// assumes that node != list.tail && values.length >= 0
				var next = node.next;

				var newNode = { value: value, prev: node, next: next };
				node.next = newNode;
				next.prev = newNode;
				list.length++;

				return newNode;
			}
			/**
			 * Removes `count` nodes after the given node. The given node will not be removed.
			 *
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {number} count
			 * @template T
			 */
			function removeRange(list, node, count) {
				var next = node.next;
				for (var i = 0; i < count && next !== list.tail; i++) {
					next = next.next;
				}
				node.next = next;
				next.prev = node;
				list.length -= i;
			}
			/**
			 * @param {LinkedList<T>} list
			 * @returns {T[]}
			 * @template T
			 */
			function toArray(list) {
				var array = [];
				var node = list.head.next;
				while (node !== list.tail) {
					array.push(node.value);
					node = node.next;
				}
				return array;
			}


			if (!_self.document) {
				if (!_self.addEventListener) {
					// in Node.js
					return _;
				}

				if (!_.disableWorkerMessageHandler) {
					// In worker
					_self.addEventListener('message', function (evt) {
						var message = JSON.parse(evt.data);
						var lang = message.language;
						var code = message.code;
						var immediateClose = message.immediateClose;

						_self.postMessage(_.highlight(code, _.languages[lang], lang));
						if (immediateClose) {
							_self.close();
						}
					}, false);
				}

				return _;
			}

			// Get current script and highlight
			var script = _.util.currentScript();

			if (script) {
				_.filename = script.src;

				if (script.hasAttribute('data-manual')) {
					_.manual = true;
				}
			}

			function highlightAutomaticallyCallback() {
				if (!_.manual) {
					_.highlightAll();
				}
			}

			if (!_.manual) {
				// If the document state is "loading", then we'll use DOMContentLoaded.
				// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
				// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
				// might take longer one animation frame to execute which can create a race condition where only some plugins have
				// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
				// See https://github.com/PrismJS/prism/issues/2102
				var readyState = document.readyState;
				if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
					document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
				} else {
					if (window.requestAnimationFrame) {
						window.requestAnimationFrame(highlightAutomaticallyCallback);
					} else {
						window.setTimeout(highlightAutomaticallyCallback, 16);
					}
				}
			}

			return _;

		}(_self));

		if (module.exports) {
			module.exports = Prism;
		}

		// hack for components to work correctly in node.js
		if (typeof commonjsGlobal !== 'undefined') {
			commonjsGlobal.Prism = Prism;
		}

		// some additional documentation/types

		/**
		 * The expansion of a simple `RegExp` literal to support additional properties.
		 *
		 * @typedef GrammarToken
		 * @property {RegExp} pattern The regular expression of the token.
		 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
		 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
		 * @property {boolean} [greedy=false] Whether the token is greedy.
		 * @property {string|string[]} [alias] An optional alias or list of aliases.
		 * @property {Grammar} [inside] The nested grammar of this token.
		 *
		 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
		 *
		 * This can be used to make nested and even recursive language definitions.
		 *
		 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
		 * each another.
		 * @global
		 * @public
		 */

		/**
		 * @typedef Grammar
		 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
		 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
		 * @global
		 * @public
		 */

		/**
		 * A function which will invoked after an element was successfully highlighted.
		 *
		 * @callback HighlightCallback
		 * @param {Element} element The element successfully highlighted.
		 * @returns {void}
		 * @global
		 * @public
		 */

		/**
		 * @callback HookCallback
		 * @param {Object<string, any>} env The environment variables of the hook.
		 * @returns {void}
		 * @global
		 * @public
		 */


		/* **********************************************
		     Begin prism-markup.js
		********************************************** */

		Prism.languages.markup = {
			'comment': {
				pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
				greedy: true
			},
			'prolog': {
				pattern: /<\?[\s\S]+?\?>/,
				greedy: true
			},
			'doctype': {
				// https://www.w3.org/TR/xml/#NT-doctypedecl
				pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
				greedy: true,
				inside: {
					'internal-subset': {
						pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
						lookbehind: true,
						greedy: true,
						inside: null // see below
					},
					'string': {
						pattern: /"[^"]*"|'[^']*'/,
						greedy: true
					},
					'punctuation': /^<!|>$|[[\]]/,
					'doctype-tag': /^DOCTYPE/i,
					'name': /[^\s<>'"]+/
				}
			},
			'cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				greedy: true
			},
			'tag': {
				pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
				greedy: true,
				inside: {
					'tag': {
						pattern: /^<\/?[^\s>\/]+/,
						inside: {
							'punctuation': /^<\/?/,
							'namespace': /^[^\s>\/:]+:/
						}
					},
					'special-attr': [],
					'attr-value': {
						pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
						inside: {
							'punctuation': [
								{
									pattern: /^=/,
									alias: 'attr-equals'
								},
								{
									pattern: /^(\s*)["']|["']$/,
									lookbehind: true
								}
							]
						}
					},
					'punctuation': /\/?>/,
					'attr-name': {
						pattern: /[^\s>\/]+/,
						inside: {
							'namespace': /^[^\s>\/:]+:/
						}
					}

				}
			},
			'entity': [
				{
					pattern: /&[\da-z]{1,8};/i,
					alias: 'named-entity'
				},
				/&#x?[\da-f]{1,8};/i
			]
		};

		Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
			Prism.languages.markup['entity'];
		Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

		// Plugin to make entity title show the real entity, idea by Roman Komarov
		Prism.hooks.add('wrap', function (env) {

			if (env.type === 'entity') {
				env.attributes['title'] = env.content.replace(/&amp;/, '&');
			}
		});

		Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
			/**
			 * Adds an inlined language to markup.
			 *
			 * An example of an inlined language is CSS with `<style>` tags.
			 *
			 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
			 * case insensitive.
			 * @param {string} lang The language key.
			 * @example
			 * addInlined('style', 'css');
			 */
			value: function addInlined(tagName, lang) {
				var includedCdataInside = {};
				includedCdataInside['language-' + lang] = {
					pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
					lookbehind: true,
					inside: Prism.languages[lang]
				};
				includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

				var inside = {
					'included-cdata': {
						pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
						inside: includedCdataInside
					}
				};
				inside['language-' + lang] = {
					pattern: /[\s\S]+/,
					inside: Prism.languages[lang]
				};

				var def = {};
				def[tagName] = {
					pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
					lookbehind: true,
					greedy: true,
					inside: inside
				};

				Prism.languages.insertBefore('markup', 'cdata', def);
			}
		});
		Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
			/**
			 * Adds an pattern to highlight languages embedded in HTML attributes.
			 *
			 * An example of an inlined language is CSS with `style` attributes.
			 *
			 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
			 * case insensitive.
			 * @param {string} lang The language key.
			 * @example
			 * addAttribute('style', 'css');
			 */
			value: function (attrName, lang) {
				Prism.languages.markup.tag.inside['special-attr'].push({
					pattern: RegExp(
						/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
						'i'
					),
					lookbehind: true,
					inside: {
						'attr-name': /^[^\s=]+/,
						'attr-value': {
							pattern: /=[\s\S]+/,
							inside: {
								'value': {
									pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
									lookbehind: true,
									alias: [lang, 'language-' + lang],
									inside: Prism.languages[lang]
								},
								'punctuation': [
									{
										pattern: /^=/,
										alias: 'attr-equals'
									},
									/"|'/
								]
							}
						}
					}
				});
			}
		});

		Prism.languages.html = Prism.languages.markup;
		Prism.languages.mathml = Prism.languages.markup;
		Prism.languages.svg = Prism.languages.markup;

		Prism.languages.xml = Prism.languages.extend('markup', {});
		Prism.languages.ssml = Prism.languages.xml;
		Prism.languages.atom = Prism.languages.xml;
		Prism.languages.rss = Prism.languages.xml;


		/* **********************************************
		     Begin prism-css.js
		********************************************** */

		(function (Prism) {

			var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

			Prism.languages.css = {
				'comment': /\/\*[\s\S]*?\*\//,
				'atrule': {
					pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
					inside: {
						'rule': /^@[\w-]+/,
						'selector-function-argument': {
							pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
							lookbehind: true,
							alias: 'selector'
						},
						'keyword': {
							pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
							lookbehind: true
						}
						// See rest below
					}
				},
				'url': {
					// https://drafts.csswg.org/css-values-3/#urls
					pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
					greedy: true,
					inside: {
						'function': /^url/i,
						'punctuation': /^\(|\)$/,
						'string': {
							pattern: RegExp('^' + string.source + '$'),
							alias: 'url'
						}
					}
				},
				'selector': {
					pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
					lookbehind: true
				},
				'string': {
					pattern: string,
					greedy: true
				},
				'property': {
					pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
					lookbehind: true
				},
				'important': /!important\b/i,
				'function': {
					pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
					lookbehind: true
				},
				'punctuation': /[(){};:,]/
			};

			Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

			var markup = Prism.languages.markup;
			if (markup) {
				markup.tag.addInlined('style', 'css');
				markup.tag.addAttribute('style', 'css');
			}

		}(Prism));


		/* **********************************************
		     Begin prism-clike.js
		********************************************** */

		Prism.languages.clike = {
			'comment': [
				{
					pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /(^|[^\\:])\/\/.*/,
					lookbehind: true,
					greedy: true
				}
			],
			'string': {
				pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
				greedy: true
			},
			'class-name': {
				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
				lookbehind: true,
				inside: {
					'punctuation': /[.\\]/
				}
			},
			'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
			'boolean': /\b(?:false|true)\b/,
			'function': /\b\w+(?=\()/,
			'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
			'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
			'punctuation': /[{}[\];(),.:]/
		};


		/* **********************************************
		     Begin prism-javascript.js
		********************************************** */

		Prism.languages.javascript = Prism.languages.extend('clike', {
			'class-name': [
				Prism.languages.clike['class-name'],
				{
					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
					lookbehind: true
				}
			],
			'keyword': [
				{
					pattern: /((?:^|\})\s*)catch\b/,
					lookbehind: true
				},
				{
					pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
					lookbehind: true
				},
			],
			// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
			'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
			'number': {
				pattern: RegExp(
					/(^|[^\w$])/.source +
					'(?:' +
					(
						// constant
						/NaN|Infinity/.source +
						'|' +
						// binary integer
						/0[bB][01]+(?:_[01]+)*n?/.source +
						'|' +
						// octal integer
						/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
						'|' +
						// hexadecimal integer
						/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
						'|' +
						// decimal bigint
						/\d+(?:_\d+)*n/.source +
						'|' +
						// decimal number (integer or float) but no bigint
						/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
					) +
					')' +
					/(?![\w$])/.source
				),
				lookbehind: true
			},
			'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
		});

		Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

		Prism.languages.insertBefore('javascript', 'keyword', {
			'regex': {
				pattern: RegExp(
					// lookbehind
					// eslint-disable-next-line regexp/no-dupe-characters-character-class
					/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
					// Regex pattern:
					// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
					// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
					// with the only syntax, so we have to define 2 different regex patterns.
					/\//.source +
					'(?:' +
					/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
					'|' +
					// `v` flag syntax. This supports 3 levels of nested character classes.
					/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
					')' +
					// lookahead
					/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
				),
				lookbehind: true,
				greedy: true,
				inside: {
					'regex-source': {
						pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
						lookbehind: true,
						alias: 'language-regex',
						inside: Prism.languages.regex
					},
					'regex-delimiter': /^\/|\/$/,
					'regex-flags': /^[a-z]+$/,
				}
			},
			// This must be declared before keyword because we use "function" inside the look-forward
			'function-variable': {
				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
				alias: 'function'
			},
			'parameter': [
				{
					pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
					lookbehind: true,
					inside: Prism.languages.javascript
				}
			],
			'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
		});

		Prism.languages.insertBefore('javascript', 'string', {
			'hashbang': {
				pattern: /^#!.*/,
				greedy: true,
				alias: 'comment'
			},
			'template-string': {
				pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
				greedy: true,
				inside: {
					'template-punctuation': {
						pattern: /^`|`$/,
						alias: 'string'
					},
					'interpolation': {
						pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
						lookbehind: true,
						inside: {
							'interpolation-punctuation': {
								pattern: /^\$\{|\}$/,
								alias: 'punctuation'
							},
							rest: Prism.languages.javascript
						}
					},
					'string': /[\s\S]+/
				}
			},
			'string-property': {
				pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
				lookbehind: true,
				greedy: true,
				alias: 'property'
			}
		});

		Prism.languages.insertBefore('javascript', 'operator', {
			'literal-property': {
				pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
				lookbehind: true,
				alias: 'property'
			},
		});

		if (Prism.languages.markup) {
			Prism.languages.markup.tag.addInlined('script', 'javascript');

			// add attribute support for all DOM events.
			// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
			Prism.languages.markup.tag.addAttribute(
				/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
				'javascript'
			);
		}

		Prism.languages.js = Prism.languages.javascript;


		/* **********************************************
		     Begin prism-file-highlight.js
		********************************************** */

		(function () {

			if (typeof Prism === 'undefined' || typeof document === 'undefined') {
				return;
			}

			// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
			if (!Element.prototype.matches) {
				Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
			}

			var LOADING_MESSAGE = 'Loading…';
			var FAILURE_MESSAGE = function (status, message) {
				return '✖ Error ' + status + ' while fetching file: ' + message;
			};
			var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

			var EXTENSIONS = {
				'js': 'javascript',
				'py': 'python',
				'rb': 'ruby',
				'ps1': 'powershell',
				'psm1': 'powershell',
				'sh': 'bash',
				'bat': 'batch',
				'h': 'c',
				'tex': 'latex'
			};

			var STATUS_ATTR = 'data-src-status';
			var STATUS_LOADING = 'loading';
			var STATUS_LOADED = 'loaded';
			var STATUS_FAILED = 'failed';

			var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
				+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

			/**
			 * Loads the given file.
			 *
			 * @param {string} src The URL or path of the source file to load.
			 * @param {(result: string) => void} success
			 * @param {(reason: string) => void} error
			 */
			function loadFile(src, success, error) {
				var xhr = new XMLHttpRequest();
				xhr.open('GET', src, true);
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						if (xhr.status < 400 && xhr.responseText) {
							success(xhr.responseText);
						} else {
							if (xhr.status >= 400) {
								error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
							} else {
								error(FAILURE_EMPTY_MESSAGE);
							}
						}
					}
				};
				xhr.send(null);
			}

			/**
			 * Parses the given range.
			 *
			 * This returns a range with inclusive ends.
			 *
			 * @param {string | null | undefined} range
			 * @returns {[number, number | undefined] | undefined}
			 */
			function parseRange(range) {
				var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
				if (m) {
					var start = Number(m[1]);
					var comma = m[2];
					var end = m[3];

					if (!comma) {
						return [start, start];
					}
					if (!end) {
						return [start, undefined];
					}
					return [start, Number(end)];
				}
				return undefined;
			}

			Prism.hooks.add('before-highlightall', function (env) {
				env.selector += ', ' + SELECTOR;
			});

			Prism.hooks.add('before-sanity-check', function (env) {
				var pre = /** @type {HTMLPreElement} */ (env.element);
				if (pre.matches(SELECTOR)) {
					env.code = ''; // fast-path the whole thing and go to complete

					pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

					// add code element with loading message
					var code = pre.appendChild(document.createElement('CODE'));
					code.textContent = LOADING_MESSAGE;

					var src = pre.getAttribute('data-src');

					var language = env.language;
					if (language === 'none') {
						// the language might be 'none' because there is no language set;
						// in this case, we want to use the extension as the language
						var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
						language = EXTENSIONS[extension] || extension;
					}

					// set language classes
					Prism.util.setLanguage(code, language);
					Prism.util.setLanguage(pre, language);

					// preload the language
					var autoloader = Prism.plugins.autoloader;
					if (autoloader) {
						autoloader.loadLanguages(language);
					}

					// load file
					loadFile(
						src,
						function (text) {
							// mark as loaded
							pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

							// handle data-range
							var range = parseRange(pre.getAttribute('data-range'));
							if (range) {
								var lines = text.split(/\r\n?|\n/g);

								// the range is one-based and inclusive on both ends
								var start = range[0];
								var end = range[1] == null ? lines.length : range[1];

								if (start < 0) { start += lines.length; }
								start = Math.max(0, Math.min(start - 1, lines.length));
								if (end < 0) { end += lines.length; }
								end = Math.max(0, Math.min(end, lines.length));

								text = lines.slice(start, end).join('\n');

								// add data-start for line numbers
								if (!pre.hasAttribute('data-start')) {
									pre.setAttribute('data-start', String(start + 1));
								}
							}

							// highlight code
							code.textContent = text;
							Prism.highlightElement(code);
						},
						function (error) {
							// mark as failed
							pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

							code.textContent = error;
						}
					);
				}
			});

			Prism.plugins.fileHighlight = {
				/**
				 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
				 *
				 * Note: Elements which are already loaded or currently loading will not be touched by this method.
				 *
				 * @param {ParentNode} [container=document]
				 */
				highlight: function highlight(container) {
					var elements = (container || document).querySelectorAll(SELECTOR);

					for (var i = 0, element; (element = elements[i++]);) {
						Prism.highlightElement(element);
					}
				}
			};

			var logged = false;
			/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
			Prism.fileHighlight = function () {
				if (!logged) {
					console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
					logged = true;
				}
				Prism.plugins.fileHighlight.highlight.apply(this, arguments);
			};

		}()); 
	} (prism));
	return prism.exports;
}

var prismExports = requirePrism();
var prismjs = /*@__PURE__*/getDefaultExportFromCjs(prismExports);

var clipboard$1 = {exports: {}};

/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
var clipboard = clipboard$1.exports;

var hasRequiredClipboard;

function requireClipboard () {
	if (hasRequiredClipboard) return clipboard$1.exports;
	hasRequiredClipboard = 1;
	(function (module, exports$1) {
		(function webpackUniversalModuleDefinition(root, factory) {
			module.exports = factory();
		})(clipboard, function() {
		return /******/ (function() { // webpackBootstrap
		/******/ 	var __webpack_modules__ = ({

		/***/ 686:
		/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

		// EXPORTS
		__webpack_require__.d(__webpack_exports__, {
		  "default": function() { return /* binding */ clipboard; }
		});

		// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
		var tiny_emitter = __webpack_require__(279);
		var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);
		// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
		var listen = __webpack_require__(370);
		var listen_default = /*#__PURE__*/__webpack_require__.n(listen);
		// EXTERNAL MODULE: ./node_modules/select/src/select.js
		var src_select = __webpack_require__(817);
		var select_default = /*#__PURE__*/__webpack_require__.n(src_select);
		/**
		 * Executes a given operation type.
		 * @param {String} type
		 * @return {Boolean}
		 */
		function command(type) {
		  try {
		    return document.execCommand(type);
		  } catch (err) {
		    return false;
		  }
		}


		/**
		 * Cut action wrapper.
		 * @param {String|HTMLElement} target
		 * @return {String}
		 */

		var ClipboardActionCut = function ClipboardActionCut(target) {
		  var selectedText = select_default()(target);
		  command('cut');
		  return selectedText;
		};

		/* harmony default export */ var actions_cut = (ClipboardActionCut);
		/**
		 * Creates a fake textarea element with a value.
		 * @param {String} value
		 * @return {HTMLElement}
		 */
		function createFakeElement(value) {
		  var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
		  var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

		  fakeElement.style.fontSize = '12pt'; // Reset box model

		  fakeElement.style.border = '0';
		  fakeElement.style.padding = '0';
		  fakeElement.style.margin = '0'; // Move element out of screen horizontally

		  fakeElement.style.position = 'absolute';
		  fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

		  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
		  fakeElement.style.top = "".concat(yPosition, "px");
		  fakeElement.setAttribute('readonly', '');
		  fakeElement.value = value;
		  return fakeElement;
		}



		/**
		 * Create fake copy action wrapper using a fake element.
		 * @param {String} target
		 * @param {Object} options
		 * @return {String}
		 */

		var fakeCopyAction = function fakeCopyAction(value, options) {
		  var fakeElement = createFakeElement(value);
		  options.container.appendChild(fakeElement);
		  var selectedText = select_default()(fakeElement);
		  command('copy');
		  fakeElement.remove();
		  return selectedText;
		};
		/**
		 * Copy action wrapper.
		 * @param {String|HTMLElement} target
		 * @param {Object} options
		 * @return {String}
		 */


		var ClipboardActionCopy = function ClipboardActionCopy(target) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
		    container: document.body
		  };
		  var selectedText = '';

		  if (typeof target === 'string') {
		    selectedText = fakeCopyAction(target, options);
		  } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
		    // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
		    selectedText = fakeCopyAction(target.value, options);
		  } else {
		    selectedText = select_default()(target);
		    command('copy');
		  }

		  return selectedText;
		};

		/* harmony default export */ var actions_copy = (ClipboardActionCopy);
		function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



		/**
		 * Inner function which performs selection from either `text` or `target`
		 * properties and then executes copy or cut operations.
		 * @param {Object} options
		 */

		var ClipboardActionDefault = function ClipboardActionDefault() {
		  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		  // Defines base properties passed from constructor.
		  var _options$action = options.action,
		      action = _options$action === void 0 ? 'copy' : _options$action,
		      container = options.container,
		      target = options.target,
		      text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

		  if (action !== 'copy' && action !== 'cut') {
		    throw new Error('Invalid "action" value, use either "copy" or "cut"');
		  } // Sets the `target` property using an element that will be have its content copied.


		  if (target !== undefined) {
		    if (target && _typeof(target) === 'object' && target.nodeType === 1) {
		      if (action === 'copy' && target.hasAttribute('disabled')) {
		        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
		      }

		      if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
		        throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
		      }
		    } else {
		      throw new Error('Invalid "target" value, use a valid Element');
		    }
		  } // Define selection strategy based on `text` property.


		  if (text) {
		    return actions_copy(text, {
		      container: container
		    });
		  } // Defines which selection strategy based on `target` property.


		  if (target) {
		    return action === 'cut' ? actions_cut(target) : actions_copy(target, {
		      container: container
		    });
		  }
		};

		/* harmony default export */ var actions_default = (ClipboardActionDefault);
		function clipboard_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return clipboard_typeof(obj); }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

		function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

		function _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

		function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

		function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

		function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






		/**
		 * Helper function to retrieve attribute value.
		 * @param {String} suffix
		 * @param {Element} element
		 */

		function getAttributeValue(suffix, element) {
		  var attribute = "data-clipboard-".concat(suffix);

		  if (!element.hasAttribute(attribute)) {
		    return;
		  }

		  return element.getAttribute(attribute);
		}
		/**
		 * Base class which takes one or more elements, adds event listeners to them,
		 * and instantiates a new `ClipboardAction` on each click.
		 */


		var Clipboard = /*#__PURE__*/function (_Emitter) {
		  _inherits(Clipboard, _Emitter);

		  var _super = _createSuper(Clipboard);

		  /**
		   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
		   * @param {Object} options
		   */
		  function Clipboard(trigger, options) {
		    var _this;

		    _classCallCheck(this, Clipboard);

		    _this = _super.call(this);

		    _this.resolveOptions(options);

		    _this.listenClick(trigger);

		    return _this;
		  }
		  /**
		   * Defines if attributes would be resolved using internal setter functions
		   * or custom functions that were passed in the constructor.
		   * @param {Object} options
		   */


		  _createClass(Clipboard, [{
		    key: "resolveOptions",
		    value: function resolveOptions() {
		      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		      this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
		      this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
		      this.text = typeof options.text === 'function' ? options.text : this.defaultText;
		      this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
		    }
		    /**
		     * Adds a click event listener to the passed trigger.
		     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
		     */

		  }, {
		    key: "listenClick",
		    value: function listenClick(trigger) {
		      var _this2 = this;

		      this.listener = listen_default()(trigger, 'click', function (e) {
		        return _this2.onClick(e);
		      });
		    }
		    /**
		     * Defines a new `ClipboardAction` on each click event.
		     * @param {Event} e
		     */

		  }, {
		    key: "onClick",
		    value: function onClick(e) {
		      var trigger = e.delegateTarget || e.currentTarget;
		      var action = this.action(trigger) || 'copy';
		      var text = actions_default({
		        action: action,
		        container: this.container,
		        target: this.target(trigger),
		        text: this.text(trigger)
		      }); // Fires an event based on the copy operation result.

		      this.emit(text ? 'success' : 'error', {
		        action: action,
		        text: text,
		        trigger: trigger,
		        clearSelection: function clearSelection() {
		          if (trigger) {
		            trigger.focus();
		          }

		          window.getSelection().removeAllRanges();
		        }
		      });
		    }
		    /**
		     * Default `action` lookup function.
		     * @param {Element} trigger
		     */

		  }, {
		    key: "defaultAction",
		    value: function defaultAction(trigger) {
		      return getAttributeValue('action', trigger);
		    }
		    /**
		     * Default `target` lookup function.
		     * @param {Element} trigger
		     */

		  }, {
		    key: "defaultTarget",
		    value: function defaultTarget(trigger) {
		      var selector = getAttributeValue('target', trigger);

		      if (selector) {
		        return document.querySelector(selector);
		      }
		    }
		    /**
		     * Allow fire programmatically a copy action
		     * @param {String|HTMLElement} target
		     * @param {Object} options
		     * @returns Text copied.
		     */

		  }, {
		    key: "defaultText",

		    /**
		     * Default `text` lookup function.
		     * @param {Element} trigger
		     */
		    value: function defaultText(trigger) {
		      return getAttributeValue('text', trigger);
		    }
		    /**
		     * Destroy lifecycle.
		     */

		  }, {
		    key: "destroy",
		    value: function destroy() {
		      this.listener.destroy();
		    }
		  }], [{
		    key: "copy",
		    value: function copy(target) {
		      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
		        container: document.body
		      };
		      return actions_copy(target, options);
		    }
		    /**
		     * Allow fire programmatically a cut action
		     * @param {String|HTMLElement} target
		     * @returns Text cutted.
		     */

		  }, {
		    key: "cut",
		    value: function cut(target) {
		      return actions_cut(target);
		    }
		    /**
		     * Returns the support of the given action, or all actions if no action is
		     * given.
		     * @param {String} [action]
		     */

		  }, {
		    key: "isSupported",
		    value: function isSupported() {
		      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
		      var actions = typeof action === 'string' ? [action] : action;
		      var support = !!document.queryCommandSupported;
		      actions.forEach(function (action) {
		        support = support && !!document.queryCommandSupported(action);
		      });
		      return support;
		    }
		  }]);

		  return Clipboard;
		}((tiny_emitter_default()));

		/* harmony default export */ var clipboard = (Clipboard);

		/***/ }),

		/***/ 828:
		/***/ (function(module) {

		var DOCUMENT_NODE_TYPE = 9;

		/**
		 * A polyfill for Element.matches()
		 */
		if (typeof Element !== 'undefined' && !Element.prototype.matches) {
		    var proto = Element.prototype;

		    proto.matches = proto.matchesSelector ||
		                    proto.mozMatchesSelector ||
		                    proto.msMatchesSelector ||
		                    proto.oMatchesSelector ||
		                    proto.webkitMatchesSelector;
		}

		/**
		 * Finds the closest parent that matches a selector.
		 *
		 * @param {Element} element
		 * @param {String} selector
		 * @return {Function}
		 */
		function closest (element, selector) {
		    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
		        if (typeof element.matches === 'function' &&
		            element.matches(selector)) {
		          return element;
		        }
		        element = element.parentNode;
		    }
		}

		module.exports = closest;


		/***/ }),

		/***/ 438:
		/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

		var closest = __webpack_require__(828);

		/**
		 * Delegates event to a selector.
		 *
		 * @param {Element} element
		 * @param {String} selector
		 * @param {String} type
		 * @param {Function} callback
		 * @param {Boolean} useCapture
		 * @return {Object}
		 */
		function _delegate(element, selector, type, callback, useCapture) {
		    var listenerFn = listener.apply(this, arguments);

		    element.addEventListener(type, listenerFn, useCapture);

		    return {
		        destroy: function() {
		            element.removeEventListener(type, listenerFn, useCapture);
		        }
		    }
		}

		/**
		 * Delegates event to a selector.
		 *
		 * @param {Element|String|Array} [elements]
		 * @param {String} selector
		 * @param {String} type
		 * @param {Function} callback
		 * @param {Boolean} useCapture
		 * @return {Object}
		 */
		function delegate(elements, selector, type, callback, useCapture) {
		    // Handle the regular Element usage
		    if (typeof elements.addEventListener === 'function') {
		        return _delegate.apply(null, arguments);
		    }

		    // Handle Element-less usage, it defaults to global delegation
		    if (typeof type === 'function') {
		        // Use `document` as the first parameter, then apply arguments
		        // This is a short way to .unshift `arguments` without running into deoptimizations
		        return _delegate.bind(null, document).apply(null, arguments);
		    }

		    // Handle Selector-based usage
		    if (typeof elements === 'string') {
		        elements = document.querySelectorAll(elements);
		    }

		    // Handle Array-like based usage
		    return Array.prototype.map.call(elements, function (element) {
		        return _delegate(element, selector, type, callback, useCapture);
		    });
		}

		/**
		 * Finds closest match and invokes callback.
		 *
		 * @param {Element} element
		 * @param {String} selector
		 * @param {String} type
		 * @param {Function} callback
		 * @return {Function}
		 */
		function listener(element, selector, type, callback) {
		    return function(e) {
		        e.delegateTarget = closest(e.target, selector);

		        if (e.delegateTarget) {
		            callback.call(element, e);
		        }
		    }
		}

		module.exports = delegate;


		/***/ }),

		/***/ 879:
		/***/ (function(__unused_webpack_module, exports$1) {

		/**
		 * Check if argument is a HTML element.
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		exports$1.node = function(value) {
		    return value !== undefined
		        && value instanceof HTMLElement
		        && value.nodeType === 1;
		};

		/**
		 * Check if argument is a list of HTML elements.
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		exports$1.nodeList = function(value) {
		    var type = Object.prototype.toString.call(value);

		    return value !== undefined
		        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
		        && ('length' in value)
		        && (value.length === 0 || exports$1.node(value[0]));
		};

		/**
		 * Check if argument is a string.
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		exports$1.string = function(value) {
		    return typeof value === 'string'
		        || value instanceof String;
		};

		/**
		 * Check if argument is a function.
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		exports$1.fn = function(value) {
		    var type = Object.prototype.toString.call(value);

		    return type === '[object Function]';
		};


		/***/ }),

		/***/ 370:
		/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

		var is = __webpack_require__(879);
		var delegate = __webpack_require__(438);

		/**
		 * Validates all params and calls the right
		 * listener function based on its target type.
		 *
		 * @param {String|HTMLElement|HTMLCollection|NodeList} target
		 * @param {String} type
		 * @param {Function} callback
		 * @return {Object}
		 */
		function listen(target, type, callback) {
		    if (!target && !type && !callback) {
		        throw new Error('Missing required arguments');
		    }

		    if (!is.string(type)) {
		        throw new TypeError('Second argument must be a String');
		    }

		    if (!is.fn(callback)) {
		        throw new TypeError('Third argument must be a Function');
		    }

		    if (is.node(target)) {
		        return listenNode(target, type, callback);
		    }
		    else if (is.nodeList(target)) {
		        return listenNodeList(target, type, callback);
		    }
		    else if (is.string(target)) {
		        return listenSelector(target, type, callback);
		    }
		    else {
		        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
		    }
		}

		/**
		 * Adds an event listener to a HTML element
		 * and returns a remove listener function.
		 *
		 * @param {HTMLElement} node
		 * @param {String} type
		 * @param {Function} callback
		 * @return {Object}
		 */
		function listenNode(node, type, callback) {
		    node.addEventListener(type, callback);

		    return {
		        destroy: function() {
		            node.removeEventListener(type, callback);
		        }
		    }
		}

		/**
		 * Add an event listener to a list of HTML elements
		 * and returns a remove listener function.
		 *
		 * @param {NodeList|HTMLCollection} nodeList
		 * @param {String} type
		 * @param {Function} callback
		 * @return {Object}
		 */
		function listenNodeList(nodeList, type, callback) {
		    Array.prototype.forEach.call(nodeList, function(node) {
		        node.addEventListener(type, callback);
		    });

		    return {
		        destroy: function() {
		            Array.prototype.forEach.call(nodeList, function(node) {
		                node.removeEventListener(type, callback);
		            });
		        }
		    }
		}

		/**
		 * Add an event listener to a selector
		 * and returns a remove listener function.
		 *
		 * @param {String} selector
		 * @param {String} type
		 * @param {Function} callback
		 * @return {Object}
		 */
		function listenSelector(selector, type, callback) {
		    return delegate(document.body, selector, type, callback);
		}

		module.exports = listen;


		/***/ }),

		/***/ 817:
		/***/ (function(module) {

		function select(element) {
		    var selectedText;

		    if (element.nodeName === 'SELECT') {
		        element.focus();

		        selectedText = element.value;
		    }
		    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
		        var isReadOnly = element.hasAttribute('readonly');

		        if (!isReadOnly) {
		            element.setAttribute('readonly', '');
		        }

		        element.select();
		        element.setSelectionRange(0, element.value.length);

		        if (!isReadOnly) {
		            element.removeAttribute('readonly');
		        }

		        selectedText = element.value;
		    }
		    else {
		        if (element.hasAttribute('contenteditable')) {
		            element.focus();
		        }

		        var selection = window.getSelection();
		        var range = document.createRange();

		        range.selectNodeContents(element);
		        selection.removeAllRanges();
		        selection.addRange(range);

		        selectedText = selection.toString();
		    }

		    return selectedText;
		}

		module.exports = select;


		/***/ }),

		/***/ 279:
		/***/ (function(module) {

		function E () {
		  // Keep this empty so it's easier to inherit from
		  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
		}

		E.prototype = {
		  on: function (name, callback, ctx) {
		    var e = this.e || (this.e = {});

		    (e[name] || (e[name] = [])).push({
		      fn: callback,
		      ctx: ctx
		    });

		    return this;
		  },

		  once: function (name, callback, ctx) {
		    var self = this;
		    function listener () {
		      self.off(name, listener);
		      callback.apply(ctx, arguments);
		    }
		    listener._ = callback;
		    return this.on(name, listener, ctx);
		  },

		  emit: function (name) {
		    var data = [].slice.call(arguments, 1);
		    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
		    var i = 0;
		    var len = evtArr.length;

		    for (i; i < len; i++) {
		      evtArr[i].fn.apply(evtArr[i].ctx, data);
		    }

		    return this;
		  },

		  off: function (name, callback) {
		    var e = this.e || (this.e = {});
		    var evts = e[name];
		    var liveEvents = [];

		    if (evts && callback) {
		      for (var i = 0, len = evts.length; i < len; i++) {
		        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
		          liveEvents.push(evts[i]);
		      }
		    }

		    // Remove event from queue to prevent memory leak
		    // Suggested by https://github.com/lazd
		    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

		    (liveEvents.length)
		      ? e[name] = liveEvents
		      : delete e[name];

		    return this;
		  }
		};

		module.exports = E;
		module.exports.TinyEmitter = E;


		/***/ })

		/******/ 	});
		/************************************************************************/
		/******/ 	// The module cache
		/******/ 	var __webpack_module_cache__ = {};
		/******/ 	
		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {
		/******/ 		// Check if module is in cache
		/******/ 		if(__webpack_module_cache__[moduleId]) {
		/******/ 			return __webpack_module_cache__[moduleId].exports;
		/******/ 		}
		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = __webpack_module_cache__[moduleId] = {
		/******/ 			// no module.id needed
		/******/ 			// no module.loaded needed
		/******/ 			exports: {}
		/******/ 		};
		/******/ 	
		/******/ 		// Execute the module function
		/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
		/******/ 	
		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}
		/******/ 	
		/************************************************************************/
		/******/ 	/* webpack/runtime/compat get default export */
		/******/ 	!function() {
		/******/ 		// getDefaultExport function for compatibility with non-harmony modules
		/******/ 		__webpack_require__.n = function(module) {
		/******/ 			var getter = module && module.__esModule ?
		/******/ 				function() { return module['default']; } :
		/******/ 				function() { return module; };
		/******/ 			__webpack_require__.d(getter, { a: getter });
		/******/ 			return getter;
		/******/ 		};
		/******/ 	}();
		/******/ 	
		/******/ 	/* webpack/runtime/define property getters */
		/******/ 	!function() {
		/******/ 		// define getter functions for harmony exports
		/******/ 		__webpack_require__.d = function(exports$1, definition) {
		/******/ 			for(var key in definition) {
		/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports$1, key)) {
		/******/ 					Object.defineProperty(exports$1, key, { enumerable: true, get: definition[key] });
		/******/ 				}
		/******/ 			}
		/******/ 		};
		/******/ 	}();
		/******/ 	
		/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
		/******/ 	!function() {
		/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); };
		/******/ 	}();
		/******/ 	
		/************************************************************************/
		/******/ 	// module exports must be returned from runtime so entry inlining is disabled
		/******/ 	// startup
		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(686);
		/******/ })()
		.default;
		}); 
	} (clipboard$1));
	return clipboard$1.exports;
}

var clipboardExports = requireClipboard();
var ClipboardJS = /*@__PURE__*/getDefaultExportFromCjs(clipboardExports);

(function () {

	if (typeof Prism === 'undefined') {
		return;
	}

	Prism.hooks.add('wrap', function (env) {
		if (env.type !== 'keyword') {
			return;
		}
		env.classes.push('keyword-' + env.content);
	});

}());

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined' || !document.querySelector) {
		return;
	}

	var LINE_NUMBERS_CLASS = 'line-numbers';
	var LINKABLE_LINE_NUMBERS_CLASS = 'linkable-line-numbers';
	var NEW_LINE_EXP = /\n(?!$)/g;

	/**
	 * @param {string} selector
	 * @param {ParentNode} [container]
	 * @returns {HTMLElement[]}
	 */
	function $$(selector, container) {
		return Array.prototype.slice.call((container || document).querySelectorAll(selector));
	}

	/**
	 * Returns whether the given element has the given class.
	 *
	 * @param {Element} element
	 * @param {string} className
	 * @returns {boolean}
	 */
	function hasClass(element, className) {
		return element.classList.contains(className);
	}

	/**
	 * Calls the given function.
	 *
	 * @param {() => any} func
	 * @returns {void}
	 */
	function callFunction(func) {
		func();
	}

	// Some browsers round the line-height, others don't.
	// We need to test for it to position the elements properly.
	var isLineHeightRounded = (function () {
		var res;
		return function () {
			if (typeof res === 'undefined') {
				var d = document.createElement('div');
				d.style.fontSize = '13px';
				d.style.lineHeight = '1.5';
				d.style.padding = '0';
				d.style.border = '0';
				d.innerHTML = '&nbsp;<br />&nbsp;';
				document.body.appendChild(d);
				// Browsers that round the line-height should have offsetHeight === 38
				// The others should have 39.
				res = d.offsetHeight === 38;
				document.body.removeChild(d);
			}
			return res;
		};
	}());

	/**
	 * Returns the top offset of the content box of the given parent and the content box of one of its children.
	 *
	 * @param {HTMLElement} parent
	 * @param {HTMLElement} child
	 */
	function getContentBoxTopOffset(parent, child) {
		var parentStyle = getComputedStyle(parent);
		var childStyle = getComputedStyle(child);

		/**
		 * Returns the numeric value of the given pixel value.
		 *
		 * @param {string} px
		 */
		function pxToNumber(px) {
			return +px.substr(0, px.length - 2);
		}

		return child.offsetTop
			+ pxToNumber(childStyle.borderTopWidth)
			+ pxToNumber(childStyle.paddingTop)
			- pxToNumber(parentStyle.paddingTop);
	}

	/**
	 * Returns whether the Line Highlight plugin is active for the given element.
	 *
	 * If this function returns `false`, do not call `highlightLines` for the given element.
	 *
	 * @param {HTMLElement | null | undefined} pre
	 * @returns {boolean}
	 */
	function isActiveFor(pre) {
		if (!pre || !/pre/i.test(pre.nodeName)) {
			return false;
		}

		if (pre.hasAttribute('data-line')) {
			return true;
		}

		if (pre.id && Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS)) {
			// Technically, the line numbers plugin is also necessary but this plugin doesn't control the classes of
			// the line numbers plugin, so we can't assume that they are present.
			return true;
		}

		return false;
	}

	var scrollIntoView = true;

	Prism.plugins.lineHighlight = {
		/**
		 * Highlights the lines of the given pre.
		 *
		 * This function is split into a DOM measuring and mutate phase to improve performance.
		 * The returned function mutates the DOM when called.
		 *
		 * @param {HTMLElement} pre
		 * @param {string | null} [lines]
		 * @param {string} [classes='']
		 * @returns {() => void}
		 */
		highlightLines: function highlightLines(pre, lines, classes) {
			lines = typeof lines === 'string' ? lines : (pre.getAttribute('data-line') || '');

			var ranges = lines.replace(/\s+/g, '').split(',').filter(Boolean);
			var offset = +pre.getAttribute('data-line-offset') || 0;

			var parseMethod = isLineHeightRounded() ? parseInt : parseFloat;
			var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);
			var hasLineNumbers = Prism.util.isActive(pre, LINE_NUMBERS_CLASS);
			var codeElement = pre.querySelector('code');
			var parentElement = hasLineNumbers ? pre : codeElement || pre;
			var mutateActions = /** @type {(() => void)[]} */ ([]);
			var lineBreakMatch = codeElement.textContent.match(NEW_LINE_EXP);
			var numberOfLines = lineBreakMatch ? lineBreakMatch.length + 1 : 1;
			/**
			 * The top offset between the content box of the <code> element and the content box of the parent element of
			 * the line highlight element (either `<pre>` or `<code>`).
			 *
			 * This offset might not be zero for some themes where the <code> element has a top margin. Some plugins
			 * (or users) might also add element above the <code> element. Because the line highlight is aligned relative
			 * to the <pre> element, we have to take this into account.
			 *
			 * This offset will be 0 if the parent element of the line highlight element is the `<code>` element.
			 */
			var codePreOffset = !codeElement || parentElement == codeElement ? 0 : getContentBoxTopOffset(pre, codeElement);

			ranges.forEach(function (currentRange) {
				var range = currentRange.split('-');

				var start = +range[0];
				var end = +range[1] || start;
				end = Math.min(numberOfLines + offset, end);

				if (end < start) {
					return;
				}

				/** @type {HTMLElement} */
				var line = pre.querySelector('.line-highlight[data-range="' + currentRange + '"]') || document.createElement('div');

				mutateActions.push(function () {
					line.setAttribute('aria-hidden', 'true');
					line.setAttribute('data-range', currentRange);
					line.className = (classes || '') + ' line-highlight';
				});

				// if the line-numbers plugin is enabled, then there is no reason for this plugin to display the line numbers
				if (hasLineNumbers && Prism.plugins.lineNumbers) {
					var startNode = Prism.plugins.lineNumbers.getLine(pre, start);
					var endNode = Prism.plugins.lineNumbers.getLine(pre, end);

					if (startNode) {
						var top = startNode.offsetTop + codePreOffset + 'px';
						mutateActions.push(function () {
							line.style.top = top;
						});
					}

					if (endNode) {
						var height = (endNode.offsetTop - startNode.offsetTop) + endNode.offsetHeight + 'px';
						mutateActions.push(function () {
							line.style.height = height;
						});
					}
				} else {
					mutateActions.push(function () {
						line.setAttribute('data-start', String(start));

						if (end > start) {
							line.setAttribute('data-end', String(end));
						}

						line.style.top = (start - offset - 1) * lineHeight + codePreOffset + 'px';

						line.textContent = new Array(end - start + 2).join(' \n');
					});
				}

				mutateActions.push(function () {
					line.style.width = pre.scrollWidth + 'px';
				});

				mutateActions.push(function () {
					// allow this to play nicely with the line-numbers plugin
					// need to attack to pre as when line-numbers is enabled, the code tag is relatively which screws up the positioning
					parentElement.appendChild(line);
				});
			});

			var id = pre.id;
			if (hasLineNumbers && Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS) && id) {
				// This implements linkable line numbers. Linkable line numbers use Line Highlight to create a link to a
				// specific line. For this to work, the pre element has to:
				//  1) have line numbers,
				//  2) have the `linkable-line-numbers` class or an ascendant that has that class, and
				//  3) have an id.

				if (!hasClass(pre, LINKABLE_LINE_NUMBERS_CLASS)) {
					// add class to pre
					mutateActions.push(function () {
						pre.classList.add(LINKABLE_LINE_NUMBERS_CLASS);
					});
				}

				var start = parseInt(pre.getAttribute('data-start') || '1');

				// iterate all line number spans
				$$('.line-numbers-rows > span', pre).forEach(function (lineSpan, i) {
					var lineNumber = i + start;
					lineSpan.onclick = function () {
						var hash = id + '.' + lineNumber;

						// this will prevent scrolling since the span is obviously in view
						scrollIntoView = false;
						location.hash = hash;
						setTimeout(function () {
							scrollIntoView = true;
						}, 1);
					};
				});
			}

			return function () {
				mutateActions.forEach(callFunction);
			};
		}
	};


	function applyHash() {
		var hash = location.hash.slice(1);

		// Remove pre-existing temporary lines
		$$('.temporary.line-highlight').forEach(function (line) {
			line.parentNode.removeChild(line);
		});

		var range = (hash.match(/\.([\d,-]+)$/) || [, ''])[1];

		if (!range || document.getElementById(hash)) {
			return;
		}

		var id = hash.slice(0, hash.lastIndexOf('.'));
		var pre = document.getElementById(id);

		if (!pre) {
			return;
		}

		if (!pre.hasAttribute('data-line')) {
			pre.setAttribute('data-line', '');
		}

		var mutateDom = Prism.plugins.lineHighlight.highlightLines(pre, range, 'temporary ');
		mutateDom();

		if (scrollIntoView) {
			document.querySelector('.temporary.line-highlight').scrollIntoView();
		}
	}

	var fakeTimer = 0; // Hack to limit the number of times applyHash() runs

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = env.element.parentElement;
		if (!isActiveFor(pre)) {
			return;
		}

		/*
		 * Cleanup for other plugins (e.g. autoloader).
		 *
		 * Sometimes <code> blocks are highlighted multiple times. It is necessary
		 * to cleanup any left-over tags, because the whitespace inside of the <div>
		 * tags change the content of the <code> tag.
		 */
		var num = 0;
		$$('.line-highlight', pre).forEach(function (line) {
			num += line.textContent.length;
			line.parentNode.removeChild(line);
		});
		// Remove extra whitespace
		if (num && /^(?: \n)+$/.test(env.code.slice(-num))) {
			env.code = env.code.slice(0, -num);
		}
	});

	Prism.hooks.add('complete', function completeHook(env) {
		var pre = env.element.parentElement;
		if (!isActiveFor(pre)) {
			return;
		}

		clearTimeout(fakeTimer);

		var hasLineNumbers = Prism.plugins.lineNumbers;
		var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;

		if (hasClass(pre, LINE_NUMBERS_CLASS) && hasLineNumbers && !isLineNumbersLoaded) {
			Prism.hooks.add('line-numbers', completeHook);
		} else {
			var mutateDom = Prism.plugins.lineHighlight.highlightLines(pre);
			mutateDom();
			fakeTimer = setTimeout(applyHash, 1);
		}
	});

	window.addEventListener('hashchange', applyHash);
	window.addEventListener('resize', function () {
		var actions = $$('pre')
			.filter(isActiveFor)
			.map(function (pre) {
				return Prism.plugins.lineHighlight.highlightLines(pre);
			});
		actions.forEach(callFunction);
	});

}());

var prismLineNumbers = {};

var hasRequiredPrismLineNumbers;

function requirePrismLineNumbers () {
	if (hasRequiredPrismLineNumbers) return prismLineNumbers;
	hasRequiredPrismLineNumbers = 1;
	(function () {

		if (typeof Prism === 'undefined' || typeof document === 'undefined') {
			return;
		}

		/**
		 * Plugin name which is used as a class name for <pre> which is activating the plugin
		 *
		 * @type {string}
		 */
		var PLUGIN_NAME = 'line-numbers';

		/**
		 * Regular expression used for determining line breaks
		 *
		 * @type {RegExp}
		 */
		var NEW_LINE_EXP = /\n(?!$)/g;


		/**
		 * Global exports
		 */
		var config = Prism.plugins.lineNumbers = {
			/**
			 * Get node for provided line number
			 *
			 * @param {Element} element pre element
			 * @param {number} number line number
			 * @returns {Element|undefined}
			 */
			getLine: function (element, number) {
				if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
					return;
				}

				var lineNumberRows = element.querySelector('.line-numbers-rows');
				if (!lineNumberRows) {
					return;
				}
				var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
				var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

				if (number < lineNumberStart) {
					number = lineNumberStart;
				}
				if (number > lineNumberEnd) {
					number = lineNumberEnd;
				}

				var lineIndex = number - lineNumberStart;

				return lineNumberRows.children[lineIndex];
			},

			/**
			 * Resizes the line numbers of the given element.
			 *
			 * This function will not add line numbers. It will only resize existing ones.
			 *
			 * @param {HTMLElement} element A `<pre>` element with line numbers.
			 * @returns {void}
			 */
			resize: function (element) {
				resizeElements([element]);
			},

			/**
			 * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
			 * the current viewport.
			 *
			 * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
			 *
			 * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
			 *
			 * @type {boolean}
			 */
			assumeViewportIndependence: true
		};

		/**
		 * Resizes the given elements.
		 *
		 * @param {HTMLElement[]} elements
		 */
		function resizeElements(elements) {
			elements = elements.filter(function (e) {
				var codeStyles = getStyles(e);
				var whiteSpace = codeStyles['white-space'];
				return whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';
			});

			if (elements.length == 0) {
				return;
			}

			var infos = elements.map(function (element) {
				var codeElement = element.querySelector('code');
				var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
				if (!codeElement || !lineNumbersWrapper) {
					return undefined;
				}

				/** @type {HTMLElement} */
				var lineNumberSizer = element.querySelector('.line-numbers-sizer');
				var codeLines = codeElement.textContent.split(NEW_LINE_EXP);

				if (!lineNumberSizer) {
					lineNumberSizer = document.createElement('span');
					lineNumberSizer.className = 'line-numbers-sizer';

					codeElement.appendChild(lineNumberSizer);
				}

				lineNumberSizer.innerHTML = '0';
				lineNumberSizer.style.display = 'block';

				var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
				lineNumberSizer.innerHTML = '';

				return {
					element: element,
					lines: codeLines,
					lineHeights: [],
					oneLinerHeight: oneLinerHeight,
					sizer: lineNumberSizer,
				};
			}).filter(Boolean);

			infos.forEach(function (info) {
				var lineNumberSizer = info.sizer;
				var lines = info.lines;
				var lineHeights = info.lineHeights;
				var oneLinerHeight = info.oneLinerHeight;

				lineHeights[lines.length - 1] = undefined;
				lines.forEach(function (line, index) {
					if (line && line.length > 1) {
						var e = lineNumberSizer.appendChild(document.createElement('span'));
						e.style.display = 'block';
						e.textContent = line;
					} else {
						lineHeights[index] = oneLinerHeight;
					}
				});
			});

			infos.forEach(function (info) {
				var lineNumberSizer = info.sizer;
				var lineHeights = info.lineHeights;

				var childIndex = 0;
				for (var i = 0; i < lineHeights.length; i++) {
					if (lineHeights[i] === undefined) {
						lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
					}
				}
			});

			infos.forEach(function (info) {
				var lineNumberSizer = info.sizer;
				var wrapper = info.element.querySelector('.line-numbers-rows');

				lineNumberSizer.style.display = 'none';
				lineNumberSizer.innerHTML = '';

				info.lineHeights.forEach(function (height, lineNumber) {
					wrapper.children[lineNumber].style.height = height + 'px';
				});
			});
		}

		/**
		 * Returns style declarations for the element
		 *
		 * @param {Element} element
		 */
		function getStyles(element) {
			if (!element) {
				return null;
			}

			return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
		}

		var lastWidth = undefined;
		window.addEventListener('resize', function () {
			if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
				return;
			}
			lastWidth = window.innerWidth;

			resizeElements(Array.prototype.slice.call(document.querySelectorAll('pre.' + PLUGIN_NAME)));
		});

		Prism.hooks.add('complete', function (env) {
			if (!env.code) {
				return;
			}

			var code = /** @type {Element} */ (env.element);
			var pre = /** @type {HTMLElement} */ (code.parentNode);

			// works only for <code> wrapped inside <pre> (not inline)
			if (!pre || !/pre/i.test(pre.nodeName)) {
				return;
			}

			// Abort if line numbers already exists
			if (code.querySelector('.line-numbers-rows')) {
				return;
			}

			// only add line numbers if <code> or one of its ancestors has the `line-numbers` class
			if (!Prism.util.isActive(code, PLUGIN_NAME)) {
				return;
			}

			// Remove the class 'line-numbers' from the <code>
			code.classList.remove(PLUGIN_NAME);
			// Add the class 'line-numbers' to the <pre>
			pre.classList.add(PLUGIN_NAME);

			var match = env.code.match(NEW_LINE_EXP);
			var linesNum = match ? match.length + 1 : 1;
			var lineNumbersWrapper;

			var lines = new Array(linesNum + 1).join('<span></span>');

			lineNumbersWrapper = document.createElement('span');
			lineNumbersWrapper.setAttribute('aria-hidden', 'true');
			lineNumbersWrapper.className = 'line-numbers-rows';
			lineNumbersWrapper.innerHTML = lines;

			if (pre.hasAttribute('data-start')) {
				pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
			}

			env.element.appendChild(lineNumbersWrapper);

			resizeElements([pre]);

			Prism.hooks.run('line-numbers', env);
		});

		Prism.hooks.add('line-numbers', function (env) {
			env.plugins = env.plugins || {};
			env.plugins.lineNumbers = true;
		});

	}());
	return prismLineNumbers;
}

requirePrismLineNumbers();

(function (Prism) {
	// $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
	// + LC_ALL, RANDOM, REPLY, SECONDS.
	// + make sure PS1..4 are here as they are not always set,
	// - some useless things.
	var envVars = '\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b';

	var commandAfterHeredoc = {
		pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
		lookbehind: true,
		alias: 'punctuation', // this looks reasonably well in all themes
		inside: null // see below
	};

	var insideString = {
		'bash': commandAfterHeredoc,
		'environment': {
			pattern: RegExp('\\$' + envVars),
			alias: 'constant'
		},
		'variable': [
			// [0]: Arithmetic Environment
			{
				pattern: /\$?\(\([\s\S]+?\)\)/,
				greedy: true,
				inside: {
					// If there is a $ sign at the beginning highlight $(( and )) as variable
					'variable': [
						{
							pattern: /(^\$\(\([\s\S]+)\)\)/,
							lookbehind: true
						},
						/^\$\(\(/
					],
					'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
					// Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
					'operator': /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
					// If there is no $ sign at the beginning highlight (( and )) as punctuation
					'punctuation': /\(\(?|\)\)?|,|;/
				}
			},
			// [1]: Command Substitution
			{
				pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
				greedy: true,
				inside: {
					'variable': /^\$\(|^`|\)$|`$/
				}
			},
			// [2]: Brace expansion
			{
				pattern: /\$\{[^}]+\}/,
				greedy: true,
				inside: {
					'operator': /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
					'punctuation': /[\[\]]/,
					'environment': {
						pattern: RegExp('(\\{)' + envVars),
						lookbehind: true,
						alias: 'constant'
					}
				}
			},
			/\$(?:\w+|[#?*!@$])/
		],
		// Escape sequences from echo and printf's manuals, and escaped quotes.
		'entity': /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
	};

	Prism.languages.bash = {
		'shebang': {
			pattern: /^#!\s*\/.*/,
			alias: 'important'
		},
		'comment': {
			pattern: /(^|[^"{\\$])#.*/,
			lookbehind: true
		},
		'function-name': [
			// a) function foo {
			// b) foo() {
			// c) function foo() {
			// but not “foo {”
			{
				// a) and c)
				pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
				lookbehind: true,
				alias: 'function'
			},
			{
				// b)
				pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
				alias: 'function'
			}
		],
		// Highlight variable names as variables in for and select beginnings.
		'for-or-select': {
			pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
			alias: 'variable',
			lookbehind: true
		},
		// Highlight variable names as variables in the left-hand part
		// of assignments (“=” and “+=”).
		'assign-left': {
			pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
			inside: {
				'environment': {
					pattern: RegExp('(^|[\\s;|&]|[<>]\\()' + envVars),
					lookbehind: true,
					alias: 'constant'
				}
			},
			alias: 'variable',
			lookbehind: true
		},
		// Highlight parameter names as variables
		'parameter': {
			pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
			alias: 'variable',
			lookbehind: true
		},
		'string': [
			// Support for Here-documents https://en.wikipedia.org/wiki/Here_document
			{
				pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
				lookbehind: true,
				greedy: true,
				inside: insideString
			},
			// Here-document with quotes around the tag
			// → No expansion (so no “inside”).
			{
				pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
				lookbehind: true,
				greedy: true,
				inside: {
					'bash': commandAfterHeredoc
				}
			},
			// “Normal” string
			{
				// https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
				pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
				lookbehind: true,
				greedy: true,
				inside: insideString
			},
			{
				// https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
				pattern: /(^|[^$\\])'[^']*'/,
				lookbehind: true,
				greedy: true
			},
			{
				// https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
				pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
				greedy: true,
				inside: {
					'entity': insideString.entity
				}
			}
		],
		'environment': {
			pattern: RegExp('\\$?' + envVars),
			alias: 'constant'
		},
		'variable': insideString.variable,
		'function': {
			pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		'keyword': {
			pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		// https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
		'builtin': {
			pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
			lookbehind: true,
			// Alias added to make those easier to distinguish from strings.
			alias: 'class-name'
		},
		'boolean': {
			pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		'file-descriptor': {
			pattern: /\B&\d\b/,
			alias: 'important'
		},
		'operator': {
			// Lots of redirections here, but not just that.
			pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
			inside: {
				'file-descriptor': {
					pattern: /^\d/,
					alias: 'important'
				}
			}
		},
		'punctuation': /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
		'number': {
			pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
			lookbehind: true
		}
	};

	commandAfterHeredoc.inside = Prism.languages.bash;

	/* Patterns in command substitution. */
	var toBeCopied = [
		'comment',
		'function-name',
		'for-or-select',
		'assign-left',
		'parameter',
		'string',
		'environment',
		'function',
		'keyword',
		'builtin',
		'boolean',
		'file-descriptor',
		'operator',
		'punctuation',
		'number'
	];
	var inside = insideString.variable[1].inside;
	for (var i = 0; i < toBeCopied.length; i++) {
		inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
	}

	Prism.languages.sh = Prism.languages.bash;
	Prism.languages.shell = Prism.languages.bash;
}(Prism));

(function (Prism) {

	Prism.languages.diff = {
		'coord': [
			// Match all kinds of coord lines (prefixed by "+++", "---" or "***").
			/^(?:\*{3}|-{3}|\+{3}).*$/m,
			// Match "@@ ... @@" coord lines in unified diff.
			/^@@.*@@$/m,
			// Match coord lines in normal diff (starts with a number).
			/^\d.*$/m
		]

		// deleted, inserted, unchanged, diff
	};

	/**
	 * A map from the name of a block to its line prefix.
	 *
	 * @type {Object<string, string>}
	 */
	var PREFIXES = {
		'deleted-sign': '-',
		'deleted-arrow': '<',
		'inserted-sign': '+',
		'inserted-arrow': '>',
		'unchanged': ' ',
		'diff': '!',
	};

	// add a token for each prefix
	Object.keys(PREFIXES).forEach(function (name) {
		var prefix = PREFIXES[name];

		var alias = [];
		if (!/^\w+$/.test(name)) { // "deleted-sign" -> "deleted"
			alias.push(/\w+/.exec(name)[0]);
		}
		if (name === 'diff') {
			alias.push('bold');
		}

		Prism.languages.diff[name] = {
			pattern: RegExp('^(?:[' + prefix + '].*(?:\r\n?|\n|(?![\\s\\S])))+', 'm'),
			alias: alias,
			inside: {
				'line': {
					pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
					lookbehind: true
				},
				'prefix': {
					pattern: /[\s\S]/,
					alias: /\w+/.exec(name)[0]
				}
			}
		};

	});

	// make prefixes available to Diff plugin
	Object.defineProperty(Prism.languages.diff, 'PREFIXES', {
		value: PREFIXES
	});

}(Prism));

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;

// https://www.json.org/json-en.html
Prism.languages.json = {
	'property': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'string': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'comment': {
		pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
		greedy: true
	},
	'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	'punctuation': /[{}[\],]/,
	'operator': /:/,
	'boolean': /\b(?:false|true)\b/,
	'null': {
		pattern: /\bnull\b/,
		alias: 'keyword'
	}
};

Prism.languages.webmanifest = Prism.languages.json;

(function (Prism) {

	// Allow only one line break
	var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;

	/**
	 * This function is intended for the creation of the bold or italic pattern.
	 *
	 * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
	 *
	 * _Note:_ Keep in mind that this adds a capturing group.
	 *
	 * @param {string} pattern
	 * @returns {RegExp}
	 */
	function createInline(pattern) {
		pattern = pattern.replace(/<inner>/g, function () { return inner; });
		return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
	}


	var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
	var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
	var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;


	Prism.languages.markdown = Prism.languages.extend('markup', {});
	Prism.languages.insertBefore('markdown', 'prolog', {
		'front-matter-block': {
			pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
			lookbehind: true,
			greedy: true,
			inside: {
				'punctuation': /^---|---$/,
				'front-matter': {
					pattern: /\S+(?:\s+\S+)*/,
					alias: ['yaml', 'language-yaml'],
					inside: Prism.languages.yaml
				}
			}
		},
		'blockquote': {
			// > ...
			pattern: /^>(?:[\t ]*>)*/m,
			alias: 'punctuation'
		},
		'table': {
			pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
			inside: {
				'table-data-rows': {
					pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
					lookbehind: true,
					inside: {
						'table-data': {
							pattern: RegExp(tableCell),
							inside: Prism.languages.markdown
						},
						'punctuation': /\|/
					}
				},
				'table-line': {
					pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
					lookbehind: true,
					inside: {
						'punctuation': /\||:?-{3,}:?/
					}
				},
				'table-header-row': {
					pattern: RegExp('^' + tableRow + '$'),
					inside: {
						'table-header': {
							pattern: RegExp(tableCell),
							alias: 'important',
							inside: Prism.languages.markdown
						},
						'punctuation': /\|/
					}
				}
			}
		},
		'code': [
			{
				// Prefixed by 4 spaces or 1 tab and preceded by an empty line
				pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
				lookbehind: true,
				alias: 'keyword'
			},
			{
				// ```optional language
				// code block
				// ```
				pattern: /^```[\s\S]*?^```$/m,
				greedy: true,
				inside: {
					'code-block': {
						pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
						lookbehind: true
					},
					'code-language': {
						pattern: /^(```).+/,
						lookbehind: true
					},
					'punctuation': /```/
				}
			}
		],
		'title': [
			{
				// title 1
				// =======

				// title 2
				// -------
				pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
				alias: 'important',
				inside: {
					punctuation: /==+$|--+$/
				}
			},
			{
				// # title 1
				// ###### title 6
				pattern: /(^\s*)#.+/m,
				lookbehind: true,
				alias: 'important',
				inside: {
					punctuation: /^#+|#+$/
				}
			}
		],
		'hr': {
			// ***
			// ---
			// * * *
			// -----------
			pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
			lookbehind: true,
			alias: 'punctuation'
		},
		'list': {
			// * item
			// + item
			// - item
			// 1. item
			pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
			lookbehind: true,
			alias: 'punctuation'
		},
		'url-reference': {
			// [id]: http://example.com "Optional title"
			// [id]: http://example.com 'Optional title'
			// [id]: http://example.com (Optional title)
			// [id]: <http://example.com> "Optional title"
			pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
			inside: {
				'variable': {
					pattern: /^(!?\[)[^\]]+/,
					lookbehind: true
				},
				'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
				'punctuation': /^[\[\]!:]|[<>]/
			},
			alias: 'url'
		},
		'bold': {
			// **strong**
			// __strong__

			// allow one nested instance of italic text using the same delimiter
			pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				'content': {
					pattern: /(^..)[\s\S]+(?=..$)/,
					lookbehind: true,
					inside: {} // see below
				},
				'punctuation': /\*\*|__/
			}
		},
		'italic': {
			// *em*
			// _em_

			// allow one nested instance of bold text using the same delimiter
			pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				'content': {
					pattern: /(^.)[\s\S]+(?=.$)/,
					lookbehind: true,
					inside: {} // see below
				},
				'punctuation': /[*_]/
			}
		},
		'strike': {
			// ~~strike through~~
			// ~strike~
			// eslint-disable-next-line regexp/strict
			pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				'content': {
					pattern: /(^~~?)[\s\S]+(?=\1$)/,
					lookbehind: true,
					inside: {} // see below
				},
				'punctuation': /~~?/
			}
		},
		'code-snippet': {
			// `code`
			// ``code``
			pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
			lookbehind: true,
			greedy: true,
			alias: ['code', 'keyword']
		},
		'url': {
			// [example](http://example.com "Optional title")
			// [example][id]
			// [example] [id]
			pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				'operator': /^!/,
				'content': {
					pattern: /(^\[)[^\]]+(?=\])/,
					lookbehind: true,
					inside: {} // see below
				},
				'variable': {
					pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
					lookbehind: true
				},
				'url': {
					pattern: /(^\]\()[^\s)]+/,
					lookbehind: true
				},
				'string': {
					pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
					lookbehind: true
				}
			}
		}
	});

	['url', 'bold', 'italic', 'strike'].forEach(function (token) {
		['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
			if (token !== inside) {
				Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
			}
		});
	});

	Prism.hooks.add('after-tokenize', function (env) {
		if (env.language !== 'markdown' && env.language !== 'md') {
			return;
		}

		function walkTokens(tokens) {
			if (!tokens || typeof tokens === 'string') {
				return;
			}

			for (var i = 0, l = tokens.length; i < l; i++) {
				var token = tokens[i];

				if (token.type !== 'code') {
					walkTokens(token.content);
					continue;
				}

				/*
				 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
				 * is optional. But the grammar is defined so that there is only one case we have to handle:
				 *
				 * token.content = [
				 *     <span class="punctuation">```</span>,
				 *     <span class="code-language">xxxx</span>,
				 *     '\n', // exactly one new lines (\r or \n or \r\n)
				 *     <span class="code-block">...</span>,
				 *     '\n', // exactly one new lines again
				 *     <span class="punctuation">```</span>
				 * ];
				 */

				var codeLang = token.content[1];
				var codeBlock = token.content[3];

				if (codeLang && codeBlock &&
					codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
					typeof codeLang.content === 'string') {

					// this might be a language that Prism does not support

					// do some replacements to support C++, C#, and F#
					var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
					// only use the first word
					lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
					var alias = 'language-' + lang;

					// add alias
					if (!codeBlock.alias) {
						codeBlock.alias = [alias];
					} else if (typeof codeBlock.alias === 'string') {
						codeBlock.alias = [codeBlock.alias, alias];
					} else {
						codeBlock.alias.push(alias);
					}
				}
			}
		}

		walkTokens(env.tokens);
	});

	Prism.hooks.add('wrap', function (env) {
		if (env.type !== 'code-block') {
			return;
		}

		var codeLang = '';
		for (var i = 0, l = env.classes.length; i < l; i++) {
			var cls = env.classes[i];
			var match = /language-(.+)/.exec(cls);
			if (match) {
				codeLang = match[1];
				break;
			}
		}

		var grammar = Prism.languages[codeLang];

		if (!grammar) {
			if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
				var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
				env.attributes['id'] = id;

				Prism.plugins.autoloader.loadLanguages(codeLang, function () {
					var ele = document.getElementById(id);
					if (ele) {
						ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
					}
				});
			}
		} else {
			env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
		}
	});

	var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');

	/**
	 * A list of known entity names.
	 *
	 * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
	 *
	 * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
	 */
	var KNOWN_ENTITY_NAMES = {
		'amp': '&',
		'lt': '<',
		'gt': '>',
		'quot': '"',
	};

	// IE 11 doesn't support `String.fromCodePoint`
	var fromCodePoint = String.fromCodePoint || String.fromCharCode;

	/**
	 * Returns the text content of a given HTML source code string.
	 *
	 * @param {string} html
	 * @returns {string}
	 */
	function textContent(html) {
		// remove all tags
		var text = html.replace(tagPattern, '');

		// decode known entities
		text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
			code = code.toLowerCase();

			if (code[0] === '#') {
				var value;
				if (code[1] === 'x') {
					value = parseInt(code.slice(2), 16);
				} else {
					value = Number(code.slice(1));
				}

				return fromCodePoint(value);
			} else {
				var known = KNOWN_ENTITY_NAMES[code];
				if (known) {
					return known;
				}

				// unable to decode
				return m;
			}
		});

		return text;
	}

	Prism.languages.md = Prism.languages.markdown;

}(Prism));

Prism.languages.markup = {
	'comment': {
		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
		greedy: true
	},
	'prolog': {
		pattern: /<\?[\s\S]+?\?>/,
		greedy: true
	},
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/i,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': {
		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
		greedy: true
	},
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						{
							pattern: /^(\s*)["']|["']$/,
							lookbehind: true
						}
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;

var prismTypescript = {};

var hasRequiredPrismTypescript;

function requirePrismTypescript () {
	if (hasRequiredPrismTypescript) return prismTypescript;
	hasRequiredPrismTypescript = 1;
	(function (Prism) {

		Prism.languages.typescript = Prism.languages.extend('javascript', {
			'class-name': {
				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'builtin': /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
		});

		// The keywords TypeScript adds to JavaScript
		Prism.languages.typescript.keyword.push(
			/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
			// keywords that have to be followed by an identifier
			/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
			// This is for `import type *, {}`
			/\btype\b(?=\s*(?:[\{*]|$))/
		);

		// doesn't work with TS because TS is too complex
		delete Prism.languages.typescript['parameter'];
		delete Prism.languages.typescript['literal-property'];

		// a version of typescript specifically for highlighting types
		var typeInside = Prism.languages.extend('typescript', {});
		delete typeInside['class-name'];

		Prism.languages.typescript['class-name'].inside = typeInside;

		Prism.languages.insertBefore('typescript', 'function', {
			'decorator': {
				pattern: /@[$\w\xA0-\uFFFF]+/,
				inside: {
					'at': {
						pattern: /^@/,
						alias: 'operator'
					},
					'function': /^[\s\S]+/
				}
			},
			'generic-function': {
				// e.g. foo<T extends "bar" | "baz">( ...
				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
				greedy: true,
				inside: {
					'function': /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
					'generic': {
						pattern: /<[\s\S]+/, // everything after the first <
						alias: 'class-name',
						inside: typeInside
					}
				}
			}
		});

		Prism.languages.ts = Prism.languages.typescript;

	}(Prism));
	return prismTypescript;
}

requirePrismTypescript();

const extensions = [
    markedExtendedAccordion({}),
    markedExtendedAlert({}),
    markedExtendedComments({}),
    markedExtendedEmbeds({}),
    markedExtendedFootnote({
        refMarkers: true, // Show [1] instead of just 1
        labelFormat: (id, number) => {
            const icons = {
                source: '📚',
                note: '📝',
                warning: '⚠️',
                explanation: '💡',
            };
            return id in icons ? icons[id] : number; // [number / id]
        },
    }),
    markedExtendedKanban({}),
    markedExtendedLists({
        interactiveCheckboxes: true,
        onCheckboxChange: (checkboxId, checked, metadata) => {
            console.log('Checkbox toggled:', checkboxId, checked, metadata);
            // Call the global update function from playground.ts
            if (window.updateMarkdownFromCheckbox) {
                window.updateMarkdownFromCheckbox(checkboxId, checked, metadata);
            }
        },
    }),
    markedExtendedSlide({}),
    markedExtendedSpoiler({}),
    markedExtendedTables({}),
    markedExtendedTabs({}),
    markedExtendedTimeline({}),
    markedExtendedTypographic({}),
    markedHighlight({
        emptyLangClass: 'language-plaintext',
        langPrefix: 'language-',
        highlight(code, lang) {
            const language = prismjs.languages[lang] ? lang : 'plaintext';
            return prismjs.highlight(code, prismjs.languages[language], language);
        },
    }),
];
g$2.use(...extensions, {
    gfm: true,
    breaks: false,
    pedantic: false,
    renderer: {
        link({ href, title, text }) {
            return `<a href="${href}" title="${title}" target="_blank">${text}</a>`;
        },
        heading({ tokens, depth }) {
            const text = this.parser.parseInline(tokens);
            const escapedText = text.toLowerCase().replace(/\W+/g, '-');
            return `
          <h${depth}>
            <a class="anchor" href="#${escapedText}">
              <span class="header-link"></span>
            </a>
            ${text}
          </h${depth}>`;
        },
    },
});
const mdRender = (md, mdBody) => {
    if (!mdBody)
        return;
    mdBody.innerHTML = g$2.parse(md);
    insertCopyElement();
};
/**
 * Updates checkbox state in Markdown source
 * Handles duplicate task names by matching both content and current checked state
 * @param markdown - The current Markdown text
 * @param rawText - The raw text of the list item to update
 * @param checked - The new checked state (what it should become)
 * @returns Updated Markdown with checkbox state changed
 */
const updateCheckboxInMarkdown = (markdown, rawText, checked) => {
    if (!rawText)
        return markdown;
    // Only trim trailing whitespace/newlines, preserve leading indentation
    const cleanRawText = rawText.replace(/\s+$/, '');
    // Extract indentation BEFORE any other processing
    const indentMatch = cleanRawText.match(/^(\s*)-/);
    const rawIndentString = indentMatch ? indentMatch[1] : '';
    const rawIndentDepth = rawIndentString.replace(/\t/g, '    ').length;
    // Extract the task text and current checkbox state from rawText
    // Use non-greedy regex to stop at the next checkbox (if present on the same line)
    const taskMatch = cleanRawText.match(/- \[([ xX])] (.+?)(?=\s+-\s*\[[ xX]]|$)/);
    if (!taskMatch)
        return markdown;
    const oldCheckboxState = taskMatch[1]; // ' ', 'x', or 'X'
    const taskText = taskMatch[2].trim();
    const wasChecked = oldCheckboxState.toLowerCase() === 'x';
    // Find the exact line with this task text, matching state, and indentation
    const lines = markdown.split('\n');
    let matchCount = 0;
    let updateIndex = -1;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        // Check if this line is a task list item
        const lineTaskMatch = line.match(/^(\s*)- \[([ xX])] (.+)$/);
        if (lineTaskMatch) {
            const [, indentation, currentState, lineTaskText] = lineTaskMatch;
            const lineChecked = currentState.toLowerCase() === 'x';
            const lineIndentDepth = indentation.replace(/\t/g, '    ').length;
            // Match by: task text, indentation depth (flexible), and current checked state
            if (lineTaskText.trim() === taskText
                && lineIndentDepth === rawIndentDepth
                && lineChecked === wasChecked) {
                // For duplicate tasks, we want the first unupdated match
                if (updateIndex === -1)
                    updateIndex = i;
                matchCount++;
            }
        }
    }
    // Update the matched line
    if (updateIndex !== -1) {
        const line = lines[updateIndex];
        const lineTaskMatch = line.match(/^(\s*)- \[([ xX])] (.+)$/);
        if (lineTaskMatch) {
            const [, indentation, , lineTaskText] = lineTaskMatch;
            const newCheckbox = checked ? 'x' : ' ';
            lines[updateIndex] = `${indentation}- [${newCheckbox}] ${lineTaskText}`;
            // Log warning if duplicates detected
            if (matchCount > 1) {
                console.warn(`[Checkbox Update] Found ${matchCount} tasks with text "${taskText}". Updated the first match.`);
            }
            return lines.join('\n');
        }
    }
    // Fallback: If the exact indentation match failed, try matching by text and state only
    // This handles cases where tokenizer indentation doesn't match source indentation
    console.warn(`[Checkbox Update] No exact match found. Trying fallback match for: "${taskText}"`);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineTaskMatch = line.match(/^(\s*)- \[([ xX])] (.+)$/);
        if (lineTaskMatch) {
            const [, indentation, currentState, lineTaskText] = lineTaskMatch;
            const lineChecked = currentState.toLowerCase() === 'x';
            // Match only by text and state (ignore indentation)
            if (lineTaskText.trim() === taskText && lineChecked === wasChecked) {
                console.log(`[Checkbox Update] Fallback match found at line ${i}`);
                const newCheckbox = checked ? 'x' : ' ';
                lines[i] = `${indentation}- [${newCheckbox}] ${lineTaskText}`;
                return lines.join('\n');
            }
        }
    }
    console.warn(`[Checkbox Update] Could not find matching task for: "${taskText}"`);
    return markdown;
};
const insertCopyElement = () => {
    document.querySelectorAll('pre').forEach((pre) => {
        // Skip if already has a copy button
        if (pre.querySelector('.copy-btn'))
            return;
        // Get the code element
        const codeElement = pre.querySelector('code');
        const codeText = (codeElement === null || codeElement === void 0 ? void 0 : codeElement.textContent) || pre.textContent || '';
        // Detect language from class
        let language = 'plaintext';
        if (codeElement) {
            const classList = Array.from(codeElement.classList);
            const langClass = classList.find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '');
            }
        }
        // Create a toolbar container
        const toolbar = document.createElement('div');
        toolbar.className = 'code-toolbar';
        // Create a language label
        if (language !== 'plaintext') {
            const langLabel = document.createElement('span');
            langLabel.className = 'code-language-label';
            langLabel.textContent = language.toUpperCase();
            langLabel.setAttribute('aria-label', `Code language: ${language}`);
            toolbar.appendChild(langLabel);
        }
        // Create a copy button
        const button = document.createElement('button');
        button.className = 'copy-btn';
        button.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M4 2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm0 1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4z"/>
        <path d="M2 6h1v6H2V6z"/>
      </svg>
      <span>Copy</span>
    `;
        button.setAttribute('data-clipboard-text', codeText);
        button.setAttribute('aria-label', 'Copy code to clipboard');
        button.setAttribute('type', 'button');
        toolbar.appendChild(button);
        pre.appendChild(toolbar);
    });
    // Initialize ClipboardJS with success/error callbacks
    const clipboard = new ClipboardJS('.copy-btn');
    clipboard.on('success', (e) => {
        const button = e.trigger;
        showCopySuccess(button);
        e.clearSelection();
    });
    clipboard.on('error', (e) => {
        const button = e.trigger;
        console.error('Copy failed:', e);
        showCopyError(button);
    });
};
/**
 * Show success state on copy button
 */
function showCopySuccess(button) {
    button.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"/>
    </svg>
    <span>Copied!</span>
  `;
    button.classList.add('copied');
    setTimeout(() => {
        button.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M4 2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm0 1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4z"/>
        <path d="M2 6h1v6H2V6z"/>
      </svg>
      <span>Copy</span>
    `;
        button.classList.remove('copied');
    }, 2000);
}
/**
 * Show error state on copy button
 */
function showCopyError(button) {
    button.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M8 0a8 8 0 100 16A8 8 0 008 0zM7 11V7h2v4H7zm0-6V3h2v2H7z"/>
    </svg>
    <span>Failed</span>
  `;
    setTimeout(() => {
        button.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M4 2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm0 1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4z"/>
        <path d="M2 6h1v6H2V6z"/>
      </svg>
      <span>Copy</span>
    `;
    }, 2000);
}

export { mdRender as m, updateCheckboxInMarkdown as u };
